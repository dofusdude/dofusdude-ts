/* tslint:disable */
/* eslint-disable */
/**
 * dofusdude
 * # Open Ankama Developer Community The all-in-one toolbelt for your next Ankama related project.  ## Versions - [Dofus 2](https://docs.dofusdu.de/dofus2/) - [Dofus 3](https://docs.dofusdu.de/dofus3/)   - v1 [latest] (you are here)   ## Client SDKs - [Javascript](https://github.com/dofusdude/dofusdude-js) `npm i dofusdude-js --save` - [Typescript](https://github.com/dofusdude/dofusdude-ts) `npm i dofusdude-ts --save` - [Go](https://github.com/dofusdude/dodugo) `go get -u github.com/dofusdude/dodugo` - [Python](https://github.com/dofusdude/dofusdude-py) `pip install dofusdude` - [Java](https://github.com/dofusdude/dofusdude-java) Maven with GitHub packages setup  Everything, including this site, is generated out of the [Docs Repo](https://github.com/dofusdude/api-docs). Consider it the Single Source of Truth. If there is a problem with the SDKs, create an issue there.  Your favorite language is missing? Please let me know!  # Main Features - ü•∑ **Seamless Auto-Update** load data in the background when a new Dofus version is released and serving it within 10 minutes with atomic data source switching. No downtime and no effects for the user, just always up-to-date.  - ‚ö° **Blazingly Fast** all data in-memory, aggressive caching over short time spans, HTTP/2 multiplexing, written in Go, optimized for low latency, hosted on bare metal in üá©üá™.  - üì® **Almanax Discord Integration** Use the endpoints as a dev or the official [Web Client](https://discord.dofusdude.com) as a user.  - ü©∏ **Dofus 3 Beta** from stable to bleeding edge by replacing /dofus3 with /dofus3beta.  - üó£Ô∏è **Multilingual** supporting _en_, _fr_, _es_, _pt_, _de_.  - üß† **Search by Relevance** allowing typos in name and description, handled by language specific text analysis and indexing.  - üïµÔ∏è **Official Sources** generated from actual data from the game.  ... and much more on the Roadmap on my [Discord](https://discord.gg/3EtHskZD8h). 
 *
 * The version of the OpenAPI document: 1.0.0-rc.8
 * Contact: stelzo@steado.de
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Almanax
 */
export interface Almanax {
    /**
     * 
     * @type {AlmanaxBonus}
     * @memberof Almanax
     */
    'bonus'?: AlmanaxBonus;
    /**
     * 
     * @type {string}
     * @memberof Almanax
     */
    'date'?: string;
    /**
     * 
     * @type {AlmanaxTribute}
     * @memberof Almanax
     */
    'tribute'?: AlmanaxTribute;
    /**
     * Amount of Kamas you get as reward for finishing this Almanax quest.
     * @type {number}
     * @memberof Almanax
     */
    'reward_kamas'?: number | null;
}
/**
 * 
 * @export
 * @interface AlmanaxBonus
 */
export interface AlmanaxBonus {
    /**
     * 
     * @type {string}
     * @memberof AlmanaxBonus
     */
    'description'?: string;
    /**
     * 
     * @type {GetMetaAlmanaxBonuses200ResponseInner}
     * @memberof AlmanaxBonus
     */
    'type'?: GetMetaAlmanaxBonuses200ResponseInner;
}
/**
 * 
 * @export
 * @interface AlmanaxTribute
 */
export interface AlmanaxTribute {
    /**
     * 
     * @type {AlmanaxTributeItem}
     * @memberof AlmanaxTribute
     */
    'item'?: AlmanaxTributeItem;
    /**
     * 
     * @type {number}
     * @memberof AlmanaxTribute
     */
    'quantity'?: number;
}
/**
 * 
 * @export
 * @interface AlmanaxTributeItem
 */
export interface AlmanaxTributeItem {
    /**
     * 
     * @type {number}
     * @memberof AlmanaxTributeItem
     */
    'ankama_id'?: number;
    /**
     * 
     * @type {Images}
     * @memberof AlmanaxTributeItem
     */
    'image_urls'?: Images;
    /**
     * 
     * @type {string}
     * @memberof AlmanaxTributeItem
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AlmanaxTributeItem
     */
    'subtype'?: string;
}
/**
 * 
 * @export
 * @interface AlmanaxWebhook
 */
export interface AlmanaxWebhook {
    /**
     * 
     * @type {string}
     * @memberof AlmanaxWebhook
     */
    'id'?: string;
    /**
     * 
     * @type {AlmanaxWebhookDailySettings}
     * @memberof AlmanaxWebhook
     */
    'daily_settings'?: AlmanaxWebhookDailySettings;
    /**
     * Only post when these bonuses come up. From all available bonuses (ids) from /dofus3/meta/{language}/almanax/bonuses.
     * @type {Array<string>}
     * @memberof AlmanaxWebhook
     */
    'bonus_whitelist'?: Array<string> | null;
    /**
     * Skip the day when these bonuses come up. From all available bonuses (ids) from /dofus3/meta/{language}/almanax/bonuses
     * @type {Array<string>}
     * @memberof AlmanaxWebhook
     */
    'bonus_blacklist'?: Array<string> | null;
    /**
     * Get the available subscriptions with /meta/webhooks/almanax
     * @type {Array<string>}
     * @memberof AlmanaxWebhook
     */
    'subscriptions'?: Array<string>;
    /**
     * If false, it will use common local time formats and weekday translations. If true, the format is YYYY-MM-DD.
     * @type {boolean}
     * @memberof AlmanaxWebhook
     */
    'iso_date'?: boolean;
    /**
     * Almanax bonus ids mapped to array of mentions.
     * @type {{ [key: string]: Array<CreateAlmanaxWebhookMentionsValueInner>; }}
     * @memberof AlmanaxWebhook
     */
    'mentions'?: { [key: string]: Array<CreateAlmanaxWebhookMentionsValueInner>; } | null;
    /**
     * - Daily posts each day, filtering with Black/Whitelist and mentions are applied daily. - Weekly posts the next 7 days (excluding the posting day) once per week at the specified time. With only weekly selected, of all mentions, only prior notices will come through daily. The 7 day preview gets filtered by the Black/Whitelist. - Monthly posts a preview of the next month from first to last date. The post will be on the last day of a month (ignoring day of the week) at the specified time. Mentions and filtering works like weekly. The biggest difference between daily and the other two is that daily always posts the current day while monthly and weekly only show future days. You can always combine the intervals by selecting multiple intervals for one hook or create multiple hooks for the same channel with different settings to get every highly specific combination you want.
     * @type {Set<string>}
     * @memberof AlmanaxWebhook
     */
    'intervals'?: Set<AlmanaxWebhookIntervalsEnum>;
    /**
     * When to post the weekly preview at the specified time.
     * @type {string}
     * @memberof AlmanaxWebhook
     */
    'weekly_weekday'?: AlmanaxWebhookWeeklyWeekdayEnum | null;
    /**
     * 
     * @type {string}
     * @memberof AlmanaxWebhook
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof AlmanaxWebhook
     */
    'last_fired_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AlmanaxWebhook
     */
    'updated_at'?: string;
}

export const AlmanaxWebhookIntervalsEnum = {
    Daily: 'daily',
    Weekly: 'weekly',
    Monthly: 'monthly'
} as const;

export type AlmanaxWebhookIntervalsEnum = typeof AlmanaxWebhookIntervalsEnum[keyof typeof AlmanaxWebhookIntervalsEnum];
export const AlmanaxWebhookWeeklyWeekdayEnum = {
    Sunday: 'sunday',
    Monday: 'monday',
    Tuesday: 'tuesday',
    Wednesday: 'wednesday',
    Thursday: 'thursday',
    Friday: 'friday',
    Saturday: 'saturday'
} as const;

export type AlmanaxWebhookWeeklyWeekdayEnum = typeof AlmanaxWebhookWeeklyWeekdayEnum[keyof typeof AlmanaxWebhookWeeklyWeekdayEnum];

/**
 * 
 * @export
 * @interface AlmanaxWebhookDailySettings
 */
export interface AlmanaxWebhookDailySettings {
    /**
     * Timezone of your community to determine midnight.
     * @type {string}
     * @memberof AlmanaxWebhookDailySettings
     */
    'timezone'?: string;
    /**
     * Hours added to midnight at the selected timezone. 8 = 8:00 in the morning.
     * @type {number}
     * @memberof AlmanaxWebhookDailySettings
     */
    'midnight_offset'?: number;
}
/**
 * 
 * @export
 * @interface Condition
 */
export interface Condition {
    /**
     * 
     * @type {string}
     * @memberof Condition
     */
    'operator'?: string;
    /**
     * 
     * @type {number}
     * @memberof Condition
     */
    'int_value'?: number;
    /**
     * 
     * @type {TranslatedId}
     * @memberof Condition
     */
    'element'?: TranslatedId;
}
/**
 * 
 * @export
 * @interface ConditionLeaf
 */
export interface ConditionLeaf {
    /**
     * always \"true\" for the leaf of a tree
     * @type {boolean}
     * @memberof ConditionLeaf
     */
    'is_operand'?: boolean;
    /**
     * 
     * @type {Condition}
     * @memberof ConditionLeaf
     */
    'condition'?: Condition;
}
/**
 * @type ConditionNode
 * @export
 */
export type ConditionNode = ConditionLeaf | ConditionRelation;

/**
 * 
 * @export
 * @interface ConditionRelation
 */
export interface ConditionRelation {
    /**
     * always \"false\" for relations
     * @type {boolean}
     * @memberof ConditionRelation
     */
    'is_operand'?: boolean;
    /**
     * \"and\", \"or\"
     * @type {string}
     * @memberof ConditionRelation
     */
    'relation'?: string;
    /**
     * 
     * @type {Array<ConditionNode | null>}
     * @memberof ConditionRelation
     */
    'children'?: Array<ConditionNode | null>;
}
/**
 * 
 * @export
 * @interface CreateAlmanaxWebhook
 */
export interface CreateAlmanaxWebhook {
    /**
     * from all available bonuses (ids) from /dofus3/meta/{language}/almanax/bonuses
     * @type {Array<string>}
     * @memberof CreateAlmanaxWebhook
     */
    'bonus_whitelist'?: Array<string> | null;
    /**
     * from all available bonuses (ids) from /dofus3/meta/{language}/almanax/bonuses
     * @type {Array<string>}
     * @memberof CreateAlmanaxWebhook
     */
    'bonus_blacklist'?: Array<string> | null;
    /**
     * Get the available subscriptions with /meta/webhooks/almanax
     * @type {Array<string>}
     * @memberof CreateAlmanaxWebhook
     */
    'subscriptions': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreateAlmanaxWebhook
     */
    'format': CreateAlmanaxWebhookFormatEnum;
    /**
     * Discord Webhook URL
     * @type {string}
     * @memberof CreateAlmanaxWebhook
     */
    'callback': string;
    /**
     * 
     * @type {CreateAlmanaxWebhookDailySettings}
     * @memberof CreateAlmanaxWebhook
     */
    'daily_settings'?: CreateAlmanaxWebhookDailySettings | null;
    /**
     * If false, it will use common local time formats and weekday translations. If true, the format is YYYY-MM-DD.
     * @type {boolean}
     * @memberof CreateAlmanaxWebhook
     */
    'iso_date'?: boolean | null;
    /**
     * Almanax bonus ids mapped to array of mentions.
     * @type {{ [key: string]: Array<CreateAlmanaxWebhookMentionsValueInner>; }}
     * @memberof CreateAlmanaxWebhook
     */
    'mentions'?: { [key: string]: Array<CreateAlmanaxWebhookMentionsValueInner>; } | null;
    /**
     * - Daily posts each day, filtering with Black/Whitelist and mentions are applied daily. - Weekly posts the next 7 days (excluding the posting day) once per week at the specified time. With only weekly selected, of all mentions, only prior notices will come through daily. The 7 day preview gets filtered by the Black/Whitelist. - Monthly posts a preview of the next month from first to last date. The post will be on the last day of a month (ignoring day of the week) at the specified time. Mentions and filtering works like weekly. The biggest difference between daily and the other two is that daily always posts the current day while monthly and weekly only show future days. You can always combine the intervals by selecting multiple intervals for one hook or create multiple hooks for the same channel with different settings to get every highly specific combination you want.
     * @type {Set<string>}
     * @memberof CreateAlmanaxWebhook
     */
    'intervals': Set<CreateAlmanaxWebhookIntervalsEnum>;
    /**
     * When to post the weekly preview at the specified time.
     * @type {string}
     * @memberof CreateAlmanaxWebhook
     */
    'weekly_weekday'?: CreateAlmanaxWebhookWeeklyWeekdayEnum | null;
}

export const CreateAlmanaxWebhookFormatEnum = {
    Discord: 'discord'
} as const;

export type CreateAlmanaxWebhookFormatEnum = typeof CreateAlmanaxWebhookFormatEnum[keyof typeof CreateAlmanaxWebhookFormatEnum];
export const CreateAlmanaxWebhookIntervalsEnum = {
    Daily: 'daily',
    Weekly: 'weekly',
    Monthly: 'monthly'
} as const;

export type CreateAlmanaxWebhookIntervalsEnum = typeof CreateAlmanaxWebhookIntervalsEnum[keyof typeof CreateAlmanaxWebhookIntervalsEnum];
export const CreateAlmanaxWebhookWeeklyWeekdayEnum = {
    Sunday: 'sunday',
    Monday: 'monday',
    Tuesday: 'tuesday',
    Wednesday: 'wednesday',
    Thursday: 'thursday',
    Friday: 'friday',
    Saturday: 'saturday'
} as const;

export type CreateAlmanaxWebhookWeeklyWeekdayEnum = typeof CreateAlmanaxWebhookWeeklyWeekdayEnum[keyof typeof CreateAlmanaxWebhookWeeklyWeekdayEnum];

/**
 * 
 * @export
 * @interface CreateAlmanaxWebhookDailySettings
 */
export interface CreateAlmanaxWebhookDailySettings {
    /**
     * Timezone of your community to determine midnight.
     * @type {string}
     * @memberof CreateAlmanaxWebhookDailySettings
     */
    'timezone'?: string | null;
    /**
     * Hours added to midnight at the selected timezone. 8 = 8:00 in the morning.
     * @type {number}
     * @memberof CreateAlmanaxWebhookDailySettings
     */
    'midnight_offset'?: number | null;
}
/**
 * Mention
 * @export
 * @interface CreateAlmanaxWebhookMentionsValueInner
 */
export interface CreateAlmanaxWebhookMentionsValueInner {
    /**
     * User or role ID directly from Discord. Activate developer mode and right click a user or role to get them.
     * @type {number}
     * @memberof CreateAlmanaxWebhookMentionsValueInner
     */
    'discord_id'?: number;
    /**
     * Whether an ID describes a role (true) or user (false). This is needed for formatting the mention command so Discord understands it.
     * @type {boolean}
     * @memberof CreateAlmanaxWebhookMentionsValueInner
     */
    'is_role'?: boolean;
    /**
     * Get a mention days before the bonus comes up. It will post on the specified time. Also works when the interval is not daily.
     * @type {number}
     * @memberof CreateAlmanaxWebhookMentionsValueInner
     */
    'ping_days_before'?: number | null;
}
/**
 * 
 * @export
 * @interface CreateRSSWebhook
 */
export interface CreateRSSWebhook {
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateRSSWebhook
     */
    'whitelist'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateRSSWebhook
     */
    'blacklist'?: Array<string> | null;
    /**
     * Get the available subscriptions with /meta/webhooks/rss
     * @type {Set<string>}
     * @memberof CreateRSSWebhook
     */
    'subscriptions': Set<string>;
    /**
     * 
     * @type {string}
     * @memberof CreateRSSWebhook
     */
    'format': CreateRSSWebhookFormatEnum;
    /**
     * 
     * @type {number}
     * @memberof CreateRSSWebhook
     */
    'preview_length'?: number | null;
    /**
     * Discord Webhook URL
     * @type {string}
     * @memberof CreateRSSWebhook
     */
    'callback': string;
}

export const CreateRSSWebhookFormatEnum = {
    Discord: 'discord'
} as const;

export type CreateRSSWebhookFormatEnum = typeof CreateRSSWebhookFormatEnum[keyof typeof CreateRSSWebhookFormatEnum];

/**
 * 
 * @export
 * @interface CreateTwitterWebhook
 */
export interface CreateTwitterWebhook {
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateTwitterWebhook
     */
    'whitelist'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateTwitterWebhook
     */
    'blacklist'?: Array<string> | null;
    /**
     * Get the available subscriptions with /meta/webhooks/twitter
     * @type {Set<string>}
     * @memberof CreateTwitterWebhook
     */
    'subscriptions': Set<string>;
    /**
     * 
     * @type {string}
     * @memberof CreateTwitterWebhook
     */
    'format': CreateTwitterWebhookFormatEnum;
    /**
     * 
     * @type {number}
     * @memberof CreateTwitterWebhook
     */
    'preview_length'?: number | null;
    /**
     * Discord Webhook URL
     * @type {string}
     * @memberof CreateTwitterWebhook
     */
    'callback': string;
}

export const CreateTwitterWebhookFormatEnum = {
    Discord: 'discord'
} as const;

export type CreateTwitterWebhookFormatEnum = typeof CreateTwitterWebhookFormatEnum[keyof typeof CreateTwitterWebhookFormatEnum];

/**
 * 
 * @export
 * @interface Effect
 */
export interface Effect {
    /**
     * minimum int value, can be a single if ignore_int_max and no ignore_int_min
     * @type {number}
     * @memberof Effect
     */
    'int_minimum'?: number;
    /**
     * maximum int value, if not ignore_int_max and not ignore_int_min, the effect has a range value
     * @type {number}
     * @memberof Effect
     */
    'int_maximum'?: number;
    /**
     * 
     * @type {EffectType}
     * @memberof Effect
     */
    'type'?: EffectType;
    /**
     * ignore the int min field because the actual value is a string. For readability the templated field is the only important field in this case. 
     * @type {boolean}
     * @memberof Effect
     */
    'ignore_int_min'?: boolean;
    /**
     * ignore the int max field, if ignore_int_min is true, int min is a single value
     * @type {boolean}
     * @memberof Effect
     */
    'ignore_int_max'?: boolean;
    /**
     * all fields from above encoded in a single string
     * @type {string}
     * @memberof Effect
     */
    'formatted'?: string;
}
/**
 * 
 * @export
 * @interface EffectType
 */
export interface EffectType {
    /**
     * 
     * @type {number}
     * @memberof EffectType
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof EffectType
     */
    'name'?: string;
    /**
     * Affects target or source actively.
     * @type {boolean}
     * @memberof EffectType
     */
    'is_active'?: boolean;
    /**
     * true if a type is generated from the Api instead of Ankama. In that case, always prefer showing the templated string and omit everything else. The \"name\" field will have an english description of the meta type. An example for such effects are class sets effects.
     * @type {boolean}
     * @memberof EffectType
     */
    'is_meta'?: boolean;
}
/**
 * 
 * @export
 * @interface Equipment
 */
export interface Equipment {
    /**
     * 
     * @type {number}
     * @memberof Equipment
     */
    'ankama_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Equipment
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Equipment
     */
    'description'?: string;
    /**
     * 
     * @type {TranslatedId}
     * @memberof Equipment
     */
    'type'?: TranslatedId;
    /**
     * 
     * @type {boolean}
     * @memberof Equipment
     */
    'is_weapon'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Equipment
     */
    'level'?: number;
    /**
     * 
     * @type {number}
     * @memberof Equipment
     */
    'pods'?: number;
    /**
     * 
     * @type {Images}
     * @memberof Equipment
     */
    'image_urls'?: Images;
    /**
     * 
     * @type {Array<Effect>}
     * @memberof Equipment
     */
    'effects'?: Array<Effect> | null;
    /**
     * 
     * @type {ConditionNode}
     * @memberof Equipment
     */
    'conditions'?: ConditionNode | null;
    /**
     * 
     * @type {Array<Recipe>}
     * @memberof Equipment
     */
    'recipe'?: Array<Recipe> | null;
    /**
     * 
     * @type {TranslatedId}
     * @memberof Equipment
     */
    'parent_set'?: TranslatedId | null;
}
/**
 * 
 * @export
 * @interface EquipmentSet
 */
export interface EquipmentSet {
    /**
     * 
     * @type {number}
     * @memberof EquipmentSet
     */
    'ankama_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof EquipmentSet
     */
    'name'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof EquipmentSet
     */
    'equipment_ids'?: Array<number>;
    /**
     * 
     * @type {{ [key: string]: Array<Effect>; }}
     * @memberof EquipmentSet
     */
    'effects'?: { [key: string]: Array<Effect>; };
    /**
     * 
     * @type {number}
     * @memberof EquipmentSet
     */
    'highest_equipment_level'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof EquipmentSet
     */
    'contains_cosmetics'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EquipmentSet
     */
    'contains_cosmetics_only'?: boolean;
}
/**
 * 
 * @export
 * @interface GameSearch
 */
export interface GameSearch {
    /**
     * 
     * @type {number}
     * @memberof GameSearch
     */
    'ankama_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof GameSearch
     */
    'name'?: string;
    /**
     * 
     * @type {GameSearchType}
     * @memberof GameSearch
     */
    'type'?: GameSearchType;
    /**
     * 
     * @type {GameSearchItem}
     * @memberof GameSearch
     */
    'item_fields'?: GameSearchItem;
}
/**
 * 
 * @export
 * @interface GameSearchItem
 */
export interface GameSearchItem {
    /**
     * 
     * @type {GameSearchType}
     * @memberof GameSearchItem
     */
    'type'?: GameSearchType;
    /**
     * 
     * @type {number}
     * @memberof GameSearchItem
     */
    'level'?: number | null;
    /**
     * 
     * @type {Images}
     * @memberof GameSearchItem
     */
    'image_urls'?: Images;
}
/**
 * 
 * @export
 * @interface GameSearchType
 */
export interface GameSearchType {
    /**
     * 
     * @type {string}
     * @memberof GameSearchType
     */
    'name_id'?: string;
}
/**
 * 
 * @export
 * @interface GetMetaAlmanaxBonuses200ResponseInner
 */
export interface GetMetaAlmanaxBonuses200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof GetMetaAlmanaxBonuses200ResponseInner
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetMetaAlmanaxBonuses200ResponseInner
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface GetMetaWebhooksTwitter200Response
 */
export interface GetMetaWebhooksTwitter200Response {
    /**
     * 
     * @type {Array<string>}
     * @memberof GetMetaWebhooksTwitter200Response
     */
    'subscriptions'?: Array<string>;
}
/**
 * All images except icon are rendered in the background which can take some time (up to hours if all data is completely generated from scratch). Because of this, they can be null if they are not yet rendered.
 * @export
 * @interface Images
 */
export interface Images {
    /**
     * 64x64 px, always available
     * @type {string}
     * @memberof Images
     */
    'icon'?: string;
    /**
     * around 2x the resolution of icon
     * @type {string}
     * @memberof Images
     */
    'sd'?: string | null;
    /**
     * around 2x the resolution of sd
     * @type {string}
     * @memberof Images
     */
    'hq'?: string | null;
    /**
     * around 2x the resolution of hd
     * @type {string}
     * @memberof Images
     */
    'hd'?: string | null;
}
/**
 * 
 * @export
 * @interface ItemSubtype
 */
export interface ItemSubtype {
    /**
     * 
     * @type {number}
     * @memberof ItemSubtype
     */
    'ankama_id'?: number;
    /**
     * unique
     * @type {string}
     * @memberof ItemSubtype
     */
    'name_id'?: string;
}
/**
 * 
 * @export
 * @interface ListEquipmentSet
 */
export interface ListEquipmentSet {
    /**
     * 
     * @type {number}
     * @memberof ListEquipmentSet
     */
    'ankama_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ListEquipmentSet
     */
    'name'?: string;
    /**
     * amount
     * @type {number}
     * @memberof ListEquipmentSet
     */
    'items'?: number;
    /**
     * 
     * @type {number}
     * @memberof ListEquipmentSet
     */
    'level'?: number;
    /**
     * 
     * @type {{ [key: string]: Array<Effect>; }}
     * @memberof ListEquipmentSet
     */
    'effects'?: { [key: string]: Array<Effect>; };
    /**
     * 
     * @type {Array<number>}
     * @memberof ListEquipmentSet
     */
    'equipment_ids'?: Array<number> | null;
    /**
     * 
     * @type {boolean}
     * @memberof ListEquipmentSet
     */
    'contains_cosmetics'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ListEquipmentSet
     */
    'contains_cosmetics_only'?: boolean;
}
/**
 * 
 * @export
 * @interface ListEquipmentSets
 */
export interface ListEquipmentSets {
    /**
     * 
     * @type {PagedLinks}
     * @memberof ListEquipmentSets
     */
    '_links'?: PagedLinks;
    /**
     * 
     * @type {Array<ListEquipmentSet>}
     * @memberof ListEquipmentSets
     */
    'sets'?: Array<ListEquipmentSet>;
}
/**
 * 
 * @export
 * @interface ListItem
 */
export interface ListItem {
    /**
     * 
     * @type {number}
     * @memberof ListItem
     */
    'ankama_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ListItem
     */
    'name'?: string;
    /**
     * 
     * @type {TranslatedId}
     * @memberof ListItem
     */
    'type'?: TranslatedId;
    /**
     * 
     * @type {number}
     * @memberof ListItem
     */
    'level'?: number;
    /**
     * 
     * @type {Images}
     * @memberof ListItem
     */
    'image_urls'?: Images;
    /**
     * 
     * @type {Array<Recipe>}
     * @memberof ListItem
     */
    'recipe'?: Array<Recipe> | null;
    /**
     * 
     * @type {string}
     * @memberof ListItem
     */
    'description'?: string | null;
    /**
     * 
     * @type {ConditionNode}
     * @memberof ListItem
     */
    'conditions'?: ConditionNode | null;
    /**
     * 
     * @type {Array<Effect>}
     * @memberof ListItem
     */
    'effects'?: Array<Effect> | null;
    /**
     * 
     * @type {boolean}
     * @memberof ListItem
     */
    'is_weapon'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof ListItem
     */
    'pods'?: number | null;
    /**
     * 
     * @type {TranslatedId}
     * @memberof ListItem
     */
    'parent_set'?: TranslatedId | null;
    /**
     * 
     * @type {number}
     * @memberof ListItem
     */
    'critical_hit_probability'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ListItem
     */
    'critical_hit_bonus'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ListItem
     */
    'max_cast_per_turn'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ListItem
     */
    'ap_cost'?: number | null;
    /**
     * 
     * @type {Range}
     * @memberof ListItem
     */
    'range'?: Range;
}
/**
 * 
 * @export
 * @interface ListItemGeneral
 */
export interface ListItemGeneral {
    /**
     * 
     * @type {number}
     * @memberof ListItemGeneral
     */
    'ankama_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ListItemGeneral
     */
    'name'?: string;
    /**
     * 
     * @type {TranslatedId}
     * @memberof ListItemGeneral
     */
    'type'?: TranslatedId;
    /**
     * 
     * @type {ItemSubtype}
     * @memberof ListItemGeneral
     */
    'item_subtype'?: ItemSubtype;
    /**
     * 
     * @type {number}
     * @memberof ListItemGeneral
     */
    'level'?: number;
    /**
     * 
     * @type {Images}
     * @memberof ListItemGeneral
     */
    'image_urls'?: Images;
}
/**
 * 
 * @export
 * @interface ListItems
 */
export interface ListItems {
    /**
     * 
     * @type {PagedLinks}
     * @memberof ListItems
     */
    '_links'?: PagedLinks;
    /**
     * 
     * @type {Array<ListItem>}
     * @memberof ListItems
     */
    'items'?: Array<ListItem>;
}
/**
 * 
 * @export
 * @interface ListMounts
 */
export interface ListMounts {
    /**
     * 
     * @type {PagedLinks}
     * @memberof ListMounts
     */
    '_links'?: PagedLinks;
    /**
     * 
     * @type {Array<Mount>}
     * @memberof ListMounts
     */
    'items'?: Array<Mount>;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * HTTP status code
     * @type {number}
     * @memberof ModelError
     */
    'status'?: number;
    /**
     * HTTP status as text
     * @type {string}
     * @memberof ModelError
     */
    'error'?: string;
    /**
     * API specific error identifier for switch-case handling
     * @type {string}
     * @memberof ModelError
     */
    'code'?: string;
    /**
     * General, human-friendly error description
     * @type {string}
     * @memberof ModelError
     */
    'message'?: string;
    /**
     * Detailed, human-friendly problem description adopting specific inputs of the request
     * @type {string}
     * @memberof ModelError
     */
    'details'?: string;
}
/**
 * 
 * @export
 * @interface Mount
 */
export interface Mount {
    /**
     * 
     * @type {number}
     * @memberof Mount
     */
    'ankama_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Mount
     */
    'name'?: string;
    /**
     * 
     * @type {MountFamily}
     * @memberof Mount
     */
    'family'?: MountFamily;
    /**
     * 
     * @type {Images}
     * @memberof Mount
     */
    'image_urls'?: Images;
    /**
     * 
     * @type {Array<Effect>}
     * @memberof Mount
     */
    'effects'?: Array<Effect> | null;
}
/**
 * 
 * @export
 * @interface MountFamily
 */
export interface MountFamily {
    /**
     * 
     * @type {number}
     * @memberof MountFamily
     */
    'ankama_id'?: number;
    /**
     * localized name
     * @type {string}
     * @memberof MountFamily
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface PagedLinks
 */
export interface PagedLinks {
    /**
     * 
     * @type {string}
     * @memberof PagedLinks
     */
    'first'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PagedLinks
     */
    'prev'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PagedLinks
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PagedLinks
     */
    'last'?: string | null;
}
/**
 * 
 * @export
 * @interface PutAlmanaxWebhook
 */
export interface PutAlmanaxWebhook {
    /**
     * from all available bonuses (ids) from /dofus3/meta/{language}/almanax/bonuses. Delete old entries with empty array []. Just null changes nothing.
     * @type {Array<string>}
     * @memberof PutAlmanaxWebhook
     */
    'bonus_whitelist'?: Array<string> | null;
    /**
     * from all available bonuses (ids) from /dofus3/meta/{language}/almanax/bonuses. Delete old entries with empty array []. Just null changes nothing.
     * @type {Array<string>}
     * @memberof PutAlmanaxWebhook
     */
    'bonus_blacklist'?: Array<string> | null;
    /**
     * Get the available subscriptions with /meta/webhooks/almanax
     * @type {Array<string>}
     * @memberof PutAlmanaxWebhook
     */
    'subscriptions'?: Array<string> | null;
    /**
     * 
     * @type {CreateAlmanaxWebhookDailySettings}
     * @memberof PutAlmanaxWebhook
     */
    'daily_settings'?: CreateAlmanaxWebhookDailySettings | null;
    /**
     * If false, it will use common local time formats and weekday translations. If true, the format is YYYY-MM-DD.
     * @type {boolean}
     * @memberof PutAlmanaxWebhook
     */
    'iso_date'?: boolean | null;
    /**
     * Almanax bonus ids mapped to array of mentions.
     * @type {{ [key: string]: Array<CreateAlmanaxWebhookMentionsValueInner>; }}
     * @memberof PutAlmanaxWebhook
     */
    'mentions'?: { [key: string]: Array<CreateAlmanaxWebhookMentionsValueInner>; };
    /**
     * 
     * @type {Set<string>}
     * @memberof PutAlmanaxWebhook
     */
    'intervals'?: Set<PutAlmanaxWebhookIntervalsEnum> | null;
    /**
     * When to post the weekly preview at the specified time.
     * @type {string}
     * @memberof PutAlmanaxWebhook
     */
    'weekly_weekday'?: PutAlmanaxWebhookWeeklyWeekdayEnum | null;
}

export const PutAlmanaxWebhookIntervalsEnum = {
    Daily: 'daily',
    Weekly: 'weekly',
    Monthly: 'monthly'
} as const;

export type PutAlmanaxWebhookIntervalsEnum = typeof PutAlmanaxWebhookIntervalsEnum[keyof typeof PutAlmanaxWebhookIntervalsEnum];
export const PutAlmanaxWebhookWeeklyWeekdayEnum = {
    Sunday: 'sunday',
    Monday: 'monday',
    Tuesday: 'tuesday',
    Wednesday: 'wednesday',
    Thursday: 'thursday',
    Friday: 'friday',
    Saturday: 'saturday'
} as const;

export type PutAlmanaxWebhookWeeklyWeekdayEnum = typeof PutAlmanaxWebhookWeeklyWeekdayEnum[keyof typeof PutAlmanaxWebhookWeeklyWeekdayEnum];

/**
 * 
 * @export
 * @interface PutRSSWebhook
 */
export interface PutRSSWebhook {
    /**
     * 
     * @type {Array<string>}
     * @memberof PutRSSWebhook
     */
    'whitelist'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof PutRSSWebhook
     */
    'blacklist'?: Array<string> | null;
    /**
     * Get the available subscriptions with /meta/webhooks/rss
     * @type {Set<string>}
     * @memberof PutRSSWebhook
     */
    'subscriptions'?: Set<string> | null;
    /**
     * 
     * @type {number}
     * @memberof PutRSSWebhook
     */
    'preview_length'?: number | null;
}
/**
 * 
 * @export
 * @interface PutTwitterWebhook
 */
export interface PutTwitterWebhook {
    /**
     * 
     * @type {Array<string>}
     * @memberof PutTwitterWebhook
     */
    'whitelist'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof PutTwitterWebhook
     */
    'blacklist'?: Array<string> | null;
    /**
     * Get the available subscriptions with /meta/webhooks/twitter
     * @type {Set<string>}
     * @memberof PutTwitterWebhook
     */
    'subscriptions'?: Set<string> | null;
    /**
     * 
     * @type {number}
     * @memberof PutTwitterWebhook
     */
    'preview_length'?: number | null;
}
/**
 * 
 * @export
 * @interface Range
 */
export interface Range {
    /**
     * 
     * @type {number}
     * @memberof Range
     */
    'min'?: number;
    /**
     * 
     * @type {number}
     * @memberof Range
     */
    'max'?: number;
}
/**
 * 
 * @export
 * @interface Recipe
 */
export interface Recipe {
    /**
     * 
     * @type {number}
     * @memberof Recipe
     */
    'item_ankama_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Recipe
     */
    'item_subtype'?: string;
    /**
     * 
     * @type {number}
     * @memberof Recipe
     */
    'quantity'?: number;
}
/**
 * 
 * @export
 * @interface Resource
 */
export interface Resource {
    /**
     * 
     * @type {number}
     * @memberof Resource
     */
    'ankama_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Resource
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Resource
     */
    'description'?: string;
    /**
     * 
     * @type {TranslatedId}
     * @memberof Resource
     */
    'type'?: TranslatedId;
    /**
     * 
     * @type {number}
     * @memberof Resource
     */
    'level'?: number;
    /**
     * 
     * @type {number}
     * @memberof Resource
     */
    'pods'?: number;
    /**
     * 
     * @type {Images}
     * @memberof Resource
     */
    'image_urls'?: Images;
    /**
     * 
     * @type {Array<Effect>}
     * @memberof Resource
     */
    'effects'?: Array<Effect> | null;
    /**
     * 
     * @type {ConditionNode}
     * @memberof Resource
     */
    'conditions'?: ConditionNode | null;
    /**
     * 
     * @type {Array<Recipe>}
     * @memberof Resource
     */
    'recipe'?: Array<Recipe> | null;
}
/**
 * 
 * @export
 * @interface RssWebhook
 */
export interface RssWebhook {
    /**
     * 
     * @type {string}
     * @memberof RssWebhook
     */
    'id'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RssWebhook
     */
    'whitelist'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof RssWebhook
     */
    'blacklist'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof RssWebhook
     */
    'subscriptions'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof RssWebhook
     */
    'format'?: RssWebhookFormatEnum;
    /**
     * 
     * @type {number}
     * @memberof RssWebhook
     */
    'preview_length'?: number;
    /**
     * 
     * @type {string}
     * @memberof RssWebhook
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof RssWebhook
     */
    'last_fired_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RssWebhook
     */
    'updated_at'?: string;
}

export const RssWebhookFormatEnum = {
    Discord: 'discord'
} as const;

export type RssWebhookFormatEnum = typeof RssWebhookFormatEnum[keyof typeof RssWebhookFormatEnum];

/**
 * 
 * @export
 * @interface TranslatedId
 */
export interface TranslatedId {
    /**
     * unique
     * @type {number}
     * @memberof TranslatedId
     */
    'id'?: number;
    /**
     * localized name
     * @type {string}
     * @memberof TranslatedId
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface TwitterWebhook
 */
export interface TwitterWebhook {
    /**
     * 
     * @type {string}
     * @memberof TwitterWebhook
     */
    'id'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TwitterWebhook
     */
    'whitelist'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof TwitterWebhook
     */
    'blacklist'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof TwitterWebhook
     */
    'subscriptions'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof TwitterWebhook
     */
    'format'?: TwitterWebhookFormatEnum;
    /**
     * 
     * @type {number}
     * @memberof TwitterWebhook
     */
    'preview_length'?: number;
    /**
     * 
     * @type {string}
     * @memberof TwitterWebhook
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof TwitterWebhook
     */
    'last_fired_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TwitterWebhook
     */
    'updated_at'?: string;
}

export const TwitterWebhookFormatEnum = {
    Discord: 'discord'
} as const;

export type TwitterWebhookFormatEnum = typeof TwitterWebhookFormatEnum[keyof typeof TwitterWebhookFormatEnum];

/**
 * 
 * @export
 * @interface Version
 */
export interface Version {
    /**
     * 
     * @type {string}
     * @memberof Version
     */
    'version'?: string;
    /**
     * 
     * @type {string}
     * @memberof Version
     */
    'release'?: string;
    /**
     * 
     * @type {string}
     * @memberof Version
     */
    'update_stamp'?: string;
}
/**
 * 
 * @export
 * @interface Weapon
 */
export interface Weapon {
    /**
     * 
     * @type {number}
     * @memberof Weapon
     */
    'ankama_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Weapon
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Weapon
     */
    'description'?: string;
    /**
     * 
     * @type {TranslatedId}
     * @memberof Weapon
     */
    'type'?: TranslatedId;
    /**
     * always true when the item is a weapon. Many fields are now available. Always check for this flag first when getting single equipment items.
     * @type {boolean}
     * @memberof Weapon
     */
    'is_weapon'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Weapon
     */
    'level'?: number;
    /**
     * 
     * @type {number}
     * @memberof Weapon
     */
    'pods'?: number;
    /**
     * 
     * @type {Images}
     * @memberof Weapon
     */
    'image_urls'?: Images;
    /**
     * 
     * @type {Array<Effect>}
     * @memberof Weapon
     */
    'effects'?: Array<Effect> | null;
    /**
     * 
     * @type {ConditionNode}
     * @memberof Weapon
     */
    'conditions'?: ConditionNode | null;
    /**
     * 
     * @type {number}
     * @memberof Weapon
     */
    'critical_hit_probability'?: number;
    /**
     * 
     * @type {number}
     * @memberof Weapon
     */
    'critical_hit_bonus'?: number;
    /**
     * 
     * @type {number}
     * @memberof Weapon
     */
    'max_cast_per_turn'?: number;
    /**
     * 
     * @type {number}
     * @memberof Weapon
     */
    'ap_cost'?: number;
    /**
     * 
     * @type {Range}
     * @memberof Weapon
     */
    'range'?: Range;
    /**
     * 
     * @type {Array<Recipe>}
     * @memberof Weapon
     */
    'recipe'?: Array<Recipe> | null;
    /**
     * 
     * @type {TranslatedId}
     * @memberof Weapon
     */
    'parent_set'?: TranslatedId | null;
}

/**
 * AlmanaxApi - axios parameter creator
 * @export
 */
export const AlmanaxApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a single date. There are not more details in the returned object than the normal range endpoint.
         * @summary Single Almanax Date
         * @param {GetAlmanaxDateLanguageEnum} language code
         * @param {string} date yyyy-mm-dd
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlmanaxDate: async (language: GetAlmanaxDateLanguageEnum, date: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getAlmanaxDate', 'language', language)
            // verify required parameter 'date' is not null or undefined
            assertParamExists('getAlmanaxDate', 'date', date)
            const localVarPath = `/dofus3/v1/{language}/almanax/{date}`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a range of dates, defaults to today + 6 following days but can specified by the query parameters.   filter[bonus_type] can be used seperately and does not have an effect on the other parameters.  range[from] changes the start date, everything else defaults to 6 following dates from this start date.  range[to] when used without anything else, it will use today as start date and this parameter as end. All ranges are inclusive.  range[from] + range[to] = inclusive range over the specified dates, should never be farther apart than 35 days.  range[from|to] + range[size] no need to specify the date, just following days with [from] (0 is today) or go backwards in time with only [to] and [size].  Not all combinations are listed but this should give you an idea how to they could work.
         * @summary Almanax Range
         * @param {GetAlmanaxRangeLanguageEnum} language code
         * @param {string} [filterBonusType] ids from meta/{language}/almanax/bonuses
         * @param {string} [rangeFrom] yyyy-mm-dd
         * @param {string} [rangeTo] yyyy-mm-dd
         * @param {number} [rangeSize] Size of the returned range. Disable to fully use the range by setting size to -1.
         * @param {string} [timezone] determine what the current time is. If you live in Brazil, \&quot;today\&quot; will be hours apart from Paris. Use your timezone to get results relative to your location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlmanaxRange: async (language: GetAlmanaxRangeLanguageEnum, filterBonusType?: string, rangeFrom?: string, rangeTo?: string, rangeSize?: number, timezone?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getAlmanaxRange', 'language', language)
            const localVarPath = `/dofus3/v1/{language}/almanax`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filterBonusType !== undefined) {
                localVarQueryParameter['filter[bonus_type]'] = filterBonusType;
            }

            if (rangeFrom !== undefined) {
                localVarQueryParameter['range[from]'] = (rangeFrom as any instanceof Date) ?
                    (rangeFrom as any).toISOString().substring(0,10) :
                    rangeFrom;
            }

            if (rangeTo !== undefined) {
                localVarQueryParameter['range[to]'] = (rangeTo as any instanceof Date) ?
                    (rangeTo as any).toISOString().substring(0,10) :
                    rangeTo;
            }

            if (rangeSize !== undefined) {
                localVarQueryParameter['range[size]'] = rangeSize;
            }

            if (timezone !== undefined) {
                localVarQueryParameter['timezone'] = timezone;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AlmanaxApi - functional programming interface
 * @export
 */
export const AlmanaxApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AlmanaxApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a single date. There are not more details in the returned object than the normal range endpoint.
         * @summary Single Almanax Date
         * @param {GetAlmanaxDateLanguageEnum} language code
         * @param {string} date yyyy-mm-dd
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAlmanaxDate(language: GetAlmanaxDateLanguageEnum, date: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Almanax>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAlmanaxDate(language, date, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlmanaxApi.getAlmanaxDate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a range of dates, defaults to today + 6 following days but can specified by the query parameters.   filter[bonus_type] can be used seperately and does not have an effect on the other parameters.  range[from] changes the start date, everything else defaults to 6 following dates from this start date.  range[to] when used without anything else, it will use today as start date and this parameter as end. All ranges are inclusive.  range[from] + range[to] = inclusive range over the specified dates, should never be farther apart than 35 days.  range[from|to] + range[size] no need to specify the date, just following days with [from] (0 is today) or go backwards in time with only [to] and [size].  Not all combinations are listed but this should give you an idea how to they could work.
         * @summary Almanax Range
         * @param {GetAlmanaxRangeLanguageEnum} language code
         * @param {string} [filterBonusType] ids from meta/{language}/almanax/bonuses
         * @param {string} [rangeFrom] yyyy-mm-dd
         * @param {string} [rangeTo] yyyy-mm-dd
         * @param {number} [rangeSize] Size of the returned range. Disable to fully use the range by setting size to -1.
         * @param {string} [timezone] determine what the current time is. If you live in Brazil, \&quot;today\&quot; will be hours apart from Paris. Use your timezone to get results relative to your location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAlmanaxRange(language: GetAlmanaxRangeLanguageEnum, filterBonusType?: string, rangeFrom?: string, rangeTo?: string, rangeSize?: number, timezone?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Almanax>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAlmanaxRange(language, filterBonusType, rangeFrom, rangeTo, rangeSize, timezone, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlmanaxApi.getAlmanaxRange']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AlmanaxApi - factory interface
 * @export
 */
export const AlmanaxApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AlmanaxApiFp(configuration)
    return {
        /**
         * Get a single date. There are not more details in the returned object than the normal range endpoint.
         * @summary Single Almanax Date
         * @param {GetAlmanaxDateLanguageEnum} language code
         * @param {string} date yyyy-mm-dd
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlmanaxDate(language: GetAlmanaxDateLanguageEnum, date: string, options?: RawAxiosRequestConfig): AxiosPromise<Almanax> {
            return localVarFp.getAlmanaxDate(language, date, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a range of dates, defaults to today + 6 following days but can specified by the query parameters.   filter[bonus_type] can be used seperately and does not have an effect on the other parameters.  range[from] changes the start date, everything else defaults to 6 following dates from this start date.  range[to] when used without anything else, it will use today as start date and this parameter as end. All ranges are inclusive.  range[from] + range[to] = inclusive range over the specified dates, should never be farther apart than 35 days.  range[from|to] + range[size] no need to specify the date, just following days with [from] (0 is today) or go backwards in time with only [to] and [size].  Not all combinations are listed but this should give you an idea how to they could work.
         * @summary Almanax Range
         * @param {GetAlmanaxRangeLanguageEnum} language code
         * @param {string} [filterBonusType] ids from meta/{language}/almanax/bonuses
         * @param {string} [rangeFrom] yyyy-mm-dd
         * @param {string} [rangeTo] yyyy-mm-dd
         * @param {number} [rangeSize] Size of the returned range. Disable to fully use the range by setting size to -1.
         * @param {string} [timezone] determine what the current time is. If you live in Brazil, \&quot;today\&quot; will be hours apart from Paris. Use your timezone to get results relative to your location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlmanaxRange(language: GetAlmanaxRangeLanguageEnum, filterBonusType?: string, rangeFrom?: string, rangeTo?: string, rangeSize?: number, timezone?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Almanax>> {
            return localVarFp.getAlmanaxRange(language, filterBonusType, rangeFrom, rangeTo, rangeSize, timezone, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AlmanaxApi - object-oriented interface
 * @export
 * @class AlmanaxApi
 * @extends {BaseAPI}
 */
export class AlmanaxApi extends BaseAPI {
    /**
     * Get a single date. There are not more details in the returned object than the normal range endpoint.
     * @summary Single Almanax Date
     * @param {GetAlmanaxDateLanguageEnum} language code
     * @param {string} date yyyy-mm-dd
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlmanaxApi
     */
    public getAlmanaxDate(language: GetAlmanaxDateLanguageEnum, date: string, options?: RawAxiosRequestConfig) {
        return AlmanaxApiFp(this.configuration).getAlmanaxDate(language, date, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a range of dates, defaults to today + 6 following days but can specified by the query parameters.   filter[bonus_type] can be used seperately and does not have an effect on the other parameters.  range[from] changes the start date, everything else defaults to 6 following dates from this start date.  range[to] when used without anything else, it will use today as start date and this parameter as end. All ranges are inclusive.  range[from] + range[to] = inclusive range over the specified dates, should never be farther apart than 35 days.  range[from|to] + range[size] no need to specify the date, just following days with [from] (0 is today) or go backwards in time with only [to] and [size].  Not all combinations are listed but this should give you an idea how to they could work.
     * @summary Almanax Range
     * @param {GetAlmanaxRangeLanguageEnum} language code
     * @param {string} [filterBonusType] ids from meta/{language}/almanax/bonuses
     * @param {string} [rangeFrom] yyyy-mm-dd
     * @param {string} [rangeTo] yyyy-mm-dd
     * @param {number} [rangeSize] Size of the returned range. Disable to fully use the range by setting size to -1.
     * @param {string} [timezone] determine what the current time is. If you live in Brazil, \&quot;today\&quot; will be hours apart from Paris. Use your timezone to get results relative to your location.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlmanaxApi
     */
    public getAlmanaxRange(language: GetAlmanaxRangeLanguageEnum, filterBonusType?: string, rangeFrom?: string, rangeTo?: string, rangeSize?: number, timezone?: string, options?: RawAxiosRequestConfig) {
        return AlmanaxApiFp(this.configuration).getAlmanaxRange(language, filterBonusType, rangeFrom, rangeTo, rangeSize, timezone, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetAlmanaxDateLanguageEnum = {
    En: 'en',
    Fr: 'fr',
    De: 'de',
    It: 'it',
    Es: 'es'
} as const;
export type GetAlmanaxDateLanguageEnum = typeof GetAlmanaxDateLanguageEnum[keyof typeof GetAlmanaxDateLanguageEnum];
/**
 * @export
 */
export const GetAlmanaxRangeLanguageEnum = {
    En: 'en',
    Fr: 'fr',
    De: 'de',
    It: 'it',
    Es: 'es'
} as const;
export type GetAlmanaxRangeLanguageEnum = typeof GetAlmanaxRangeLanguageEnum[keyof typeof GetAlmanaxRangeLanguageEnum];


/**
 * ConsumablesApi - axios parameter creator
 * @export
 */
export const ConsumablesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve all consumable items with one request. This endpoint is just an alias for the a list with disabled pagination (page[size]=-1) and all fields[type] set.  If you want everything unfiltered, delete the other query parameters.  Be careful with testing or (god forbid) using /all in your browser, the returned json is huge and will slow down the browser!  Tip: set the HTTP Header \'Accept-Encoding: gzip\' for saving bandwidth. You will need to uncompress it on your end. Example with cURL: ``` curl -sH \'Accept-Encoding: gzip\' <api-endpoint> | gunzip - ```
         * @summary List All Consumables
         * @param {GetAllItemsConsumablesListLanguageEnum} language a valid language code
         * @param {GetAllItemsConsumablesListGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {GetAllItemsConsumablesListSortLevelEnum} [sortLevel] sort the resulting list by level, default unsorted
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {GetAllItemsConsumablesListAcceptEncodingEnum} [acceptEncoding] optional compression for saving bandwidth
         * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllItemsConsumablesList: async (language: GetAllItemsConsumablesListLanguageEnum, game: GetAllItemsConsumablesListGameEnum, sortLevel?: GetAllItemsConsumablesListSortLevelEnum, filterMinLevel?: number, filterMaxLevel?: number, acceptEncoding?: GetAllItemsConsumablesListAcceptEncodingEnum, filterTypeNameId?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getAllItemsConsumablesList', 'language', language)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getAllItemsConsumablesList', 'game', game)
            const localVarPath = `/{game}/v1/{language}/items/consumables/all`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sortLevel !== undefined) {
                localVarQueryParameter['sort[level]'] = sortLevel;
            }

            if (filterMinLevel !== undefined) {
                localVarQueryParameter['filter[min_level]'] = filterMinLevel;
            }

            if (filterMaxLevel !== undefined) {
                localVarQueryParameter['filter[max_level]'] = filterMaxLevel;
            }

            if (filterTypeNameId) {
                localVarQueryParameter['filter[type.name_id]'] = Array.from(filterTypeNameId).join(COLLECTION_FORMATS.csv);
            }


    
            if (acceptEncoding != null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of consumable items.
         * @summary List Consumables
         * @param {GetItemsConsumablesListLanguageEnum} language a valid language code
         * @param {GetItemsConsumablesListGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {GetItemsConsumablesListSortLevelEnum} [sortLevel] sort the resulting list by level, default unsorted
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {number} [pageSize] size of the results from the list. -1 disables pagination and gets all in one response.
         * @param {number} [pageNumber] page number based on the current page[size]. So you could get page 1 with 8 entrys and page 2 would have entries 8 to 16.
         * @param {Set<GetItemsConsumablesListFieldsItemEnum>} [fieldsItem] adds fields from their detail endpoint to the item list entries. Multiple comma separated values allowed.
         * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsConsumablesList: async (language: GetItemsConsumablesListLanguageEnum, game: GetItemsConsumablesListGameEnum, sortLevel?: GetItemsConsumablesListSortLevelEnum, filterMinLevel?: number, filterMaxLevel?: number, pageSize?: number, pageNumber?: number, fieldsItem?: Set<GetItemsConsumablesListFieldsItemEnum>, filterTypeNameId?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getItemsConsumablesList', 'language', language)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getItemsConsumablesList', 'game', game)
            const localVarPath = `/{game}/v1/{language}/items/consumables`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sortLevel !== undefined) {
                localVarQueryParameter['sort[level]'] = sortLevel;
            }

            if (filterMinLevel !== undefined) {
                localVarQueryParameter['filter[min_level]'] = filterMinLevel;
            }

            if (filterMaxLevel !== undefined) {
                localVarQueryParameter['filter[max_level]'] = filterMaxLevel;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page[size]'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['page[number]'] = pageNumber;
            }

            if (fieldsItem) {
                localVarQueryParameter['fields[item]'] = Array.from(fieldsItem).join(COLLECTION_FORMATS.csv);
            }

            if (filterTypeNameId) {
                localVarQueryParameter['filter[type.name_id]'] = Array.from(filterTypeNameId).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search in all names and descriptions of consumable items with a query.
         * @summary Search Consumables
         * @param {GetItemsConsumablesSearchLanguageEnum} language a valid language code
         * @param {GetItemsConsumablesSearchGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {string} query case sensitive search query
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {number} [limit] maximum number of returned results
         * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsConsumablesSearch: async (language: GetItemsConsumablesSearchLanguageEnum, game: GetItemsConsumablesSearchGameEnum, query: string, filterMinLevel?: number, filterMaxLevel?: number, limit?: number, filterTypeNameId?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getItemsConsumablesSearch', 'language', language)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getItemsConsumablesSearch', 'game', game)
            // verify required parameter 'query' is not null or undefined
            assertParamExists('getItemsConsumablesSearch', 'query', query)
            const localVarPath = `/{game}/v1/{language}/items/consumables/search`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (filterMinLevel !== undefined) {
                localVarQueryParameter['filter[min_level]'] = filterMinLevel;
            }

            if (filterMaxLevel !== undefined) {
                localVarQueryParameter['filter[max_level]'] = filterMaxLevel;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (filterTypeNameId) {
                localVarQueryParameter['filter[type.name_id]'] = Array.from(filterTypeNameId).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific consumable item with id.
         * @summary Single Consumables
         * @param {GetItemsConsumablesSingleLanguageEnum} language a valid language code
         * @param {number} ankamaId identifier
         * @param {GetItemsConsumablesSingleGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsConsumablesSingle: async (language: GetItemsConsumablesSingleLanguageEnum, ankamaId: number, game: GetItemsConsumablesSingleGameEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getItemsConsumablesSingle', 'language', language)
            // verify required parameter 'ankamaId' is not null or undefined
            assertParamExists('getItemsConsumablesSingle', 'ankamaId', ankamaId)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getItemsConsumablesSingle', 'game', game)
            const localVarPath = `/{game}/v1/{language}/items/consumables/{ankama_id}`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"ankama_id"}}`, encodeURIComponent(String(ankamaId)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConsumablesApi - functional programming interface
 * @export
 */
export const ConsumablesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConsumablesApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve all consumable items with one request. This endpoint is just an alias for the a list with disabled pagination (page[size]=-1) and all fields[type] set.  If you want everything unfiltered, delete the other query parameters.  Be careful with testing or (god forbid) using /all in your browser, the returned json is huge and will slow down the browser!  Tip: set the HTTP Header \'Accept-Encoding: gzip\' for saving bandwidth. You will need to uncompress it on your end. Example with cURL: ``` curl -sH \'Accept-Encoding: gzip\' <api-endpoint> | gunzip - ```
         * @summary List All Consumables
         * @param {GetAllItemsConsumablesListLanguageEnum} language a valid language code
         * @param {GetAllItemsConsumablesListGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {GetAllItemsConsumablesListSortLevelEnum} [sortLevel] sort the resulting list by level, default unsorted
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {GetAllItemsConsumablesListAcceptEncodingEnum} [acceptEncoding] optional compression for saving bandwidth
         * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllItemsConsumablesList(language: GetAllItemsConsumablesListLanguageEnum, game: GetAllItemsConsumablesListGameEnum, sortLevel?: GetAllItemsConsumablesListSortLevelEnum, filterMinLevel?: number, filterMaxLevel?: number, acceptEncoding?: GetAllItemsConsumablesListAcceptEncodingEnum, filterTypeNameId?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllItemsConsumablesList(language, game, sortLevel, filterMinLevel, filterMaxLevel, acceptEncoding, filterTypeNameId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConsumablesApi.getAllItemsConsumablesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of consumable items.
         * @summary List Consumables
         * @param {GetItemsConsumablesListLanguageEnum} language a valid language code
         * @param {GetItemsConsumablesListGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {GetItemsConsumablesListSortLevelEnum} [sortLevel] sort the resulting list by level, default unsorted
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {number} [pageSize] size of the results from the list. -1 disables pagination and gets all in one response.
         * @param {number} [pageNumber] page number based on the current page[size]. So you could get page 1 with 8 entrys and page 2 would have entries 8 to 16.
         * @param {Set<GetItemsConsumablesListFieldsItemEnum>} [fieldsItem] adds fields from their detail endpoint to the item list entries. Multiple comma separated values allowed.
         * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemsConsumablesList(language: GetItemsConsumablesListLanguageEnum, game: GetItemsConsumablesListGameEnum, sortLevel?: GetItemsConsumablesListSortLevelEnum, filterMinLevel?: number, filterMaxLevel?: number, pageSize?: number, pageNumber?: number, fieldsItem?: Set<GetItemsConsumablesListFieldsItemEnum>, filterTypeNameId?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemsConsumablesList(language, game, sortLevel, filterMinLevel, filterMaxLevel, pageSize, pageNumber, fieldsItem, filterTypeNameId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConsumablesApi.getItemsConsumablesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search in all names and descriptions of consumable items with a query.
         * @summary Search Consumables
         * @param {GetItemsConsumablesSearchLanguageEnum} language a valid language code
         * @param {GetItemsConsumablesSearchGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {string} query case sensitive search query
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {number} [limit] maximum number of returned results
         * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemsConsumablesSearch(language: GetItemsConsumablesSearchLanguageEnum, game: GetItemsConsumablesSearchGameEnum, query: string, filterMinLevel?: number, filterMaxLevel?: number, limit?: number, filterTypeNameId?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemsConsumablesSearch(language, game, query, filterMinLevel, filterMaxLevel, limit, filterTypeNameId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConsumablesApi.getItemsConsumablesSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific consumable item with id.
         * @summary Single Consumables
         * @param {GetItemsConsumablesSingleLanguageEnum} language a valid language code
         * @param {number} ankamaId identifier
         * @param {GetItemsConsumablesSingleGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemsConsumablesSingle(language: GetItemsConsumablesSingleLanguageEnum, ankamaId: number, game: GetItemsConsumablesSingleGameEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Resource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemsConsumablesSingle(language, ankamaId, game, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConsumablesApi.getItemsConsumablesSingle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ConsumablesApi - factory interface
 * @export
 */
export const ConsumablesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConsumablesApiFp(configuration)
    return {
        /**
         * Retrieve all consumable items with one request. This endpoint is just an alias for the a list with disabled pagination (page[size]=-1) and all fields[type] set.  If you want everything unfiltered, delete the other query parameters.  Be careful with testing or (god forbid) using /all in your browser, the returned json is huge and will slow down the browser!  Tip: set the HTTP Header \'Accept-Encoding: gzip\' for saving bandwidth. You will need to uncompress it on your end. Example with cURL: ``` curl -sH \'Accept-Encoding: gzip\' <api-endpoint> | gunzip - ```
         * @summary List All Consumables
         * @param {GetAllItemsConsumablesListLanguageEnum} language a valid language code
         * @param {GetAllItemsConsumablesListGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {GetAllItemsConsumablesListSortLevelEnum} [sortLevel] sort the resulting list by level, default unsorted
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {GetAllItemsConsumablesListAcceptEncodingEnum} [acceptEncoding] optional compression for saving bandwidth
         * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllItemsConsumablesList(language: GetAllItemsConsumablesListLanguageEnum, game: GetAllItemsConsumablesListGameEnum, sortLevel?: GetAllItemsConsumablesListSortLevelEnum, filterMinLevel?: number, filterMaxLevel?: number, acceptEncoding?: GetAllItemsConsumablesListAcceptEncodingEnum, filterTypeNameId?: Set<string>, options?: RawAxiosRequestConfig): AxiosPromise<ListItems> {
            return localVarFp.getAllItemsConsumablesList(language, game, sortLevel, filterMinLevel, filterMaxLevel, acceptEncoding, filterTypeNameId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of consumable items.
         * @summary List Consumables
         * @param {GetItemsConsumablesListLanguageEnum} language a valid language code
         * @param {GetItemsConsumablesListGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {GetItemsConsumablesListSortLevelEnum} [sortLevel] sort the resulting list by level, default unsorted
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {number} [pageSize] size of the results from the list. -1 disables pagination and gets all in one response.
         * @param {number} [pageNumber] page number based on the current page[size]. So you could get page 1 with 8 entrys and page 2 would have entries 8 to 16.
         * @param {Set<GetItemsConsumablesListFieldsItemEnum>} [fieldsItem] adds fields from their detail endpoint to the item list entries. Multiple comma separated values allowed.
         * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsConsumablesList(language: GetItemsConsumablesListLanguageEnum, game: GetItemsConsumablesListGameEnum, sortLevel?: GetItemsConsumablesListSortLevelEnum, filterMinLevel?: number, filterMaxLevel?: number, pageSize?: number, pageNumber?: number, fieldsItem?: Set<GetItemsConsumablesListFieldsItemEnum>, filterTypeNameId?: Set<string>, options?: RawAxiosRequestConfig): AxiosPromise<ListItems> {
            return localVarFp.getItemsConsumablesList(language, game, sortLevel, filterMinLevel, filterMaxLevel, pageSize, pageNumber, fieldsItem, filterTypeNameId, options).then((request) => request(axios, basePath));
        },
        /**
         * Search in all names and descriptions of consumable items with a query.
         * @summary Search Consumables
         * @param {GetItemsConsumablesSearchLanguageEnum} language a valid language code
         * @param {GetItemsConsumablesSearchGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {string} query case sensitive search query
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {number} [limit] maximum number of returned results
         * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsConsumablesSearch(language: GetItemsConsumablesSearchLanguageEnum, game: GetItemsConsumablesSearchGameEnum, query: string, filterMinLevel?: number, filterMaxLevel?: number, limit?: number, filterTypeNameId?: Set<string>, options?: RawAxiosRequestConfig): AxiosPromise<Array<ListItem>> {
            return localVarFp.getItemsConsumablesSearch(language, game, query, filterMinLevel, filterMaxLevel, limit, filterTypeNameId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific consumable item with id.
         * @summary Single Consumables
         * @param {GetItemsConsumablesSingleLanguageEnum} language a valid language code
         * @param {number} ankamaId identifier
         * @param {GetItemsConsumablesSingleGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsConsumablesSingle(language: GetItemsConsumablesSingleLanguageEnum, ankamaId: number, game: GetItemsConsumablesSingleGameEnum, options?: RawAxiosRequestConfig): AxiosPromise<Resource> {
            return localVarFp.getItemsConsumablesSingle(language, ankamaId, game, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConsumablesApi - object-oriented interface
 * @export
 * @class ConsumablesApi
 * @extends {BaseAPI}
 */
export class ConsumablesApi extends BaseAPI {
    /**
     * Retrieve all consumable items with one request. This endpoint is just an alias for the a list with disabled pagination (page[size]=-1) and all fields[type] set.  If you want everything unfiltered, delete the other query parameters.  Be careful with testing or (god forbid) using /all in your browser, the returned json is huge and will slow down the browser!  Tip: set the HTTP Header \'Accept-Encoding: gzip\' for saving bandwidth. You will need to uncompress it on your end. Example with cURL: ``` curl -sH \'Accept-Encoding: gzip\' <api-endpoint> | gunzip - ```
     * @summary List All Consumables
     * @param {GetAllItemsConsumablesListLanguageEnum} language a valid language code
     * @param {GetAllItemsConsumablesListGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
     * @param {GetAllItemsConsumablesListSortLevelEnum} [sortLevel] sort the resulting list by level, default unsorted
     * @param {number} [filterMinLevel] only results which level is equal or above this value
     * @param {number} [filterMaxLevel] only results which level is equal or below this value
     * @param {GetAllItemsConsumablesListAcceptEncodingEnum} [acceptEncoding] optional compression for saving bandwidth
     * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsumablesApi
     */
    public getAllItemsConsumablesList(language: GetAllItemsConsumablesListLanguageEnum, game: GetAllItemsConsumablesListGameEnum, sortLevel?: GetAllItemsConsumablesListSortLevelEnum, filterMinLevel?: number, filterMaxLevel?: number, acceptEncoding?: GetAllItemsConsumablesListAcceptEncodingEnum, filterTypeNameId?: Set<string>, options?: RawAxiosRequestConfig) {
        return ConsumablesApiFp(this.configuration).getAllItemsConsumablesList(language, game, sortLevel, filterMinLevel, filterMaxLevel, acceptEncoding, filterTypeNameId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of consumable items.
     * @summary List Consumables
     * @param {GetItemsConsumablesListLanguageEnum} language a valid language code
     * @param {GetItemsConsumablesListGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
     * @param {GetItemsConsumablesListSortLevelEnum} [sortLevel] sort the resulting list by level, default unsorted
     * @param {number} [filterMinLevel] only results which level is equal or above this value
     * @param {number} [filterMaxLevel] only results which level is equal or below this value
     * @param {number} [pageSize] size of the results from the list. -1 disables pagination and gets all in one response.
     * @param {number} [pageNumber] page number based on the current page[size]. So you could get page 1 with 8 entrys and page 2 would have entries 8 to 16.
     * @param {Set<GetItemsConsumablesListFieldsItemEnum>} [fieldsItem] adds fields from their detail endpoint to the item list entries. Multiple comma separated values allowed.
     * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsumablesApi
     */
    public getItemsConsumablesList(language: GetItemsConsumablesListLanguageEnum, game: GetItemsConsumablesListGameEnum, sortLevel?: GetItemsConsumablesListSortLevelEnum, filterMinLevel?: number, filterMaxLevel?: number, pageSize?: number, pageNumber?: number, fieldsItem?: Set<GetItemsConsumablesListFieldsItemEnum>, filterTypeNameId?: Set<string>, options?: RawAxiosRequestConfig) {
        return ConsumablesApiFp(this.configuration).getItemsConsumablesList(language, game, sortLevel, filterMinLevel, filterMaxLevel, pageSize, pageNumber, fieldsItem, filterTypeNameId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search in all names and descriptions of consumable items with a query.
     * @summary Search Consumables
     * @param {GetItemsConsumablesSearchLanguageEnum} language a valid language code
     * @param {GetItemsConsumablesSearchGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
     * @param {string} query case sensitive search query
     * @param {number} [filterMinLevel] only results which level is equal or above this value
     * @param {number} [filterMaxLevel] only results which level is equal or below this value
     * @param {number} [limit] maximum number of returned results
     * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsumablesApi
     */
    public getItemsConsumablesSearch(language: GetItemsConsumablesSearchLanguageEnum, game: GetItemsConsumablesSearchGameEnum, query: string, filterMinLevel?: number, filterMaxLevel?: number, limit?: number, filterTypeNameId?: Set<string>, options?: RawAxiosRequestConfig) {
        return ConsumablesApiFp(this.configuration).getItemsConsumablesSearch(language, game, query, filterMinLevel, filterMaxLevel, limit, filterTypeNameId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific consumable item with id.
     * @summary Single Consumables
     * @param {GetItemsConsumablesSingleLanguageEnum} language a valid language code
     * @param {number} ankamaId identifier
     * @param {GetItemsConsumablesSingleGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsumablesApi
     */
    public getItemsConsumablesSingle(language: GetItemsConsumablesSingleLanguageEnum, ankamaId: number, game: GetItemsConsumablesSingleGameEnum, options?: RawAxiosRequestConfig) {
        return ConsumablesApiFp(this.configuration).getItemsConsumablesSingle(language, ankamaId, game, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetAllItemsConsumablesListLanguageEnum = {
    En: 'en',
    Fr: 'fr',
    De: 'de',
    Es: 'es',
    Pt: 'pt'
} as const;
export type GetAllItemsConsumablesListLanguageEnum = typeof GetAllItemsConsumablesListLanguageEnum[keyof typeof GetAllItemsConsumablesListLanguageEnum];
/**
 * @export
 */
export const GetAllItemsConsumablesListGameEnum = {
    Dofus3: 'dofus3',
    Dofus3beta: 'dofus3beta'
} as const;
export type GetAllItemsConsumablesListGameEnum = typeof GetAllItemsConsumablesListGameEnum[keyof typeof GetAllItemsConsumablesListGameEnum];
/**
 * @export
 */
export const GetAllItemsConsumablesListSortLevelEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type GetAllItemsConsumablesListSortLevelEnum = typeof GetAllItemsConsumablesListSortLevelEnum[keyof typeof GetAllItemsConsumablesListSortLevelEnum];
/**
 * @export
 */
export const GetAllItemsConsumablesListAcceptEncodingEnum = {
    Gzip: 'gzip'
} as const;
export type GetAllItemsConsumablesListAcceptEncodingEnum = typeof GetAllItemsConsumablesListAcceptEncodingEnum[keyof typeof GetAllItemsConsumablesListAcceptEncodingEnum];
/**
 * @export
 */
export const GetItemsConsumablesListLanguageEnum = {
    En: 'en',
    Fr: 'fr',
    De: 'de',
    Es: 'es',
    Pt: 'pt'
} as const;
export type GetItemsConsumablesListLanguageEnum = typeof GetItemsConsumablesListLanguageEnum[keyof typeof GetItemsConsumablesListLanguageEnum];
/**
 * @export
 */
export const GetItemsConsumablesListGameEnum = {
    Dofus3: 'dofus3',
    Dofus3beta: 'dofus3beta'
} as const;
export type GetItemsConsumablesListGameEnum = typeof GetItemsConsumablesListGameEnum[keyof typeof GetItemsConsumablesListGameEnum];
/**
 * @export
 */
export const GetItemsConsumablesListSortLevelEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type GetItemsConsumablesListSortLevelEnum = typeof GetItemsConsumablesListSortLevelEnum[keyof typeof GetItemsConsumablesListSortLevelEnum];
/**
 * @export
 */
export const GetItemsConsumablesListFieldsItemEnum = {
    Recipe: 'recipe',
    Description: 'description',
    Conditions: 'conditions',
    Effects: 'effects'
} as const;
export type GetItemsConsumablesListFieldsItemEnum = typeof GetItemsConsumablesListFieldsItemEnum[keyof typeof GetItemsConsumablesListFieldsItemEnum];
/**
 * @export
 */
export const GetItemsConsumablesSearchLanguageEnum = {
    En: 'en',
    Fr: 'fr',
    De: 'de',
    Es: 'es',
    Pt: 'pt'
} as const;
export type GetItemsConsumablesSearchLanguageEnum = typeof GetItemsConsumablesSearchLanguageEnum[keyof typeof GetItemsConsumablesSearchLanguageEnum];
/**
 * @export
 */
export const GetItemsConsumablesSearchGameEnum = {
    Dofus3: 'dofus3',
    Dofus3beta: 'dofus3beta'
} as const;
export type GetItemsConsumablesSearchGameEnum = typeof GetItemsConsumablesSearchGameEnum[keyof typeof GetItemsConsumablesSearchGameEnum];
/**
 * @export
 */
export const GetItemsConsumablesSingleLanguageEnum = {
    En: 'en',
    Fr: 'fr',
    De: 'de',
    Es: 'es',
    Pt: 'pt'
} as const;
export type GetItemsConsumablesSingleLanguageEnum = typeof GetItemsConsumablesSingleLanguageEnum[keyof typeof GetItemsConsumablesSingleLanguageEnum];
/**
 * @export
 */
export const GetItemsConsumablesSingleGameEnum = {
    Dofus3: 'dofus3',
    Dofus3beta: 'dofus3beta'
} as const;
export type GetItemsConsumablesSingleGameEnum = typeof GetItemsConsumablesSingleGameEnum[keyof typeof GetItemsConsumablesSingleGameEnum];


/**
 * CosmeticsApi - axios parameter creator
 * @export
 */
export const CosmeticsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve all cosmetic items with one request. This endpoint is just an alias for the a list with disabled pagination (page[size]=-1) and all fields[type] set.  If you want everything unfiltered, delete the other query parameters.  Be careful with testing or (god forbid) using /all in your browser, the returned json is huge and will slow down the browser!  Tip: set the HTTP Header \'Accept-Encoding: gzip\' for saving bandwidth. You will need to uncompress it on your end. Example with cURL: ``` curl -sH \'Accept-Encoding: gzip\' <api-endpoint> | gunzip - ```
         * @summary List All Cosmetics
         * @param {GetAllCosmeticsListLanguageEnum} language a valid language code
         * @param {GetAllCosmeticsListGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {GetAllCosmeticsListSortLevelEnum} [sortLevel] sort the resulting list by level, default unsorted
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {GetAllCosmeticsListAcceptEncodingEnum} [acceptEncoding] optional compression for saving bandwidth
         * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCosmeticsList: async (language: GetAllCosmeticsListLanguageEnum, game: GetAllCosmeticsListGameEnum, sortLevel?: GetAllCosmeticsListSortLevelEnum, filterMinLevel?: number, filterMaxLevel?: number, acceptEncoding?: GetAllCosmeticsListAcceptEncodingEnum, filterTypeNameId?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getAllCosmeticsList', 'language', language)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getAllCosmeticsList', 'game', game)
            const localVarPath = `/{game}/v1/{language}/items/cosmetics/all`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sortLevel !== undefined) {
                localVarQueryParameter['sort[level]'] = sortLevel;
            }

            if (filterMinLevel !== undefined) {
                localVarQueryParameter['filter[min_level]'] = filterMinLevel;
            }

            if (filterMaxLevel !== undefined) {
                localVarQueryParameter['filter[max_level]'] = filterMaxLevel;
            }

            if (filterTypeNameId) {
                localVarQueryParameter['filter[type.name_id]'] = Array.from(filterTypeNameId).join(COLLECTION_FORMATS.csv);
            }


    
            if (acceptEncoding != null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of cosmetic items.
         * @summary List Cosmetics
         * @param {GetCosmeticsListLanguageEnum} language a valid language code
         * @param {GetCosmeticsListGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {GetCosmeticsListSortLevelEnum} [sortLevel] sort the resulting list by level, default unsorted
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {number} [pageSize] size of the results from the list. -1 disables pagination and gets all in one response.
         * @param {number} [pageNumber] page number based on the current page[size]. So you could get page 1 with 8 entrys and page 2 would have entries 8 to 16.
         * @param {Set<GetCosmeticsListFieldsItemEnum>} [fieldsItem] adds fields from their detail endpoint to the item list entries. Multiple comma separated values allowed.
         * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCosmeticsList: async (language: GetCosmeticsListLanguageEnum, game: GetCosmeticsListGameEnum, sortLevel?: GetCosmeticsListSortLevelEnum, filterMinLevel?: number, filterMaxLevel?: number, pageSize?: number, pageNumber?: number, fieldsItem?: Set<GetCosmeticsListFieldsItemEnum>, filterTypeNameId?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getCosmeticsList', 'language', language)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getCosmeticsList', 'game', game)
            const localVarPath = `/{game}/v1/{language}/items/cosmetics`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sortLevel !== undefined) {
                localVarQueryParameter['sort[level]'] = sortLevel;
            }

            if (filterMinLevel !== undefined) {
                localVarQueryParameter['filter[min_level]'] = filterMinLevel;
            }

            if (filterMaxLevel !== undefined) {
                localVarQueryParameter['filter[max_level]'] = filterMaxLevel;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page[size]'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['page[number]'] = pageNumber;
            }

            if (fieldsItem) {
                localVarQueryParameter['fields[item]'] = Array.from(fieldsItem).join(COLLECTION_FORMATS.csv);
            }

            if (filterTypeNameId) {
                localVarQueryParameter['filter[type.name_id]'] = Array.from(filterTypeNameId).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search in all names and descriptions of cosmetic items with a query.
         * @summary Search Cosmetics
         * @param {GetCosmeticsSearchLanguageEnum} language a valid language code
         * @param {GetCosmeticsSearchGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {string} query case sensitive search query
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {number} [limit] maximum number of returned results
         * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCosmeticsSearch: async (language: GetCosmeticsSearchLanguageEnum, game: GetCosmeticsSearchGameEnum, query: string, filterMinLevel?: number, filterMaxLevel?: number, limit?: number, filterTypeNameId?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getCosmeticsSearch', 'language', language)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getCosmeticsSearch', 'game', game)
            // verify required parameter 'query' is not null or undefined
            assertParamExists('getCosmeticsSearch', 'query', query)
            const localVarPath = `/{game}/v1/{language}/items/cosmetics/search`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (filterMinLevel !== undefined) {
                localVarQueryParameter['filter[min_level]'] = filterMinLevel;
            }

            if (filterMaxLevel !== undefined) {
                localVarQueryParameter['filter[max_level]'] = filterMaxLevel;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (filterTypeNameId) {
                localVarQueryParameter['filter[type.name_id]'] = Array.from(filterTypeNameId).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific cosmetic item with id.
         * @summary Single Cosmetics
         * @param {GetCosmeticsSingleLanguageEnum} language a valid language code
         * @param {number} ankamaId identifier
         * @param {GetCosmeticsSingleGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCosmeticsSingle: async (language: GetCosmeticsSingleLanguageEnum, ankamaId: number, game: GetCosmeticsSingleGameEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getCosmeticsSingle', 'language', language)
            // verify required parameter 'ankamaId' is not null or undefined
            assertParamExists('getCosmeticsSingle', 'ankamaId', ankamaId)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getCosmeticsSingle', 'game', game)
            const localVarPath = `/{game}/v1/{language}/items/cosmetics/{ankama_id}`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"ankama_id"}}`, encodeURIComponent(String(ankamaId)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CosmeticsApi - functional programming interface
 * @export
 */
export const CosmeticsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CosmeticsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve all cosmetic items with one request. This endpoint is just an alias for the a list with disabled pagination (page[size]=-1) and all fields[type] set.  If you want everything unfiltered, delete the other query parameters.  Be careful with testing or (god forbid) using /all in your browser, the returned json is huge and will slow down the browser!  Tip: set the HTTP Header \'Accept-Encoding: gzip\' for saving bandwidth. You will need to uncompress it on your end. Example with cURL: ``` curl -sH \'Accept-Encoding: gzip\' <api-endpoint> | gunzip - ```
         * @summary List All Cosmetics
         * @param {GetAllCosmeticsListLanguageEnum} language a valid language code
         * @param {GetAllCosmeticsListGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {GetAllCosmeticsListSortLevelEnum} [sortLevel] sort the resulting list by level, default unsorted
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {GetAllCosmeticsListAcceptEncodingEnum} [acceptEncoding] optional compression for saving bandwidth
         * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllCosmeticsList(language: GetAllCosmeticsListLanguageEnum, game: GetAllCosmeticsListGameEnum, sortLevel?: GetAllCosmeticsListSortLevelEnum, filterMinLevel?: number, filterMaxLevel?: number, acceptEncoding?: GetAllCosmeticsListAcceptEncodingEnum, filterTypeNameId?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllCosmeticsList(language, game, sortLevel, filterMinLevel, filterMaxLevel, acceptEncoding, filterTypeNameId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CosmeticsApi.getAllCosmeticsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of cosmetic items.
         * @summary List Cosmetics
         * @param {GetCosmeticsListLanguageEnum} language a valid language code
         * @param {GetCosmeticsListGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {GetCosmeticsListSortLevelEnum} [sortLevel] sort the resulting list by level, default unsorted
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {number} [pageSize] size of the results from the list. -1 disables pagination and gets all in one response.
         * @param {number} [pageNumber] page number based on the current page[size]. So you could get page 1 with 8 entrys and page 2 would have entries 8 to 16.
         * @param {Set<GetCosmeticsListFieldsItemEnum>} [fieldsItem] adds fields from their detail endpoint to the item list entries. Multiple comma separated values allowed.
         * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCosmeticsList(language: GetCosmeticsListLanguageEnum, game: GetCosmeticsListGameEnum, sortLevel?: GetCosmeticsListSortLevelEnum, filterMinLevel?: number, filterMaxLevel?: number, pageSize?: number, pageNumber?: number, fieldsItem?: Set<GetCosmeticsListFieldsItemEnum>, filterTypeNameId?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCosmeticsList(language, game, sortLevel, filterMinLevel, filterMaxLevel, pageSize, pageNumber, fieldsItem, filterTypeNameId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CosmeticsApi.getCosmeticsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search in all names and descriptions of cosmetic items with a query.
         * @summary Search Cosmetics
         * @param {GetCosmeticsSearchLanguageEnum} language a valid language code
         * @param {GetCosmeticsSearchGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {string} query case sensitive search query
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {number} [limit] maximum number of returned results
         * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCosmeticsSearch(language: GetCosmeticsSearchLanguageEnum, game: GetCosmeticsSearchGameEnum, query: string, filterMinLevel?: number, filterMaxLevel?: number, limit?: number, filterTypeNameId?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCosmeticsSearch(language, game, query, filterMinLevel, filterMaxLevel, limit, filterTypeNameId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CosmeticsApi.getCosmeticsSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific cosmetic item with id.
         * @summary Single Cosmetics
         * @param {GetCosmeticsSingleLanguageEnum} language a valid language code
         * @param {number} ankamaId identifier
         * @param {GetCosmeticsSingleGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCosmeticsSingle(language: GetCosmeticsSingleLanguageEnum, ankamaId: number, game: GetCosmeticsSingleGameEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Equipment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCosmeticsSingle(language, ankamaId, game, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CosmeticsApi.getCosmeticsSingle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CosmeticsApi - factory interface
 * @export
 */
export const CosmeticsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CosmeticsApiFp(configuration)
    return {
        /**
         * Retrieve all cosmetic items with one request. This endpoint is just an alias for the a list with disabled pagination (page[size]=-1) and all fields[type] set.  If you want everything unfiltered, delete the other query parameters.  Be careful with testing or (god forbid) using /all in your browser, the returned json is huge and will slow down the browser!  Tip: set the HTTP Header \'Accept-Encoding: gzip\' for saving bandwidth. You will need to uncompress it on your end. Example with cURL: ``` curl -sH \'Accept-Encoding: gzip\' <api-endpoint> | gunzip - ```
         * @summary List All Cosmetics
         * @param {GetAllCosmeticsListLanguageEnum} language a valid language code
         * @param {GetAllCosmeticsListGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {GetAllCosmeticsListSortLevelEnum} [sortLevel] sort the resulting list by level, default unsorted
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {GetAllCosmeticsListAcceptEncodingEnum} [acceptEncoding] optional compression for saving bandwidth
         * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCosmeticsList(language: GetAllCosmeticsListLanguageEnum, game: GetAllCosmeticsListGameEnum, sortLevel?: GetAllCosmeticsListSortLevelEnum, filterMinLevel?: number, filterMaxLevel?: number, acceptEncoding?: GetAllCosmeticsListAcceptEncodingEnum, filterTypeNameId?: Set<string>, options?: RawAxiosRequestConfig): AxiosPromise<ListItems> {
            return localVarFp.getAllCosmeticsList(language, game, sortLevel, filterMinLevel, filterMaxLevel, acceptEncoding, filterTypeNameId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of cosmetic items.
         * @summary List Cosmetics
         * @param {GetCosmeticsListLanguageEnum} language a valid language code
         * @param {GetCosmeticsListGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {GetCosmeticsListSortLevelEnum} [sortLevel] sort the resulting list by level, default unsorted
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {number} [pageSize] size of the results from the list. -1 disables pagination and gets all in one response.
         * @param {number} [pageNumber] page number based on the current page[size]. So you could get page 1 with 8 entrys and page 2 would have entries 8 to 16.
         * @param {Set<GetCosmeticsListFieldsItemEnum>} [fieldsItem] adds fields from their detail endpoint to the item list entries. Multiple comma separated values allowed.
         * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCosmeticsList(language: GetCosmeticsListLanguageEnum, game: GetCosmeticsListGameEnum, sortLevel?: GetCosmeticsListSortLevelEnum, filterMinLevel?: number, filterMaxLevel?: number, pageSize?: number, pageNumber?: number, fieldsItem?: Set<GetCosmeticsListFieldsItemEnum>, filterTypeNameId?: Set<string>, options?: RawAxiosRequestConfig): AxiosPromise<ListItems> {
            return localVarFp.getCosmeticsList(language, game, sortLevel, filterMinLevel, filterMaxLevel, pageSize, pageNumber, fieldsItem, filterTypeNameId, options).then((request) => request(axios, basePath));
        },
        /**
         * Search in all names and descriptions of cosmetic items with a query.
         * @summary Search Cosmetics
         * @param {GetCosmeticsSearchLanguageEnum} language a valid language code
         * @param {GetCosmeticsSearchGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {string} query case sensitive search query
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {number} [limit] maximum number of returned results
         * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCosmeticsSearch(language: GetCosmeticsSearchLanguageEnum, game: GetCosmeticsSearchGameEnum, query: string, filterMinLevel?: number, filterMaxLevel?: number, limit?: number, filterTypeNameId?: Set<string>, options?: RawAxiosRequestConfig): AxiosPromise<Array<ListItem>> {
            return localVarFp.getCosmeticsSearch(language, game, query, filterMinLevel, filterMaxLevel, limit, filterTypeNameId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific cosmetic item with id.
         * @summary Single Cosmetics
         * @param {GetCosmeticsSingleLanguageEnum} language a valid language code
         * @param {number} ankamaId identifier
         * @param {GetCosmeticsSingleGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCosmeticsSingle(language: GetCosmeticsSingleLanguageEnum, ankamaId: number, game: GetCosmeticsSingleGameEnum, options?: RawAxiosRequestConfig): AxiosPromise<Equipment> {
            return localVarFp.getCosmeticsSingle(language, ankamaId, game, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CosmeticsApi - object-oriented interface
 * @export
 * @class CosmeticsApi
 * @extends {BaseAPI}
 */
export class CosmeticsApi extends BaseAPI {
    /**
     * Retrieve all cosmetic items with one request. This endpoint is just an alias for the a list with disabled pagination (page[size]=-1) and all fields[type] set.  If you want everything unfiltered, delete the other query parameters.  Be careful with testing or (god forbid) using /all in your browser, the returned json is huge and will slow down the browser!  Tip: set the HTTP Header \'Accept-Encoding: gzip\' for saving bandwidth. You will need to uncompress it on your end. Example with cURL: ``` curl -sH \'Accept-Encoding: gzip\' <api-endpoint> | gunzip - ```
     * @summary List All Cosmetics
     * @param {GetAllCosmeticsListLanguageEnum} language a valid language code
     * @param {GetAllCosmeticsListGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
     * @param {GetAllCosmeticsListSortLevelEnum} [sortLevel] sort the resulting list by level, default unsorted
     * @param {number} [filterMinLevel] only results which level is equal or above this value
     * @param {number} [filterMaxLevel] only results which level is equal or below this value
     * @param {GetAllCosmeticsListAcceptEncodingEnum} [acceptEncoding] optional compression for saving bandwidth
     * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CosmeticsApi
     */
    public getAllCosmeticsList(language: GetAllCosmeticsListLanguageEnum, game: GetAllCosmeticsListGameEnum, sortLevel?: GetAllCosmeticsListSortLevelEnum, filterMinLevel?: number, filterMaxLevel?: number, acceptEncoding?: GetAllCosmeticsListAcceptEncodingEnum, filterTypeNameId?: Set<string>, options?: RawAxiosRequestConfig) {
        return CosmeticsApiFp(this.configuration).getAllCosmeticsList(language, game, sortLevel, filterMinLevel, filterMaxLevel, acceptEncoding, filterTypeNameId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of cosmetic items.
     * @summary List Cosmetics
     * @param {GetCosmeticsListLanguageEnum} language a valid language code
     * @param {GetCosmeticsListGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
     * @param {GetCosmeticsListSortLevelEnum} [sortLevel] sort the resulting list by level, default unsorted
     * @param {number} [filterMinLevel] only results which level is equal or above this value
     * @param {number} [filterMaxLevel] only results which level is equal or below this value
     * @param {number} [pageSize] size of the results from the list. -1 disables pagination and gets all in one response.
     * @param {number} [pageNumber] page number based on the current page[size]. So you could get page 1 with 8 entrys and page 2 would have entries 8 to 16.
     * @param {Set<GetCosmeticsListFieldsItemEnum>} [fieldsItem] adds fields from their detail endpoint to the item list entries. Multiple comma separated values allowed.
     * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CosmeticsApi
     */
    public getCosmeticsList(language: GetCosmeticsListLanguageEnum, game: GetCosmeticsListGameEnum, sortLevel?: GetCosmeticsListSortLevelEnum, filterMinLevel?: number, filterMaxLevel?: number, pageSize?: number, pageNumber?: number, fieldsItem?: Set<GetCosmeticsListFieldsItemEnum>, filterTypeNameId?: Set<string>, options?: RawAxiosRequestConfig) {
        return CosmeticsApiFp(this.configuration).getCosmeticsList(language, game, sortLevel, filterMinLevel, filterMaxLevel, pageSize, pageNumber, fieldsItem, filterTypeNameId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search in all names and descriptions of cosmetic items with a query.
     * @summary Search Cosmetics
     * @param {GetCosmeticsSearchLanguageEnum} language a valid language code
     * @param {GetCosmeticsSearchGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
     * @param {string} query case sensitive search query
     * @param {number} [filterMinLevel] only results which level is equal or above this value
     * @param {number} [filterMaxLevel] only results which level is equal or below this value
     * @param {number} [limit] maximum number of returned results
     * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CosmeticsApi
     */
    public getCosmeticsSearch(language: GetCosmeticsSearchLanguageEnum, game: GetCosmeticsSearchGameEnum, query: string, filterMinLevel?: number, filterMaxLevel?: number, limit?: number, filterTypeNameId?: Set<string>, options?: RawAxiosRequestConfig) {
        return CosmeticsApiFp(this.configuration).getCosmeticsSearch(language, game, query, filterMinLevel, filterMaxLevel, limit, filterTypeNameId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific cosmetic item with id.
     * @summary Single Cosmetics
     * @param {GetCosmeticsSingleLanguageEnum} language a valid language code
     * @param {number} ankamaId identifier
     * @param {GetCosmeticsSingleGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CosmeticsApi
     */
    public getCosmeticsSingle(language: GetCosmeticsSingleLanguageEnum, ankamaId: number, game: GetCosmeticsSingleGameEnum, options?: RawAxiosRequestConfig) {
        return CosmeticsApiFp(this.configuration).getCosmeticsSingle(language, ankamaId, game, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetAllCosmeticsListLanguageEnum = {
    En: 'en',
    Fr: 'fr',
    De: 'de',
    Es: 'es',
    Pt: 'pt'
} as const;
export type GetAllCosmeticsListLanguageEnum = typeof GetAllCosmeticsListLanguageEnum[keyof typeof GetAllCosmeticsListLanguageEnum];
/**
 * @export
 */
export const GetAllCosmeticsListGameEnum = {
    Dofus3: 'dofus3',
    Dofus3beta: 'dofus3beta'
} as const;
export type GetAllCosmeticsListGameEnum = typeof GetAllCosmeticsListGameEnum[keyof typeof GetAllCosmeticsListGameEnum];
/**
 * @export
 */
export const GetAllCosmeticsListSortLevelEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type GetAllCosmeticsListSortLevelEnum = typeof GetAllCosmeticsListSortLevelEnum[keyof typeof GetAllCosmeticsListSortLevelEnum];
/**
 * @export
 */
export const GetAllCosmeticsListAcceptEncodingEnum = {
    Gzip: 'gzip'
} as const;
export type GetAllCosmeticsListAcceptEncodingEnum = typeof GetAllCosmeticsListAcceptEncodingEnum[keyof typeof GetAllCosmeticsListAcceptEncodingEnum];
/**
 * @export
 */
export const GetCosmeticsListLanguageEnum = {
    En: 'en',
    Fr: 'fr',
    De: 'de',
    Es: 'es',
    Pt: 'pt'
} as const;
export type GetCosmeticsListLanguageEnum = typeof GetCosmeticsListLanguageEnum[keyof typeof GetCosmeticsListLanguageEnum];
/**
 * @export
 */
export const GetCosmeticsListGameEnum = {
    Dofus3: 'dofus3',
    Dofus3beta: 'dofus3beta'
} as const;
export type GetCosmeticsListGameEnum = typeof GetCosmeticsListGameEnum[keyof typeof GetCosmeticsListGameEnum];
/**
 * @export
 */
export const GetCosmeticsListSortLevelEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type GetCosmeticsListSortLevelEnum = typeof GetCosmeticsListSortLevelEnum[keyof typeof GetCosmeticsListSortLevelEnum];
/**
 * @export
 */
export const GetCosmeticsListFieldsItemEnum = {
    Recipe: 'recipe',
    Description: 'description',
    Conditions: 'conditions',
    Effects: 'effects',
    IsWeapon: 'is_weapon',
    Pods: 'pods',
    ParentSet: 'parent_set',
    CriticalHitProbability: 'critical_hit_probability',
    CriticalHitBonus: 'critical_hit_bonus',
    MaxCastPerTurn: 'max_cast_per_turn',
    ApCost: 'ap_cost',
    Range: 'range'
} as const;
export type GetCosmeticsListFieldsItemEnum = typeof GetCosmeticsListFieldsItemEnum[keyof typeof GetCosmeticsListFieldsItemEnum];
/**
 * @export
 */
export const GetCosmeticsSearchLanguageEnum = {
    En: 'en',
    Fr: 'fr',
    De: 'de',
    Es: 'es',
    Pt: 'pt'
} as const;
export type GetCosmeticsSearchLanguageEnum = typeof GetCosmeticsSearchLanguageEnum[keyof typeof GetCosmeticsSearchLanguageEnum];
/**
 * @export
 */
export const GetCosmeticsSearchGameEnum = {
    Dofus3: 'dofus3',
    Dofus3beta: 'dofus3beta'
} as const;
export type GetCosmeticsSearchGameEnum = typeof GetCosmeticsSearchGameEnum[keyof typeof GetCosmeticsSearchGameEnum];
/**
 * @export
 */
export const GetCosmeticsSingleLanguageEnum = {
    En: 'en',
    Fr: 'fr',
    De: 'de',
    Es: 'es',
    Pt: 'pt'
} as const;
export type GetCosmeticsSingleLanguageEnum = typeof GetCosmeticsSingleLanguageEnum[keyof typeof GetCosmeticsSingleLanguageEnum];
/**
 * @export
 */
export const GetCosmeticsSingleGameEnum = {
    Dofus3: 'dofus3',
    Dofus3beta: 'dofus3beta'
} as const;
export type GetCosmeticsSingleGameEnum = typeof GetCosmeticsSingleGameEnum[keyof typeof GetCosmeticsSingleGameEnum];


/**
 * EquipmentApi - axios parameter creator
 * @export
 */
export const EquipmentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve all equipment items with one request. This endpoint is just an alias for the a list with disabled pagination (page[size]=-1) and all fields[type] set.  If you want everything unfiltered, delete the other query parameters.  Be careful with testing or (god forbid) using /all in your browser, the returned json is huge and will slow down the browser!  Tip: set the HTTP Header \'Accept-Encoding: gzip\' for saving bandwidth. You will need to uncompress it on your end. Example with cURL: ``` curl -sH \'Accept-Encoding: gzip\' <api-endpoint> | gunzip - ```
         * @summary List All Equipment
         * @param {GetAllItemsEquipmentListLanguageEnum} language a valid language code
         * @param {GetAllItemsEquipmentListGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {GetAllItemsEquipmentListSortLevelEnum} [sortLevel] sort the resulting list by level, default unsorted
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {GetAllItemsEquipmentListAcceptEncodingEnum} [acceptEncoding] optional compression for saving bandwidth
         * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllItemsEquipmentList: async (language: GetAllItemsEquipmentListLanguageEnum, game: GetAllItemsEquipmentListGameEnum, sortLevel?: GetAllItemsEquipmentListSortLevelEnum, filterMinLevel?: number, filterMaxLevel?: number, acceptEncoding?: GetAllItemsEquipmentListAcceptEncodingEnum, filterTypeNameId?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getAllItemsEquipmentList', 'language', language)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getAllItemsEquipmentList', 'game', game)
            const localVarPath = `/{game}/v1/{language}/items/equipment/all`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sortLevel !== undefined) {
                localVarQueryParameter['sort[level]'] = sortLevel;
            }

            if (filterMinLevel !== undefined) {
                localVarQueryParameter['filter[min_level]'] = filterMinLevel;
            }

            if (filterMaxLevel !== undefined) {
                localVarQueryParameter['filter[max_level]'] = filterMaxLevel;
            }

            if (filterTypeNameId) {
                localVarQueryParameter['filter[type.name_id]'] = Array.from(filterTypeNameId).join(COLLECTION_FORMATS.csv);
            }


    
            if (acceptEncoding != null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of equipment items.
         * @summary List Equipment
         * @param {GetItemsEquipmentListLanguageEnum} language a valid language code
         * @param {GetItemsEquipmentListGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {GetItemsEquipmentListSortLevelEnum} [sortLevel] sort the resulting list by level, default unsorted
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {number} [pageSize] size of the results from the list. -1 disables pagination and gets all in one response.
         * @param {number} [pageNumber] page number based on the current page[size]. So you could get page 1 with 8 entrys and page 2 would have entries 8 to 16.
         * @param {Set<GetItemsEquipmentListFieldsItemEnum>} [fieldsItem] adds fields from their detail endpoint to the item list entries. Multiple comma separated values allowed.
         * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsEquipmentList: async (language: GetItemsEquipmentListLanguageEnum, game: GetItemsEquipmentListGameEnum, sortLevel?: GetItemsEquipmentListSortLevelEnum, filterMinLevel?: number, filterMaxLevel?: number, pageSize?: number, pageNumber?: number, fieldsItem?: Set<GetItemsEquipmentListFieldsItemEnum>, filterTypeNameId?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getItemsEquipmentList', 'language', language)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getItemsEquipmentList', 'game', game)
            const localVarPath = `/{game}/v1/{language}/items/equipment`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sortLevel !== undefined) {
                localVarQueryParameter['sort[level]'] = sortLevel;
            }

            if (filterMinLevel !== undefined) {
                localVarQueryParameter['filter[min_level]'] = filterMinLevel;
            }

            if (filterMaxLevel !== undefined) {
                localVarQueryParameter['filter[max_level]'] = filterMaxLevel;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page[size]'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['page[number]'] = pageNumber;
            }

            if (fieldsItem) {
                localVarQueryParameter['fields[item]'] = Array.from(fieldsItem).join(COLLECTION_FORMATS.csv);
            }

            if (filterTypeNameId) {
                localVarQueryParameter['filter[type.name_id]'] = Array.from(filterTypeNameId).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search in all names and descriptions of equipment items with a query.
         * @summary Search Equipment
         * @param {GetItemsEquipmentSearchLanguageEnum} language a valid language code
         * @param {GetItemsEquipmentSearchGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {string} query case sensitive search query
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {number} [limit] maximum number of returned results
         * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsEquipmentSearch: async (language: GetItemsEquipmentSearchLanguageEnum, game: GetItemsEquipmentSearchGameEnum, query: string, filterMinLevel?: number, filterMaxLevel?: number, limit?: number, filterTypeNameId?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getItemsEquipmentSearch', 'language', language)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getItemsEquipmentSearch', 'game', game)
            // verify required parameter 'query' is not null or undefined
            assertParamExists('getItemsEquipmentSearch', 'query', query)
            const localVarPath = `/{game}/v1/{language}/items/equipment/search`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (filterMinLevel !== undefined) {
                localVarQueryParameter['filter[min_level]'] = filterMinLevel;
            }

            if (filterMaxLevel !== undefined) {
                localVarQueryParameter['filter[max_level]'] = filterMaxLevel;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (filterTypeNameId) {
                localVarQueryParameter['filter[type.name_id]'] = Array.from(filterTypeNameId).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific equipment item with id.
         * @summary Single Equipment
         * @param {GetItemsEquipmentSingleLanguageEnum} language a valid language code
         * @param {number} ankamaId identifier
         * @param {GetItemsEquipmentSingleGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsEquipmentSingle: async (language: GetItemsEquipmentSingleLanguageEnum, ankamaId: number, game: GetItemsEquipmentSingleGameEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getItemsEquipmentSingle', 'language', language)
            // verify required parameter 'ankamaId' is not null or undefined
            assertParamExists('getItemsEquipmentSingle', 'ankamaId', ankamaId)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getItemsEquipmentSingle', 'game', game)
            const localVarPath = `/{game}/v1/{language}/items/equipment/{ankama_id}`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"ankama_id"}}`, encodeURIComponent(String(ankamaId)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EquipmentApi - functional programming interface
 * @export
 */
export const EquipmentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EquipmentApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve all equipment items with one request. This endpoint is just an alias for the a list with disabled pagination (page[size]=-1) and all fields[type] set.  If you want everything unfiltered, delete the other query parameters.  Be careful with testing or (god forbid) using /all in your browser, the returned json is huge and will slow down the browser!  Tip: set the HTTP Header \'Accept-Encoding: gzip\' for saving bandwidth. You will need to uncompress it on your end. Example with cURL: ``` curl -sH \'Accept-Encoding: gzip\' <api-endpoint> | gunzip - ```
         * @summary List All Equipment
         * @param {GetAllItemsEquipmentListLanguageEnum} language a valid language code
         * @param {GetAllItemsEquipmentListGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {GetAllItemsEquipmentListSortLevelEnum} [sortLevel] sort the resulting list by level, default unsorted
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {GetAllItemsEquipmentListAcceptEncodingEnum} [acceptEncoding] optional compression for saving bandwidth
         * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllItemsEquipmentList(language: GetAllItemsEquipmentListLanguageEnum, game: GetAllItemsEquipmentListGameEnum, sortLevel?: GetAllItemsEquipmentListSortLevelEnum, filterMinLevel?: number, filterMaxLevel?: number, acceptEncoding?: GetAllItemsEquipmentListAcceptEncodingEnum, filterTypeNameId?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllItemsEquipmentList(language, game, sortLevel, filterMinLevel, filterMaxLevel, acceptEncoding, filterTypeNameId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EquipmentApi.getAllItemsEquipmentList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of equipment items.
         * @summary List Equipment
         * @param {GetItemsEquipmentListLanguageEnum} language a valid language code
         * @param {GetItemsEquipmentListGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {GetItemsEquipmentListSortLevelEnum} [sortLevel] sort the resulting list by level, default unsorted
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {number} [pageSize] size of the results from the list. -1 disables pagination and gets all in one response.
         * @param {number} [pageNumber] page number based on the current page[size]. So you could get page 1 with 8 entrys and page 2 would have entries 8 to 16.
         * @param {Set<GetItemsEquipmentListFieldsItemEnum>} [fieldsItem] adds fields from their detail endpoint to the item list entries. Multiple comma separated values allowed.
         * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemsEquipmentList(language: GetItemsEquipmentListLanguageEnum, game: GetItemsEquipmentListGameEnum, sortLevel?: GetItemsEquipmentListSortLevelEnum, filterMinLevel?: number, filterMaxLevel?: number, pageSize?: number, pageNumber?: number, fieldsItem?: Set<GetItemsEquipmentListFieldsItemEnum>, filterTypeNameId?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemsEquipmentList(language, game, sortLevel, filterMinLevel, filterMaxLevel, pageSize, pageNumber, fieldsItem, filterTypeNameId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EquipmentApi.getItemsEquipmentList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search in all names and descriptions of equipment items with a query.
         * @summary Search Equipment
         * @param {GetItemsEquipmentSearchLanguageEnum} language a valid language code
         * @param {GetItemsEquipmentSearchGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {string} query case sensitive search query
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {number} [limit] maximum number of returned results
         * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemsEquipmentSearch(language: GetItemsEquipmentSearchLanguageEnum, game: GetItemsEquipmentSearchGameEnum, query: string, filterMinLevel?: number, filterMaxLevel?: number, limit?: number, filterTypeNameId?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemsEquipmentSearch(language, game, query, filterMinLevel, filterMaxLevel, limit, filterTypeNameId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EquipmentApi.getItemsEquipmentSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific equipment item with id.
         * @summary Single Equipment
         * @param {GetItemsEquipmentSingleLanguageEnum} language a valid language code
         * @param {number} ankamaId identifier
         * @param {GetItemsEquipmentSingleGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemsEquipmentSingle(language: GetItemsEquipmentSingleLanguageEnum, ankamaId: number, game: GetItemsEquipmentSingleGameEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Weapon>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemsEquipmentSingle(language, ankamaId, game, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EquipmentApi.getItemsEquipmentSingle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EquipmentApi - factory interface
 * @export
 */
export const EquipmentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EquipmentApiFp(configuration)
    return {
        /**
         * Retrieve all equipment items with one request. This endpoint is just an alias for the a list with disabled pagination (page[size]=-1) and all fields[type] set.  If you want everything unfiltered, delete the other query parameters.  Be careful with testing or (god forbid) using /all in your browser, the returned json is huge and will slow down the browser!  Tip: set the HTTP Header \'Accept-Encoding: gzip\' for saving bandwidth. You will need to uncompress it on your end. Example with cURL: ``` curl -sH \'Accept-Encoding: gzip\' <api-endpoint> | gunzip - ```
         * @summary List All Equipment
         * @param {GetAllItemsEquipmentListLanguageEnum} language a valid language code
         * @param {GetAllItemsEquipmentListGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {GetAllItemsEquipmentListSortLevelEnum} [sortLevel] sort the resulting list by level, default unsorted
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {GetAllItemsEquipmentListAcceptEncodingEnum} [acceptEncoding] optional compression for saving bandwidth
         * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllItemsEquipmentList(language: GetAllItemsEquipmentListLanguageEnum, game: GetAllItemsEquipmentListGameEnum, sortLevel?: GetAllItemsEquipmentListSortLevelEnum, filterMinLevel?: number, filterMaxLevel?: number, acceptEncoding?: GetAllItemsEquipmentListAcceptEncodingEnum, filterTypeNameId?: Set<string>, options?: RawAxiosRequestConfig): AxiosPromise<ListItems> {
            return localVarFp.getAllItemsEquipmentList(language, game, sortLevel, filterMinLevel, filterMaxLevel, acceptEncoding, filterTypeNameId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of equipment items.
         * @summary List Equipment
         * @param {GetItemsEquipmentListLanguageEnum} language a valid language code
         * @param {GetItemsEquipmentListGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {GetItemsEquipmentListSortLevelEnum} [sortLevel] sort the resulting list by level, default unsorted
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {number} [pageSize] size of the results from the list. -1 disables pagination and gets all in one response.
         * @param {number} [pageNumber] page number based on the current page[size]. So you could get page 1 with 8 entrys and page 2 would have entries 8 to 16.
         * @param {Set<GetItemsEquipmentListFieldsItemEnum>} [fieldsItem] adds fields from their detail endpoint to the item list entries. Multiple comma separated values allowed.
         * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsEquipmentList(language: GetItemsEquipmentListLanguageEnum, game: GetItemsEquipmentListGameEnum, sortLevel?: GetItemsEquipmentListSortLevelEnum, filterMinLevel?: number, filterMaxLevel?: number, pageSize?: number, pageNumber?: number, fieldsItem?: Set<GetItemsEquipmentListFieldsItemEnum>, filterTypeNameId?: Set<string>, options?: RawAxiosRequestConfig): AxiosPromise<ListItems> {
            return localVarFp.getItemsEquipmentList(language, game, sortLevel, filterMinLevel, filterMaxLevel, pageSize, pageNumber, fieldsItem, filterTypeNameId, options).then((request) => request(axios, basePath));
        },
        /**
         * Search in all names and descriptions of equipment items with a query.
         * @summary Search Equipment
         * @param {GetItemsEquipmentSearchLanguageEnum} language a valid language code
         * @param {GetItemsEquipmentSearchGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {string} query case sensitive search query
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {number} [limit] maximum number of returned results
         * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsEquipmentSearch(language: GetItemsEquipmentSearchLanguageEnum, game: GetItemsEquipmentSearchGameEnum, query: string, filterMinLevel?: number, filterMaxLevel?: number, limit?: number, filterTypeNameId?: Set<string>, options?: RawAxiosRequestConfig): AxiosPromise<Array<ListItem>> {
            return localVarFp.getItemsEquipmentSearch(language, game, query, filterMinLevel, filterMaxLevel, limit, filterTypeNameId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific equipment item with id.
         * @summary Single Equipment
         * @param {GetItemsEquipmentSingleLanguageEnum} language a valid language code
         * @param {number} ankamaId identifier
         * @param {GetItemsEquipmentSingleGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsEquipmentSingle(language: GetItemsEquipmentSingleLanguageEnum, ankamaId: number, game: GetItemsEquipmentSingleGameEnum, options?: RawAxiosRequestConfig): AxiosPromise<Weapon> {
            return localVarFp.getItemsEquipmentSingle(language, ankamaId, game, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EquipmentApi - object-oriented interface
 * @export
 * @class EquipmentApi
 * @extends {BaseAPI}
 */
export class EquipmentApi extends BaseAPI {
    /**
     * Retrieve all equipment items with one request. This endpoint is just an alias for the a list with disabled pagination (page[size]=-1) and all fields[type] set.  If you want everything unfiltered, delete the other query parameters.  Be careful with testing or (god forbid) using /all in your browser, the returned json is huge and will slow down the browser!  Tip: set the HTTP Header \'Accept-Encoding: gzip\' for saving bandwidth. You will need to uncompress it on your end. Example with cURL: ``` curl -sH \'Accept-Encoding: gzip\' <api-endpoint> | gunzip - ```
     * @summary List All Equipment
     * @param {GetAllItemsEquipmentListLanguageEnum} language a valid language code
     * @param {GetAllItemsEquipmentListGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
     * @param {GetAllItemsEquipmentListSortLevelEnum} [sortLevel] sort the resulting list by level, default unsorted
     * @param {number} [filterMinLevel] only results which level is equal or above this value
     * @param {number} [filterMaxLevel] only results which level is equal or below this value
     * @param {GetAllItemsEquipmentListAcceptEncodingEnum} [acceptEncoding] optional compression for saving bandwidth
     * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EquipmentApi
     */
    public getAllItemsEquipmentList(language: GetAllItemsEquipmentListLanguageEnum, game: GetAllItemsEquipmentListGameEnum, sortLevel?: GetAllItemsEquipmentListSortLevelEnum, filterMinLevel?: number, filterMaxLevel?: number, acceptEncoding?: GetAllItemsEquipmentListAcceptEncodingEnum, filterTypeNameId?: Set<string>, options?: RawAxiosRequestConfig) {
        return EquipmentApiFp(this.configuration).getAllItemsEquipmentList(language, game, sortLevel, filterMinLevel, filterMaxLevel, acceptEncoding, filterTypeNameId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of equipment items.
     * @summary List Equipment
     * @param {GetItemsEquipmentListLanguageEnum} language a valid language code
     * @param {GetItemsEquipmentListGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
     * @param {GetItemsEquipmentListSortLevelEnum} [sortLevel] sort the resulting list by level, default unsorted
     * @param {number} [filterMinLevel] only results which level is equal or above this value
     * @param {number} [filterMaxLevel] only results which level is equal or below this value
     * @param {number} [pageSize] size of the results from the list. -1 disables pagination and gets all in one response.
     * @param {number} [pageNumber] page number based on the current page[size]. So you could get page 1 with 8 entrys and page 2 would have entries 8 to 16.
     * @param {Set<GetItemsEquipmentListFieldsItemEnum>} [fieldsItem] adds fields from their detail endpoint to the item list entries. Multiple comma separated values allowed.
     * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EquipmentApi
     */
    public getItemsEquipmentList(language: GetItemsEquipmentListLanguageEnum, game: GetItemsEquipmentListGameEnum, sortLevel?: GetItemsEquipmentListSortLevelEnum, filterMinLevel?: number, filterMaxLevel?: number, pageSize?: number, pageNumber?: number, fieldsItem?: Set<GetItemsEquipmentListFieldsItemEnum>, filterTypeNameId?: Set<string>, options?: RawAxiosRequestConfig) {
        return EquipmentApiFp(this.configuration).getItemsEquipmentList(language, game, sortLevel, filterMinLevel, filterMaxLevel, pageSize, pageNumber, fieldsItem, filterTypeNameId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search in all names and descriptions of equipment items with a query.
     * @summary Search Equipment
     * @param {GetItemsEquipmentSearchLanguageEnum} language a valid language code
     * @param {GetItemsEquipmentSearchGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
     * @param {string} query case sensitive search query
     * @param {number} [filterMinLevel] only results which level is equal or above this value
     * @param {number} [filterMaxLevel] only results which level is equal or below this value
     * @param {number} [limit] maximum number of returned results
     * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EquipmentApi
     */
    public getItemsEquipmentSearch(language: GetItemsEquipmentSearchLanguageEnum, game: GetItemsEquipmentSearchGameEnum, query: string, filterMinLevel?: number, filterMaxLevel?: number, limit?: number, filterTypeNameId?: Set<string>, options?: RawAxiosRequestConfig) {
        return EquipmentApiFp(this.configuration).getItemsEquipmentSearch(language, game, query, filterMinLevel, filterMaxLevel, limit, filterTypeNameId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific equipment item with id.
     * @summary Single Equipment
     * @param {GetItemsEquipmentSingleLanguageEnum} language a valid language code
     * @param {number} ankamaId identifier
     * @param {GetItemsEquipmentSingleGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EquipmentApi
     */
    public getItemsEquipmentSingle(language: GetItemsEquipmentSingleLanguageEnum, ankamaId: number, game: GetItemsEquipmentSingleGameEnum, options?: RawAxiosRequestConfig) {
        return EquipmentApiFp(this.configuration).getItemsEquipmentSingle(language, ankamaId, game, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetAllItemsEquipmentListLanguageEnum = {
    En: 'en',
    Fr: 'fr',
    De: 'de',
    Es: 'es',
    Pt: 'pt'
} as const;
export type GetAllItemsEquipmentListLanguageEnum = typeof GetAllItemsEquipmentListLanguageEnum[keyof typeof GetAllItemsEquipmentListLanguageEnum];
/**
 * @export
 */
export const GetAllItemsEquipmentListGameEnum = {
    Dofus3: 'dofus3',
    Dofus3beta: 'dofus3beta'
} as const;
export type GetAllItemsEquipmentListGameEnum = typeof GetAllItemsEquipmentListGameEnum[keyof typeof GetAllItemsEquipmentListGameEnum];
/**
 * @export
 */
export const GetAllItemsEquipmentListSortLevelEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type GetAllItemsEquipmentListSortLevelEnum = typeof GetAllItemsEquipmentListSortLevelEnum[keyof typeof GetAllItemsEquipmentListSortLevelEnum];
/**
 * @export
 */
export const GetAllItemsEquipmentListAcceptEncodingEnum = {
    Gzip: 'gzip'
} as const;
export type GetAllItemsEquipmentListAcceptEncodingEnum = typeof GetAllItemsEquipmentListAcceptEncodingEnum[keyof typeof GetAllItemsEquipmentListAcceptEncodingEnum];
/**
 * @export
 */
export const GetItemsEquipmentListLanguageEnum = {
    En: 'en',
    Fr: 'fr',
    De: 'de',
    Es: 'es',
    Pt: 'pt'
} as const;
export type GetItemsEquipmentListLanguageEnum = typeof GetItemsEquipmentListLanguageEnum[keyof typeof GetItemsEquipmentListLanguageEnum];
/**
 * @export
 */
export const GetItemsEquipmentListGameEnum = {
    Dofus3: 'dofus3',
    Dofus3beta: 'dofus3beta'
} as const;
export type GetItemsEquipmentListGameEnum = typeof GetItemsEquipmentListGameEnum[keyof typeof GetItemsEquipmentListGameEnum];
/**
 * @export
 */
export const GetItemsEquipmentListSortLevelEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type GetItemsEquipmentListSortLevelEnum = typeof GetItemsEquipmentListSortLevelEnum[keyof typeof GetItemsEquipmentListSortLevelEnum];
/**
 * @export
 */
export const GetItemsEquipmentListFieldsItemEnum = {
    Recipe: 'recipe',
    Description: 'description',
    Conditions: 'conditions',
    Effects: 'effects',
    IsWeapon: 'is_weapon',
    Pods: 'pods',
    ParentSet: 'parent_set',
    CriticalHitProbability: 'critical_hit_probability',
    CriticalHitBonus: 'critical_hit_bonus',
    MaxCastPerTurn: 'max_cast_per_turn',
    ApCost: 'ap_cost',
    Range: 'range'
} as const;
export type GetItemsEquipmentListFieldsItemEnum = typeof GetItemsEquipmentListFieldsItemEnum[keyof typeof GetItemsEquipmentListFieldsItemEnum];
/**
 * @export
 */
export const GetItemsEquipmentSearchLanguageEnum = {
    En: 'en',
    Fr: 'fr',
    De: 'de',
    Es: 'es',
    Pt: 'pt'
} as const;
export type GetItemsEquipmentSearchLanguageEnum = typeof GetItemsEquipmentSearchLanguageEnum[keyof typeof GetItemsEquipmentSearchLanguageEnum];
/**
 * @export
 */
export const GetItemsEquipmentSearchGameEnum = {
    Dofus3: 'dofus3',
    Dofus3beta: 'dofus3beta'
} as const;
export type GetItemsEquipmentSearchGameEnum = typeof GetItemsEquipmentSearchGameEnum[keyof typeof GetItemsEquipmentSearchGameEnum];
/**
 * @export
 */
export const GetItemsEquipmentSingleLanguageEnum = {
    En: 'en',
    Fr: 'fr',
    De: 'de',
    Es: 'es',
    Pt: 'pt'
} as const;
export type GetItemsEquipmentSingleLanguageEnum = typeof GetItemsEquipmentSingleLanguageEnum[keyof typeof GetItemsEquipmentSingleLanguageEnum];
/**
 * @export
 */
export const GetItemsEquipmentSingleGameEnum = {
    Dofus3: 'dofus3',
    Dofus3beta: 'dofus3beta'
} as const;
export type GetItemsEquipmentSingleGameEnum = typeof GetItemsEquipmentSingleGameEnum[keyof typeof GetItemsEquipmentSingleGameEnum];


/**
 * GameApi - axios parameter creator
 * @export
 */
export const GameApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Search in all names and descriptions of all supported types in the game. For the list of supported types see the endpoint /dofus3/meta/search/types.
         * @summary Game Search
         * @param {GetGameSearchLanguageEnum} language a valid language code
         * @param {GetGameSearchGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {string} query search query
         * @param {Set<GetGameSearchFilterSearchIndexEnum>} [filterSearchIndex] only results with all specific type
         * @param {number} [limit] maximum number of returned results
         * @param {Set<GetGameSearchFieldsItemEnum>} [fieldsItem] adds fields from the item search to the list entries if the hit is an item. Multiple comma separated values allowed.
         * @param {Set<string>} [filterTypeNameId] multi-filter results with the english item type name, including \&quot;mount\&quot; and \&quot;set\&quot; from filter[search_index]. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGameSearch: async (language: GetGameSearchLanguageEnum, game: GetGameSearchGameEnum, query: string, filterSearchIndex?: Set<GetGameSearchFilterSearchIndexEnum>, limit?: number, fieldsItem?: Set<GetGameSearchFieldsItemEnum>, filterTypeNameId?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getGameSearch', 'language', language)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getGameSearch', 'game', game)
            // verify required parameter 'query' is not null or undefined
            assertParamExists('getGameSearch', 'query', query)
            const localVarPath = `/{game}/v1/{language}/search`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (filterSearchIndex) {
                localVarQueryParameter['filter[search_index]'] = Array.from(filterSearchIndex).join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fieldsItem) {
                localVarQueryParameter['fields[item]'] = Array.from(fieldsItem).join(COLLECTION_FORMATS.csv);
            }

            if (filterTypeNameId) {
                localVarQueryParameter['filter[type.name_id]'] = Array.from(filterTypeNameId).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search in all names and descriptions of Dofus items (including all subtypes) with a query.
         * @summary Search All Items
         * @param {GetItemsAllSearchLanguageEnum} language a valid language code
         * @param {GetItemsAllSearchGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {string} query case sensitive search query
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {number} [limit] maximum number of returned results
         * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsAllSearch: async (language: GetItemsAllSearchLanguageEnum, game: GetItemsAllSearchGameEnum, query: string, filterMinLevel?: number, filterMaxLevel?: number, limit?: number, filterTypeNameId?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getItemsAllSearch', 'language', language)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getItemsAllSearch', 'game', game)
            // verify required parameter 'query' is not null or undefined
            assertParamExists('getItemsAllSearch', 'query', query)
            const localVarPath = `/{game}/v1/{language}/items/search`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (filterMinLevel !== undefined) {
                localVarQueryParameter['filter[min_level]'] = filterMinLevel;
            }

            if (filterMaxLevel !== undefined) {
                localVarQueryParameter['filter[max_level]'] = filterMaxLevel;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (filterTypeNameId) {
                localVarQueryParameter['filter[type.name_id]'] = Array.from(filterTypeNameId).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GameApi - functional programming interface
 * @export
 */
export const GameApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GameApiAxiosParamCreator(configuration)
    return {
        /**
         * Search in all names and descriptions of all supported types in the game. For the list of supported types see the endpoint /dofus3/meta/search/types.
         * @summary Game Search
         * @param {GetGameSearchLanguageEnum} language a valid language code
         * @param {GetGameSearchGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {string} query search query
         * @param {Set<GetGameSearchFilterSearchIndexEnum>} [filterSearchIndex] only results with all specific type
         * @param {number} [limit] maximum number of returned results
         * @param {Set<GetGameSearchFieldsItemEnum>} [fieldsItem] adds fields from the item search to the list entries if the hit is an item. Multiple comma separated values allowed.
         * @param {Set<string>} [filterTypeNameId] multi-filter results with the english item type name, including \&quot;mount\&quot; and \&quot;set\&quot; from filter[search_index]. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGameSearch(language: GetGameSearchLanguageEnum, game: GetGameSearchGameEnum, query: string, filterSearchIndex?: Set<GetGameSearchFilterSearchIndexEnum>, limit?: number, fieldsItem?: Set<GetGameSearchFieldsItemEnum>, filterTypeNameId?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GameSearch>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGameSearch(language, game, query, filterSearchIndex, limit, fieldsItem, filterTypeNameId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameApi.getGameSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search in all names and descriptions of Dofus items (including all subtypes) with a query.
         * @summary Search All Items
         * @param {GetItemsAllSearchLanguageEnum} language a valid language code
         * @param {GetItemsAllSearchGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {string} query case sensitive search query
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {number} [limit] maximum number of returned results
         * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemsAllSearch(language: GetItemsAllSearchLanguageEnum, game: GetItemsAllSearchGameEnum, query: string, filterMinLevel?: number, filterMaxLevel?: number, limit?: number, filterTypeNameId?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListItemGeneral>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemsAllSearch(language, game, query, filterMinLevel, filterMaxLevel, limit, filterTypeNameId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameApi.getItemsAllSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GameApi - factory interface
 * @export
 */
export const GameApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GameApiFp(configuration)
    return {
        /**
         * Search in all names and descriptions of all supported types in the game. For the list of supported types see the endpoint /dofus3/meta/search/types.
         * @summary Game Search
         * @param {GetGameSearchLanguageEnum} language a valid language code
         * @param {GetGameSearchGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {string} query search query
         * @param {Set<GetGameSearchFilterSearchIndexEnum>} [filterSearchIndex] only results with all specific type
         * @param {number} [limit] maximum number of returned results
         * @param {Set<GetGameSearchFieldsItemEnum>} [fieldsItem] adds fields from the item search to the list entries if the hit is an item. Multiple comma separated values allowed.
         * @param {Set<string>} [filterTypeNameId] multi-filter results with the english item type name, including \&quot;mount\&quot; and \&quot;set\&quot; from filter[search_index]. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGameSearch(language: GetGameSearchLanguageEnum, game: GetGameSearchGameEnum, query: string, filterSearchIndex?: Set<GetGameSearchFilterSearchIndexEnum>, limit?: number, fieldsItem?: Set<GetGameSearchFieldsItemEnum>, filterTypeNameId?: Set<string>, options?: RawAxiosRequestConfig): AxiosPromise<Array<GameSearch>> {
            return localVarFp.getGameSearch(language, game, query, filterSearchIndex, limit, fieldsItem, filterTypeNameId, options).then((request) => request(axios, basePath));
        },
        /**
         * Search in all names and descriptions of Dofus items (including all subtypes) with a query.
         * @summary Search All Items
         * @param {GetItemsAllSearchLanguageEnum} language a valid language code
         * @param {GetItemsAllSearchGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {string} query case sensitive search query
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {number} [limit] maximum number of returned results
         * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsAllSearch(language: GetItemsAllSearchLanguageEnum, game: GetItemsAllSearchGameEnum, query: string, filterMinLevel?: number, filterMaxLevel?: number, limit?: number, filterTypeNameId?: Set<string>, options?: RawAxiosRequestConfig): AxiosPromise<Array<ListItemGeneral>> {
            return localVarFp.getItemsAllSearch(language, game, query, filterMinLevel, filterMaxLevel, limit, filterTypeNameId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GameApi - object-oriented interface
 * @export
 * @class GameApi
 * @extends {BaseAPI}
 */
export class GameApi extends BaseAPI {
    /**
     * Search in all names and descriptions of all supported types in the game. For the list of supported types see the endpoint /dofus3/meta/search/types.
     * @summary Game Search
     * @param {GetGameSearchLanguageEnum} language a valid language code
     * @param {GetGameSearchGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
     * @param {string} query search query
     * @param {Set<GetGameSearchFilterSearchIndexEnum>} [filterSearchIndex] only results with all specific type
     * @param {number} [limit] maximum number of returned results
     * @param {Set<GetGameSearchFieldsItemEnum>} [fieldsItem] adds fields from the item search to the list entries if the hit is an item. Multiple comma separated values allowed.
     * @param {Set<string>} [filterTypeNameId] multi-filter results with the english item type name, including \&quot;mount\&quot; and \&quot;set\&quot; from filter[search_index]. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameApi
     */
    public getGameSearch(language: GetGameSearchLanguageEnum, game: GetGameSearchGameEnum, query: string, filterSearchIndex?: Set<GetGameSearchFilterSearchIndexEnum>, limit?: number, fieldsItem?: Set<GetGameSearchFieldsItemEnum>, filterTypeNameId?: Set<string>, options?: RawAxiosRequestConfig) {
        return GameApiFp(this.configuration).getGameSearch(language, game, query, filterSearchIndex, limit, fieldsItem, filterTypeNameId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search in all names and descriptions of Dofus items (including all subtypes) with a query.
     * @summary Search All Items
     * @param {GetItemsAllSearchLanguageEnum} language a valid language code
     * @param {GetItemsAllSearchGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
     * @param {string} query case sensitive search query
     * @param {number} [filterMinLevel] only results which level is equal or above this value
     * @param {number} [filterMaxLevel] only results which level is equal or below this value
     * @param {number} [limit] maximum number of returned results
     * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameApi
     */
    public getItemsAllSearch(language: GetItemsAllSearchLanguageEnum, game: GetItemsAllSearchGameEnum, query: string, filterMinLevel?: number, filterMaxLevel?: number, limit?: number, filterTypeNameId?: Set<string>, options?: RawAxiosRequestConfig) {
        return GameApiFp(this.configuration).getItemsAllSearch(language, game, query, filterMinLevel, filterMaxLevel, limit, filterTypeNameId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetGameSearchLanguageEnum = {
    En: 'en',
    Fr: 'fr',
    De: 'de',
    Es: 'es',
    Pt: 'pt'
} as const;
export type GetGameSearchLanguageEnum = typeof GetGameSearchLanguageEnum[keyof typeof GetGameSearchLanguageEnum];
/**
 * @export
 */
export const GetGameSearchGameEnum = {
    Dofus3: 'dofus3',
    Dofus3beta: 'dofus3beta'
} as const;
export type GetGameSearchGameEnum = typeof GetGameSearchGameEnum[keyof typeof GetGameSearchGameEnum];
/**
 * @export
 */
export const GetGameSearchFilterSearchIndexEnum = {
    ItemsConsumables: 'items-consumables',
    ItemsCosmetics: 'items-cosmetics',
    ItemsResources: 'items-resources',
    ItemsEquipment: 'items-equipment',
    ItemsQuestItems: 'items-quest_items',
    Mounts: 'mounts',
    Sets: 'sets'
} as const;
export type GetGameSearchFilterSearchIndexEnum = typeof GetGameSearchFilterSearchIndexEnum[keyof typeof GetGameSearchFilterSearchIndexEnum];
/**
 * @export
 */
export const GetGameSearchFieldsItemEnum = {
    Level: 'level',
    ImageUrls: 'image_urls',
    Type: 'type'
} as const;
export type GetGameSearchFieldsItemEnum = typeof GetGameSearchFieldsItemEnum[keyof typeof GetGameSearchFieldsItemEnum];
/**
 * @export
 */
export const GetItemsAllSearchLanguageEnum = {
    En: 'en',
    Fr: 'fr',
    De: 'de',
    Es: 'es',
    Pt: 'pt'
} as const;
export type GetItemsAllSearchLanguageEnum = typeof GetItemsAllSearchLanguageEnum[keyof typeof GetItemsAllSearchLanguageEnum];
/**
 * @export
 */
export const GetItemsAllSearchGameEnum = {
    Dofus3: 'dofus3',
    Dofus3beta: 'dofus3beta'
} as const;
export type GetItemsAllSearchGameEnum = typeof GetItemsAllSearchGameEnum[keyof typeof GetItemsAllSearchGameEnum];


/**
 * MetaApi - axios parameter creator
 * @export
 */
export const MetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all types for /{game}/v1/{lang}/search available for filtering. All names are english for comparing them inside applications. Order is fixed so you can compare indices instead of strings.
         * @summary Available Game Search Types
         * @param {GetGameSearchTypesGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGameSearchTypes: async (game: GetGameSearchTypesGameEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getGameSearchTypes', 'game', game)
            const localVarPath = `/{game}/v1/meta/search/types`
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all types of all items. Primarily used for filtering more detailed types in listings or search endpoints. All names are english for comparing them inside applications. Ordering is not guaranteed to persist with game updates.
         * @summary Available Item Types
         * @param {GetItemTypesGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemTypes: async (game: GetItemTypesGameEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getItemTypes', 'game', game)
            const localVarPath = `/{game}/v1/meta/items/types`
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all the available bonuses and their id for filtering them in the range endpoint.
         * @summary Available Almanax Bonuses
         * @param {GetMetaAlmanaxBonusesLanguageEnum} language a valid language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetaAlmanaxBonuses: async (language: GetMetaAlmanaxBonusesLanguageEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getMetaAlmanaxBonuses', 'language', language)
            const localVarPath = `/dofus3/v1/meta/{language}/almanax/bonuses`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search all the available bonuses and their id for filtering them in the range endpoint.
         * @summary Search Available Almanax Bonuses
         * @param {GetMetaAlmanaxBonusesSearchLanguageEnum} language a valid language code
         * @param {string} query case sensitive search query
         * @param {number} [limit] maximum number of returned results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetaAlmanaxBonusesSearch: async (language: GetMetaAlmanaxBonusesSearchLanguageEnum, query: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getMetaAlmanaxBonusesSearch', 'language', language)
            // verify required parameter 'query' is not null or undefined
            assertParamExists('getMetaAlmanaxBonusesSearch', 'query', query)
            const localVarPath = `/dofus3/v1/meta/{language}/almanax/bonuses/search`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the mappings for all specific elements that are linked in the dataset. All names are english. Translations are not needed because of a global unique id which is the index inside the array. Future elements will get a higher id.
         * @summary Effects and Condition Elements
         * @param {GetMetaElementsGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetaElements: async (game: GetMetaElementsGameEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getMetaElements', 'game', game)
            const localVarPath = `/{game}/v1/meta/elements`
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The current game version of the hosted data.
         * @summary Game Version
         * @param {GetMetaVersionGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetaVersion: async (game: GetMetaVersionGameEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getMetaVersion', 'game', game)
            const localVarPath = `/{game}/v1/meta/version`
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetaApi - functional programming interface
 * @export
 */
export const MetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetaApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all types for /{game}/v1/{lang}/search available for filtering. All names are english for comparing them inside applications. Order is fixed so you can compare indices instead of strings.
         * @summary Available Game Search Types
         * @param {GetGameSearchTypesGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGameSearchTypes(game: GetGameSearchTypesGameEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGameSearchTypes(game, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetaApi.getGameSearchTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all types of all items. Primarily used for filtering more detailed types in listings or search endpoints. All names are english for comparing them inside applications. Ordering is not guaranteed to persist with game updates.
         * @summary Available Item Types
         * @param {GetItemTypesGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemTypes(game: GetItemTypesGameEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemTypes(game, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetaApi.getItemTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all the available bonuses and their id for filtering them in the range endpoint.
         * @summary Available Almanax Bonuses
         * @param {GetMetaAlmanaxBonusesLanguageEnum} language a valid language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetaAlmanaxBonuses(language: GetMetaAlmanaxBonusesLanguageEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetMetaAlmanaxBonuses200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetaAlmanaxBonuses(language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetaApi.getMetaAlmanaxBonuses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search all the available bonuses and their id for filtering them in the range endpoint.
         * @summary Search Available Almanax Bonuses
         * @param {GetMetaAlmanaxBonusesSearchLanguageEnum} language a valid language code
         * @param {string} query case sensitive search query
         * @param {number} [limit] maximum number of returned results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetaAlmanaxBonusesSearch(language: GetMetaAlmanaxBonusesSearchLanguageEnum, query: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetMetaAlmanaxBonuses200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetaAlmanaxBonusesSearch(language, query, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetaApi.getMetaAlmanaxBonusesSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the mappings for all specific elements that are linked in the dataset. All names are english. Translations are not needed because of a global unique id which is the index inside the array. Future elements will get a higher id.
         * @summary Effects and Condition Elements
         * @param {GetMetaElementsGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetaElements(game: GetMetaElementsGameEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetaElements(game, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetaApi.getMetaElements']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The current game version of the hosted data.
         * @summary Game Version
         * @param {GetMetaVersionGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetaVersion(game: GetMetaVersionGameEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Version>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetaVersion(game, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetaApi.getMetaVersion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MetaApi - factory interface
 * @export
 */
export const MetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetaApiFp(configuration)
    return {
        /**
         * Get all types for /{game}/v1/{lang}/search available for filtering. All names are english for comparing them inside applications. Order is fixed so you can compare indices instead of strings.
         * @summary Available Game Search Types
         * @param {GetGameSearchTypesGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGameSearchTypes(game: GetGameSearchTypesGameEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.getGameSearchTypes(game, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all types of all items. Primarily used for filtering more detailed types in listings or search endpoints. All names are english for comparing them inside applications. Ordering is not guaranteed to persist with game updates.
         * @summary Available Item Types
         * @param {GetItemTypesGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemTypes(game: GetItemTypesGameEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.getItemTypes(game, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all the available bonuses and their id for filtering them in the range endpoint.
         * @summary Available Almanax Bonuses
         * @param {GetMetaAlmanaxBonusesLanguageEnum} language a valid language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetaAlmanaxBonuses(language: GetMetaAlmanaxBonusesLanguageEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMetaAlmanaxBonuses200ResponseInner>> {
            return localVarFp.getMetaAlmanaxBonuses(language, options).then((request) => request(axios, basePath));
        },
        /**
         * Search all the available bonuses and their id for filtering them in the range endpoint.
         * @summary Search Available Almanax Bonuses
         * @param {GetMetaAlmanaxBonusesSearchLanguageEnum} language a valid language code
         * @param {string} query case sensitive search query
         * @param {number} [limit] maximum number of returned results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetaAlmanaxBonusesSearch(language: GetMetaAlmanaxBonusesSearchLanguageEnum, query: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMetaAlmanaxBonuses200ResponseInner>> {
            return localVarFp.getMetaAlmanaxBonusesSearch(language, query, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the mappings for all specific elements that are linked in the dataset. All names are english. Translations are not needed because of a global unique id which is the index inside the array. Future elements will get a higher id.
         * @summary Effects and Condition Elements
         * @param {GetMetaElementsGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetaElements(game: GetMetaElementsGameEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.getMetaElements(game, options).then((request) => request(axios, basePath));
        },
        /**
         * The current game version of the hosted data.
         * @summary Game Version
         * @param {GetMetaVersionGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetaVersion(game: GetMetaVersionGameEnum, options?: RawAxiosRequestConfig): AxiosPromise<Version> {
            return localVarFp.getMetaVersion(game, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetaApi - object-oriented interface
 * @export
 * @class MetaApi
 * @extends {BaseAPI}
 */
export class MetaApi extends BaseAPI {
    /**
     * Get all types for /{game}/v1/{lang}/search available for filtering. All names are english for comparing them inside applications. Order is fixed so you can compare indices instead of strings.
     * @summary Available Game Search Types
     * @param {GetGameSearchTypesGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetaApi
     */
    public getGameSearchTypes(game: GetGameSearchTypesGameEnum, options?: RawAxiosRequestConfig) {
        return MetaApiFp(this.configuration).getGameSearchTypes(game, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all types of all items. Primarily used for filtering more detailed types in listings or search endpoints. All names are english for comparing them inside applications. Ordering is not guaranteed to persist with game updates.
     * @summary Available Item Types
     * @param {GetItemTypesGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetaApi
     */
    public getItemTypes(game: GetItemTypesGameEnum, options?: RawAxiosRequestConfig) {
        return MetaApiFp(this.configuration).getItemTypes(game, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all the available bonuses and their id for filtering them in the range endpoint.
     * @summary Available Almanax Bonuses
     * @param {GetMetaAlmanaxBonusesLanguageEnum} language a valid language code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetaApi
     */
    public getMetaAlmanaxBonuses(language: GetMetaAlmanaxBonusesLanguageEnum, options?: RawAxiosRequestConfig) {
        return MetaApiFp(this.configuration).getMetaAlmanaxBonuses(language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search all the available bonuses and their id for filtering them in the range endpoint.
     * @summary Search Available Almanax Bonuses
     * @param {GetMetaAlmanaxBonusesSearchLanguageEnum} language a valid language code
     * @param {string} query case sensitive search query
     * @param {number} [limit] maximum number of returned results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetaApi
     */
    public getMetaAlmanaxBonusesSearch(language: GetMetaAlmanaxBonusesSearchLanguageEnum, query: string, limit?: number, options?: RawAxiosRequestConfig) {
        return MetaApiFp(this.configuration).getMetaAlmanaxBonusesSearch(language, query, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the mappings for all specific elements that are linked in the dataset. All names are english. Translations are not needed because of a global unique id which is the index inside the array. Future elements will get a higher id.
     * @summary Effects and Condition Elements
     * @param {GetMetaElementsGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetaApi
     */
    public getMetaElements(game: GetMetaElementsGameEnum, options?: RawAxiosRequestConfig) {
        return MetaApiFp(this.configuration).getMetaElements(game, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The current game version of the hosted data.
     * @summary Game Version
     * @param {GetMetaVersionGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetaApi
     */
    public getMetaVersion(game: GetMetaVersionGameEnum, options?: RawAxiosRequestConfig) {
        return MetaApiFp(this.configuration).getMetaVersion(game, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetGameSearchTypesGameEnum = {
    Dofus3: 'dofus3',
    Dofus3beta: 'dofus3beta'
} as const;
export type GetGameSearchTypesGameEnum = typeof GetGameSearchTypesGameEnum[keyof typeof GetGameSearchTypesGameEnum];
/**
 * @export
 */
export const GetItemTypesGameEnum = {
    Dofus3: 'dofus3',
    Dofus3beta: 'dofus3beta'
} as const;
export type GetItemTypesGameEnum = typeof GetItemTypesGameEnum[keyof typeof GetItemTypesGameEnum];
/**
 * @export
 */
export const GetMetaAlmanaxBonusesLanguageEnum = {
    En: 'en',
    Fr: 'fr',
    De: 'de',
    It: 'it',
    Es: 'es'
} as const;
export type GetMetaAlmanaxBonusesLanguageEnum = typeof GetMetaAlmanaxBonusesLanguageEnum[keyof typeof GetMetaAlmanaxBonusesLanguageEnum];
/**
 * @export
 */
export const GetMetaAlmanaxBonusesSearchLanguageEnum = {
    En: 'en',
    Fr: 'fr',
    De: 'de',
    It: 'it',
    Es: 'es'
} as const;
export type GetMetaAlmanaxBonusesSearchLanguageEnum = typeof GetMetaAlmanaxBonusesSearchLanguageEnum[keyof typeof GetMetaAlmanaxBonusesSearchLanguageEnum];
/**
 * @export
 */
export const GetMetaElementsGameEnum = {
    Dofus3: 'dofus3',
    Dofus3beta: 'dofus3beta'
} as const;
export type GetMetaElementsGameEnum = typeof GetMetaElementsGameEnum[keyof typeof GetMetaElementsGameEnum];
/**
 * @export
 */
export const GetMetaVersionGameEnum = {
    Dofus3: 'dofus3',
    Dofus3beta: 'dofus3beta'
} as const;
export type GetMetaVersionGameEnum = typeof GetMetaVersionGameEnum[keyof typeof GetMetaVersionGameEnum];


/**
 * MountsApi - axios parameter creator
 * @export
 */
export const MountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve all mounts with one request. This endpoint is just an alias for the a list with disabled pagination (page[size]=-1) and all fields[type] set.  If you want everything unfiltered, delete the other query parameters.  Be careful with testing or (god forbid) using /all in your browser, the returned json is huge and will slow down the browser!  Tip: set the HTTP Header \'Accept-Encoding: gzip\' for saving bandwidth. You will need to uncompress it on your end. Example with cURL: ``` curl -sH \'Accept-Encoding: gzip\' <api-endpoint> | gunzip - ```
         * @summary List All Mounts
         * @param {GetAllMountsListLanguageEnum} language a valid language code
         * @param {GetAllMountsListGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {string} [filterFamilyName] only results with the translated family name
         * @param {GetAllMountsListAcceptEncodingEnum} [acceptEncoding] optional compression for saving bandwidth
         * @param {number} [filterFamilyId] only results with the unique family id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMountsList: async (language: GetAllMountsListLanguageEnum, game: GetAllMountsListGameEnum, filterFamilyName?: string, acceptEncoding?: GetAllMountsListAcceptEncodingEnum, filterFamilyId?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getAllMountsList', 'language', language)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getAllMountsList', 'game', game)
            const localVarPath = `/{game}/v1/{language}/mounts/all`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filterFamilyName !== undefined) {
                localVarQueryParameter['filter[family.name]'] = filterFamilyName;
            }

            if (filterFamilyId !== undefined) {
                localVarQueryParameter['filter[family.id]'] = filterFamilyId;
            }


    
            if (acceptEncoding != null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of mounts.
         * @summary List Mounts
         * @param {GetMountsListLanguageEnum} language a valid language code
         * @param {GetMountsListGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {string} [filterFamilyName] only results with the translated family name
         * @param {number} [pageSize] size of the results from the list. -1 disables pagination and gets all in one response.
         * @param {number} [pageNumber] page number based on the current page[size]. So you could get page 1 with 8 entrys and page 2 would have entries 8 to 16.
         * @param {Set<GetMountsListFieldsMountEnum>} [fieldsMount] adds fields from their detail endpoint to the item list entries. Multiple comma separated values allowed.
         * @param {number} [filterFamilyId] only results with the unique family id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMountsList: async (language: GetMountsListLanguageEnum, game: GetMountsListGameEnum, filterFamilyName?: string, pageSize?: number, pageNumber?: number, fieldsMount?: Set<GetMountsListFieldsMountEnum>, filterFamilyId?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getMountsList', 'language', language)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getMountsList', 'game', game)
            const localVarPath = `/{game}/v1/{language}/mounts`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filterFamilyName !== undefined) {
                localVarQueryParameter['filter[family.name]'] = filterFamilyName;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page[size]'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['page[number]'] = pageNumber;
            }

            if (fieldsMount) {
                localVarQueryParameter['fields[mount]'] = Array.from(fieldsMount).join(COLLECTION_FORMATS.csv);
            }

            if (filterFamilyId !== undefined) {
                localVarQueryParameter['filter[family.id]'] = filterFamilyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search in all names and descriptions of mounts with a query.
         * @summary Search Mounts
         * @param {GetMountsSearchLanguageEnum} language a valid language code
         * @param {GetMountsSearchGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {string} query case sensitive search query
         * @param {string} [filterFamilyName] only results with the translated family name
         * @param {number} [limit] maximum number of returned results
         * @param {number} [filterFamilyId] only results with the unique family id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMountsSearch: async (language: GetMountsSearchLanguageEnum, game: GetMountsSearchGameEnum, query: string, filterFamilyName?: string, limit?: number, filterFamilyId?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getMountsSearch', 'language', language)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getMountsSearch', 'game', game)
            // verify required parameter 'query' is not null or undefined
            assertParamExists('getMountsSearch', 'query', query)
            const localVarPath = `/{game}/v1/{language}/mounts/search`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (filterFamilyName !== undefined) {
                localVarQueryParameter['filter[family.name]'] = filterFamilyName;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (filterFamilyId !== undefined) {
                localVarQueryParameter['filter[family.id]'] = filterFamilyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific mount with id.
         * @summary Single Mounts
         * @param {GetMountsSingleLanguageEnum} language a valid language code
         * @param {number} ankamaId identifier
         * @param {GetMountsSingleGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMountsSingle: async (language: GetMountsSingleLanguageEnum, ankamaId: number, game: GetMountsSingleGameEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getMountsSingle', 'language', language)
            // verify required parameter 'ankamaId' is not null or undefined
            assertParamExists('getMountsSingle', 'ankamaId', ankamaId)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getMountsSingle', 'game', game)
            const localVarPath = `/{game}/v1/{language}/mounts/{ankama_id}`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"ankama_id"}}`, encodeURIComponent(String(ankamaId)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MountsApi - functional programming interface
 * @export
 */
export const MountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MountsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve all mounts with one request. This endpoint is just an alias for the a list with disabled pagination (page[size]=-1) and all fields[type] set.  If you want everything unfiltered, delete the other query parameters.  Be careful with testing or (god forbid) using /all in your browser, the returned json is huge and will slow down the browser!  Tip: set the HTTP Header \'Accept-Encoding: gzip\' for saving bandwidth. You will need to uncompress it on your end. Example with cURL: ``` curl -sH \'Accept-Encoding: gzip\' <api-endpoint> | gunzip - ```
         * @summary List All Mounts
         * @param {GetAllMountsListLanguageEnum} language a valid language code
         * @param {GetAllMountsListGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {string} [filterFamilyName] only results with the translated family name
         * @param {GetAllMountsListAcceptEncodingEnum} [acceptEncoding] optional compression for saving bandwidth
         * @param {number} [filterFamilyId] only results with the unique family id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllMountsList(language: GetAllMountsListLanguageEnum, game: GetAllMountsListGameEnum, filterFamilyName?: string, acceptEncoding?: GetAllMountsListAcceptEncodingEnum, filterFamilyId?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListMounts>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllMountsList(language, game, filterFamilyName, acceptEncoding, filterFamilyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MountsApi.getAllMountsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of mounts.
         * @summary List Mounts
         * @param {GetMountsListLanguageEnum} language a valid language code
         * @param {GetMountsListGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {string} [filterFamilyName] only results with the translated family name
         * @param {number} [pageSize] size of the results from the list. -1 disables pagination and gets all in one response.
         * @param {number} [pageNumber] page number based on the current page[size]. So you could get page 1 with 8 entrys and page 2 would have entries 8 to 16.
         * @param {Set<GetMountsListFieldsMountEnum>} [fieldsMount] adds fields from their detail endpoint to the item list entries. Multiple comma separated values allowed.
         * @param {number} [filterFamilyId] only results with the unique family id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMountsList(language: GetMountsListLanguageEnum, game: GetMountsListGameEnum, filterFamilyName?: string, pageSize?: number, pageNumber?: number, fieldsMount?: Set<GetMountsListFieldsMountEnum>, filterFamilyId?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListMounts>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMountsList(language, game, filterFamilyName, pageSize, pageNumber, fieldsMount, filterFamilyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MountsApi.getMountsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search in all names and descriptions of mounts with a query.
         * @summary Search Mounts
         * @param {GetMountsSearchLanguageEnum} language a valid language code
         * @param {GetMountsSearchGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {string} query case sensitive search query
         * @param {string} [filterFamilyName] only results with the translated family name
         * @param {number} [limit] maximum number of returned results
         * @param {number} [filterFamilyId] only results with the unique family id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMountsSearch(language: GetMountsSearchLanguageEnum, game: GetMountsSearchGameEnum, query: string, filterFamilyName?: string, limit?: number, filterFamilyId?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Mount>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMountsSearch(language, game, query, filterFamilyName, limit, filterFamilyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MountsApi.getMountsSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific mount with id.
         * @summary Single Mounts
         * @param {GetMountsSingleLanguageEnum} language a valid language code
         * @param {number} ankamaId identifier
         * @param {GetMountsSingleGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMountsSingle(language: GetMountsSingleLanguageEnum, ankamaId: number, game: GetMountsSingleGameEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Mount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMountsSingle(language, ankamaId, game, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MountsApi.getMountsSingle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MountsApi - factory interface
 * @export
 */
export const MountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MountsApiFp(configuration)
    return {
        /**
         * Retrieve all mounts with one request. This endpoint is just an alias for the a list with disabled pagination (page[size]=-1) and all fields[type] set.  If you want everything unfiltered, delete the other query parameters.  Be careful with testing or (god forbid) using /all in your browser, the returned json is huge and will slow down the browser!  Tip: set the HTTP Header \'Accept-Encoding: gzip\' for saving bandwidth. You will need to uncompress it on your end. Example with cURL: ``` curl -sH \'Accept-Encoding: gzip\' <api-endpoint> | gunzip - ```
         * @summary List All Mounts
         * @param {GetAllMountsListLanguageEnum} language a valid language code
         * @param {GetAllMountsListGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {string} [filterFamilyName] only results with the translated family name
         * @param {GetAllMountsListAcceptEncodingEnum} [acceptEncoding] optional compression for saving bandwidth
         * @param {number} [filterFamilyId] only results with the unique family id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMountsList(language: GetAllMountsListLanguageEnum, game: GetAllMountsListGameEnum, filterFamilyName?: string, acceptEncoding?: GetAllMountsListAcceptEncodingEnum, filterFamilyId?: number, options?: RawAxiosRequestConfig): AxiosPromise<ListMounts> {
            return localVarFp.getAllMountsList(language, game, filterFamilyName, acceptEncoding, filterFamilyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of mounts.
         * @summary List Mounts
         * @param {GetMountsListLanguageEnum} language a valid language code
         * @param {GetMountsListGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {string} [filterFamilyName] only results with the translated family name
         * @param {number} [pageSize] size of the results from the list. -1 disables pagination and gets all in one response.
         * @param {number} [pageNumber] page number based on the current page[size]. So you could get page 1 with 8 entrys and page 2 would have entries 8 to 16.
         * @param {Set<GetMountsListFieldsMountEnum>} [fieldsMount] adds fields from their detail endpoint to the item list entries. Multiple comma separated values allowed.
         * @param {number} [filterFamilyId] only results with the unique family id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMountsList(language: GetMountsListLanguageEnum, game: GetMountsListGameEnum, filterFamilyName?: string, pageSize?: number, pageNumber?: number, fieldsMount?: Set<GetMountsListFieldsMountEnum>, filterFamilyId?: number, options?: RawAxiosRequestConfig): AxiosPromise<ListMounts> {
            return localVarFp.getMountsList(language, game, filterFamilyName, pageSize, pageNumber, fieldsMount, filterFamilyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Search in all names and descriptions of mounts with a query.
         * @summary Search Mounts
         * @param {GetMountsSearchLanguageEnum} language a valid language code
         * @param {GetMountsSearchGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {string} query case sensitive search query
         * @param {string} [filterFamilyName] only results with the translated family name
         * @param {number} [limit] maximum number of returned results
         * @param {number} [filterFamilyId] only results with the unique family id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMountsSearch(language: GetMountsSearchLanguageEnum, game: GetMountsSearchGameEnum, query: string, filterFamilyName?: string, limit?: number, filterFamilyId?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Mount>> {
            return localVarFp.getMountsSearch(language, game, query, filterFamilyName, limit, filterFamilyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific mount with id.
         * @summary Single Mounts
         * @param {GetMountsSingleLanguageEnum} language a valid language code
         * @param {number} ankamaId identifier
         * @param {GetMountsSingleGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMountsSingle(language: GetMountsSingleLanguageEnum, ankamaId: number, game: GetMountsSingleGameEnum, options?: RawAxiosRequestConfig): AxiosPromise<Mount> {
            return localVarFp.getMountsSingle(language, ankamaId, game, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MountsApi - object-oriented interface
 * @export
 * @class MountsApi
 * @extends {BaseAPI}
 */
export class MountsApi extends BaseAPI {
    /**
     * Retrieve all mounts with one request. This endpoint is just an alias for the a list with disabled pagination (page[size]=-1) and all fields[type] set.  If you want everything unfiltered, delete the other query parameters.  Be careful with testing or (god forbid) using /all in your browser, the returned json is huge and will slow down the browser!  Tip: set the HTTP Header \'Accept-Encoding: gzip\' for saving bandwidth. You will need to uncompress it on your end. Example with cURL: ``` curl -sH \'Accept-Encoding: gzip\' <api-endpoint> | gunzip - ```
     * @summary List All Mounts
     * @param {GetAllMountsListLanguageEnum} language a valid language code
     * @param {GetAllMountsListGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
     * @param {string} [filterFamilyName] only results with the translated family name
     * @param {GetAllMountsListAcceptEncodingEnum} [acceptEncoding] optional compression for saving bandwidth
     * @param {number} [filterFamilyId] only results with the unique family id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MountsApi
     */
    public getAllMountsList(language: GetAllMountsListLanguageEnum, game: GetAllMountsListGameEnum, filterFamilyName?: string, acceptEncoding?: GetAllMountsListAcceptEncodingEnum, filterFamilyId?: number, options?: RawAxiosRequestConfig) {
        return MountsApiFp(this.configuration).getAllMountsList(language, game, filterFamilyName, acceptEncoding, filterFamilyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of mounts.
     * @summary List Mounts
     * @param {GetMountsListLanguageEnum} language a valid language code
     * @param {GetMountsListGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
     * @param {string} [filterFamilyName] only results with the translated family name
     * @param {number} [pageSize] size of the results from the list. -1 disables pagination and gets all in one response.
     * @param {number} [pageNumber] page number based on the current page[size]. So you could get page 1 with 8 entrys and page 2 would have entries 8 to 16.
     * @param {Set<GetMountsListFieldsMountEnum>} [fieldsMount] adds fields from their detail endpoint to the item list entries. Multiple comma separated values allowed.
     * @param {number} [filterFamilyId] only results with the unique family id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MountsApi
     */
    public getMountsList(language: GetMountsListLanguageEnum, game: GetMountsListGameEnum, filterFamilyName?: string, pageSize?: number, pageNumber?: number, fieldsMount?: Set<GetMountsListFieldsMountEnum>, filterFamilyId?: number, options?: RawAxiosRequestConfig) {
        return MountsApiFp(this.configuration).getMountsList(language, game, filterFamilyName, pageSize, pageNumber, fieldsMount, filterFamilyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search in all names and descriptions of mounts with a query.
     * @summary Search Mounts
     * @param {GetMountsSearchLanguageEnum} language a valid language code
     * @param {GetMountsSearchGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
     * @param {string} query case sensitive search query
     * @param {string} [filterFamilyName] only results with the translated family name
     * @param {number} [limit] maximum number of returned results
     * @param {number} [filterFamilyId] only results with the unique family id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MountsApi
     */
    public getMountsSearch(language: GetMountsSearchLanguageEnum, game: GetMountsSearchGameEnum, query: string, filterFamilyName?: string, limit?: number, filterFamilyId?: number, options?: RawAxiosRequestConfig) {
        return MountsApiFp(this.configuration).getMountsSearch(language, game, query, filterFamilyName, limit, filterFamilyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific mount with id.
     * @summary Single Mounts
     * @param {GetMountsSingleLanguageEnum} language a valid language code
     * @param {number} ankamaId identifier
     * @param {GetMountsSingleGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MountsApi
     */
    public getMountsSingle(language: GetMountsSingleLanguageEnum, ankamaId: number, game: GetMountsSingleGameEnum, options?: RawAxiosRequestConfig) {
        return MountsApiFp(this.configuration).getMountsSingle(language, ankamaId, game, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetAllMountsListLanguageEnum = {
    En: 'en',
    Fr: 'fr',
    De: 'de',
    Es: 'es',
    Pt: 'pt'
} as const;
export type GetAllMountsListLanguageEnum = typeof GetAllMountsListLanguageEnum[keyof typeof GetAllMountsListLanguageEnum];
/**
 * @export
 */
export const GetAllMountsListGameEnum = {
    Dofus3: 'dofus3',
    Dofus3beta: 'dofus3beta'
} as const;
export type GetAllMountsListGameEnum = typeof GetAllMountsListGameEnum[keyof typeof GetAllMountsListGameEnum];
/**
 * @export
 */
export const GetAllMountsListAcceptEncodingEnum = {
    Gzip: 'gzip'
} as const;
export type GetAllMountsListAcceptEncodingEnum = typeof GetAllMountsListAcceptEncodingEnum[keyof typeof GetAllMountsListAcceptEncodingEnum];
/**
 * @export
 */
export const GetMountsListLanguageEnum = {
    En: 'en',
    Fr: 'fr',
    De: 'de',
    Es: 'es',
    Pt: 'pt'
} as const;
export type GetMountsListLanguageEnum = typeof GetMountsListLanguageEnum[keyof typeof GetMountsListLanguageEnum];
/**
 * @export
 */
export const GetMountsListGameEnum = {
    Dofus3: 'dofus3',
    Dofus3beta: 'dofus3beta'
} as const;
export type GetMountsListGameEnum = typeof GetMountsListGameEnum[keyof typeof GetMountsListGameEnum];
/**
 * @export
 */
export const GetMountsListFieldsMountEnum = {
    Effects: 'effects'
} as const;
export type GetMountsListFieldsMountEnum = typeof GetMountsListFieldsMountEnum[keyof typeof GetMountsListFieldsMountEnum];
/**
 * @export
 */
export const GetMountsSearchLanguageEnum = {
    En: 'en',
    Fr: 'fr',
    De: 'de',
    Es: 'es',
    Pt: 'pt'
} as const;
export type GetMountsSearchLanguageEnum = typeof GetMountsSearchLanguageEnum[keyof typeof GetMountsSearchLanguageEnum];
/**
 * @export
 */
export const GetMountsSearchGameEnum = {
    Dofus3: 'dofus3',
    Dofus3beta: 'dofus3beta'
} as const;
export type GetMountsSearchGameEnum = typeof GetMountsSearchGameEnum[keyof typeof GetMountsSearchGameEnum];
/**
 * @export
 */
export const GetMountsSingleLanguageEnum = {
    En: 'en',
    Fr: 'fr',
    De: 'de',
    Es: 'es',
    Pt: 'pt'
} as const;
export type GetMountsSingleLanguageEnum = typeof GetMountsSingleLanguageEnum[keyof typeof GetMountsSingleLanguageEnum];
/**
 * @export
 */
export const GetMountsSingleGameEnum = {
    Dofus3: 'dofus3',
    Dofus3beta: 'dofus3beta'
} as const;
export type GetMountsSingleGameEnum = typeof GetMountsSingleGameEnum[keyof typeof GetMountsSingleGameEnum];


/**
 * QuestItemsApi - axios parameter creator
 * @export
 */
export const QuestItemsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve all quest items with one request. This endpoint is just an alias for the a list with disabled pagination (page[size]=-1) and all fields[type] set.  If you want everything unfiltered, delete the other query parameters.  Be careful with testing or (god forbid) using /all in your browser, the returned json is huge and will slow down the browser!  Tip: set the HTTP Header \'Accept-Encoding: gzip\' for saving bandwidth. You will need to uncompress it on your end. Example with cURL: ``` curl -sH \'Accept-Encoding: gzip\' <api-endpoint> | gunzip - ```
         * @summary List All Quest Items
         * @param {GetAllItemsQuestListLanguageEnum} language a valid language code
         * @param {GetAllItemsQuestListGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {GetAllItemsQuestListSortLevelEnum} [sortLevel] sort the resulting list by level, default unsorted
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {GetAllItemsQuestListAcceptEncodingEnum} [acceptEncoding] optional compression for saving bandwidth
         * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllItemsQuestList: async (language: GetAllItemsQuestListLanguageEnum, game: GetAllItemsQuestListGameEnum, sortLevel?: GetAllItemsQuestListSortLevelEnum, filterMinLevel?: number, filterMaxLevel?: number, acceptEncoding?: GetAllItemsQuestListAcceptEncodingEnum, filterTypeNameId?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getAllItemsQuestList', 'language', language)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getAllItemsQuestList', 'game', game)
            const localVarPath = `/{game}/v1/{language}/items/quest/all`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sortLevel !== undefined) {
                localVarQueryParameter['sort[level]'] = sortLevel;
            }

            if (filterMinLevel !== undefined) {
                localVarQueryParameter['filter[min_level]'] = filterMinLevel;
            }

            if (filterMaxLevel !== undefined) {
                localVarQueryParameter['filter[max_level]'] = filterMaxLevel;
            }

            if (filterTypeNameId) {
                localVarQueryParameter['filter[type.name_id]'] = Array.from(filterTypeNameId).join(COLLECTION_FORMATS.csv);
            }


    
            if (acceptEncoding != null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific quest item with id.
         * @summary Single Quest Items
         * @param {GetItemQuestSingleLanguageEnum} language a valid language code
         * @param {number} ankamaId identifier
         * @param {GetItemQuestSingleGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemQuestSingle: async (language: GetItemQuestSingleLanguageEnum, ankamaId: number, game: GetItemQuestSingleGameEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getItemQuestSingle', 'language', language)
            // verify required parameter 'ankamaId' is not null or undefined
            assertParamExists('getItemQuestSingle', 'ankamaId', ankamaId)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getItemQuestSingle', 'game', game)
            const localVarPath = `/{game}/v1/{language}/items/quest/{ankama_id}`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"ankama_id"}}`, encodeURIComponent(String(ankamaId)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of quest items.
         * @summary List Quest Items
         * @param {GetItemsQuestListLanguageEnum} language a valid language code
         * @param {GetItemsQuestListGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {GetItemsQuestListSortLevelEnum} [sortLevel] sort the resulting list by level, default unsorted
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {number} [pageSize] size of the results from the list. -1 disables pagination and gets all in one response.
         * @param {number} [pageNumber] page number based on the current page[size]. So you could get page 1 with 8 entrys and page 2 would have entries 8 to 16.
         * @param {Set<GetItemsQuestListFieldsItemEnum>} [fieldsItem] adds fields from their detail endpoint to the item list entries. Multiple comma separated values allowed.
         * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsQuestList: async (language: GetItemsQuestListLanguageEnum, game: GetItemsQuestListGameEnum, sortLevel?: GetItemsQuestListSortLevelEnum, filterMinLevel?: number, filterMaxLevel?: number, pageSize?: number, pageNumber?: number, fieldsItem?: Set<GetItemsQuestListFieldsItemEnum>, filterTypeNameId?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getItemsQuestList', 'language', language)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getItemsQuestList', 'game', game)
            const localVarPath = `/{game}/v1/{language}/items/quest`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sortLevel !== undefined) {
                localVarQueryParameter['sort[level]'] = sortLevel;
            }

            if (filterMinLevel !== undefined) {
                localVarQueryParameter['filter[min_level]'] = filterMinLevel;
            }

            if (filterMaxLevel !== undefined) {
                localVarQueryParameter['filter[max_level]'] = filterMaxLevel;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page[size]'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['page[number]'] = pageNumber;
            }

            if (fieldsItem) {
                localVarQueryParameter['fields[item]'] = Array.from(fieldsItem).join(COLLECTION_FORMATS.csv);
            }

            if (filterTypeNameId) {
                localVarQueryParameter['filter[type.name_id]'] = Array.from(filterTypeNameId).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search in all names and descriptions of quest items with a query.
         * @summary Search Quest Items
         * @param {GetItemsQuestSearchLanguageEnum} language a valid language code
         * @param {GetItemsQuestSearchGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {string} query case sensitive search query
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {number} [limit] maximum number of returned results
         * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsQuestSearch: async (language: GetItemsQuestSearchLanguageEnum, game: GetItemsQuestSearchGameEnum, query: string, filterMinLevel?: number, filterMaxLevel?: number, limit?: number, filterTypeNameId?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getItemsQuestSearch', 'language', language)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getItemsQuestSearch', 'game', game)
            // verify required parameter 'query' is not null or undefined
            assertParamExists('getItemsQuestSearch', 'query', query)
            const localVarPath = `/{game}/v1/{language}/items/quest/search`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (filterMinLevel !== undefined) {
                localVarQueryParameter['filter[min_level]'] = filterMinLevel;
            }

            if (filterMaxLevel !== undefined) {
                localVarQueryParameter['filter[max_level]'] = filterMaxLevel;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (filterTypeNameId) {
                localVarQueryParameter['filter[type.name_id]'] = Array.from(filterTypeNameId).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuestItemsApi - functional programming interface
 * @export
 */
export const QuestItemsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QuestItemsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve all quest items with one request. This endpoint is just an alias for the a list with disabled pagination (page[size]=-1) and all fields[type] set.  If you want everything unfiltered, delete the other query parameters.  Be careful with testing or (god forbid) using /all in your browser, the returned json is huge and will slow down the browser!  Tip: set the HTTP Header \'Accept-Encoding: gzip\' for saving bandwidth. You will need to uncompress it on your end. Example with cURL: ``` curl -sH \'Accept-Encoding: gzip\' <api-endpoint> | gunzip - ```
         * @summary List All Quest Items
         * @param {GetAllItemsQuestListLanguageEnum} language a valid language code
         * @param {GetAllItemsQuestListGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {GetAllItemsQuestListSortLevelEnum} [sortLevel] sort the resulting list by level, default unsorted
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {GetAllItemsQuestListAcceptEncodingEnum} [acceptEncoding] optional compression for saving bandwidth
         * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllItemsQuestList(language: GetAllItemsQuestListLanguageEnum, game: GetAllItemsQuestListGameEnum, sortLevel?: GetAllItemsQuestListSortLevelEnum, filterMinLevel?: number, filterMaxLevel?: number, acceptEncoding?: GetAllItemsQuestListAcceptEncodingEnum, filterTypeNameId?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllItemsQuestList(language, game, sortLevel, filterMinLevel, filterMaxLevel, acceptEncoding, filterTypeNameId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuestItemsApi.getAllItemsQuestList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific quest item with id.
         * @summary Single Quest Items
         * @param {GetItemQuestSingleLanguageEnum} language a valid language code
         * @param {number} ankamaId identifier
         * @param {GetItemQuestSingleGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemQuestSingle(language: GetItemQuestSingleLanguageEnum, ankamaId: number, game: GetItemQuestSingleGameEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Resource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemQuestSingle(language, ankamaId, game, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuestItemsApi.getItemQuestSingle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of quest items.
         * @summary List Quest Items
         * @param {GetItemsQuestListLanguageEnum} language a valid language code
         * @param {GetItemsQuestListGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {GetItemsQuestListSortLevelEnum} [sortLevel] sort the resulting list by level, default unsorted
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {number} [pageSize] size of the results from the list. -1 disables pagination and gets all in one response.
         * @param {number} [pageNumber] page number based on the current page[size]. So you could get page 1 with 8 entrys and page 2 would have entries 8 to 16.
         * @param {Set<GetItemsQuestListFieldsItemEnum>} [fieldsItem] adds fields from their detail endpoint to the item list entries. Multiple comma separated values allowed.
         * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemsQuestList(language: GetItemsQuestListLanguageEnum, game: GetItemsQuestListGameEnum, sortLevel?: GetItemsQuestListSortLevelEnum, filterMinLevel?: number, filterMaxLevel?: number, pageSize?: number, pageNumber?: number, fieldsItem?: Set<GetItemsQuestListFieldsItemEnum>, filterTypeNameId?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemsQuestList(language, game, sortLevel, filterMinLevel, filterMaxLevel, pageSize, pageNumber, fieldsItem, filterTypeNameId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuestItemsApi.getItemsQuestList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search in all names and descriptions of quest items with a query.
         * @summary Search Quest Items
         * @param {GetItemsQuestSearchLanguageEnum} language a valid language code
         * @param {GetItemsQuestSearchGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {string} query case sensitive search query
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {number} [limit] maximum number of returned results
         * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemsQuestSearch(language: GetItemsQuestSearchLanguageEnum, game: GetItemsQuestSearchGameEnum, query: string, filterMinLevel?: number, filterMaxLevel?: number, limit?: number, filterTypeNameId?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemsQuestSearch(language, game, query, filterMinLevel, filterMaxLevel, limit, filterTypeNameId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuestItemsApi.getItemsQuestSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * QuestItemsApi - factory interface
 * @export
 */
export const QuestItemsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QuestItemsApiFp(configuration)
    return {
        /**
         * Retrieve all quest items with one request. This endpoint is just an alias for the a list with disabled pagination (page[size]=-1) and all fields[type] set.  If you want everything unfiltered, delete the other query parameters.  Be careful with testing or (god forbid) using /all in your browser, the returned json is huge and will slow down the browser!  Tip: set the HTTP Header \'Accept-Encoding: gzip\' for saving bandwidth. You will need to uncompress it on your end. Example with cURL: ``` curl -sH \'Accept-Encoding: gzip\' <api-endpoint> | gunzip - ```
         * @summary List All Quest Items
         * @param {GetAllItemsQuestListLanguageEnum} language a valid language code
         * @param {GetAllItemsQuestListGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {GetAllItemsQuestListSortLevelEnum} [sortLevel] sort the resulting list by level, default unsorted
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {GetAllItemsQuestListAcceptEncodingEnum} [acceptEncoding] optional compression for saving bandwidth
         * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllItemsQuestList(language: GetAllItemsQuestListLanguageEnum, game: GetAllItemsQuestListGameEnum, sortLevel?: GetAllItemsQuestListSortLevelEnum, filterMinLevel?: number, filterMaxLevel?: number, acceptEncoding?: GetAllItemsQuestListAcceptEncodingEnum, filterTypeNameId?: Set<string>, options?: RawAxiosRequestConfig): AxiosPromise<ListItems> {
            return localVarFp.getAllItemsQuestList(language, game, sortLevel, filterMinLevel, filterMaxLevel, acceptEncoding, filterTypeNameId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific quest item with id.
         * @summary Single Quest Items
         * @param {GetItemQuestSingleLanguageEnum} language a valid language code
         * @param {number} ankamaId identifier
         * @param {GetItemQuestSingleGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemQuestSingle(language: GetItemQuestSingleLanguageEnum, ankamaId: number, game: GetItemQuestSingleGameEnum, options?: RawAxiosRequestConfig): AxiosPromise<Resource> {
            return localVarFp.getItemQuestSingle(language, ankamaId, game, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of quest items.
         * @summary List Quest Items
         * @param {GetItemsQuestListLanguageEnum} language a valid language code
         * @param {GetItemsQuestListGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {GetItemsQuestListSortLevelEnum} [sortLevel] sort the resulting list by level, default unsorted
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {number} [pageSize] size of the results from the list. -1 disables pagination and gets all in one response.
         * @param {number} [pageNumber] page number based on the current page[size]. So you could get page 1 with 8 entrys and page 2 would have entries 8 to 16.
         * @param {Set<GetItemsQuestListFieldsItemEnum>} [fieldsItem] adds fields from their detail endpoint to the item list entries. Multiple comma separated values allowed.
         * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsQuestList(language: GetItemsQuestListLanguageEnum, game: GetItemsQuestListGameEnum, sortLevel?: GetItemsQuestListSortLevelEnum, filterMinLevel?: number, filterMaxLevel?: number, pageSize?: number, pageNumber?: number, fieldsItem?: Set<GetItemsQuestListFieldsItemEnum>, filterTypeNameId?: Set<string>, options?: RawAxiosRequestConfig): AxiosPromise<ListItems> {
            return localVarFp.getItemsQuestList(language, game, sortLevel, filterMinLevel, filterMaxLevel, pageSize, pageNumber, fieldsItem, filterTypeNameId, options).then((request) => request(axios, basePath));
        },
        /**
         * Search in all names and descriptions of quest items with a query.
         * @summary Search Quest Items
         * @param {GetItemsQuestSearchLanguageEnum} language a valid language code
         * @param {GetItemsQuestSearchGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {string} query case sensitive search query
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {number} [limit] maximum number of returned results
         * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsQuestSearch(language: GetItemsQuestSearchLanguageEnum, game: GetItemsQuestSearchGameEnum, query: string, filterMinLevel?: number, filterMaxLevel?: number, limit?: number, filterTypeNameId?: Set<string>, options?: RawAxiosRequestConfig): AxiosPromise<Array<ListItem>> {
            return localVarFp.getItemsQuestSearch(language, game, query, filterMinLevel, filterMaxLevel, limit, filterTypeNameId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QuestItemsApi - object-oriented interface
 * @export
 * @class QuestItemsApi
 * @extends {BaseAPI}
 */
export class QuestItemsApi extends BaseAPI {
    /**
     * Retrieve all quest items with one request. This endpoint is just an alias for the a list with disabled pagination (page[size]=-1) and all fields[type] set.  If you want everything unfiltered, delete the other query parameters.  Be careful with testing or (god forbid) using /all in your browser, the returned json is huge and will slow down the browser!  Tip: set the HTTP Header \'Accept-Encoding: gzip\' for saving bandwidth. You will need to uncompress it on your end. Example with cURL: ``` curl -sH \'Accept-Encoding: gzip\' <api-endpoint> | gunzip - ```
     * @summary List All Quest Items
     * @param {GetAllItemsQuestListLanguageEnum} language a valid language code
     * @param {GetAllItemsQuestListGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
     * @param {GetAllItemsQuestListSortLevelEnum} [sortLevel] sort the resulting list by level, default unsorted
     * @param {number} [filterMinLevel] only results which level is equal or above this value
     * @param {number} [filterMaxLevel] only results which level is equal or below this value
     * @param {GetAllItemsQuestListAcceptEncodingEnum} [acceptEncoding] optional compression for saving bandwidth
     * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestItemsApi
     */
    public getAllItemsQuestList(language: GetAllItemsQuestListLanguageEnum, game: GetAllItemsQuestListGameEnum, sortLevel?: GetAllItemsQuestListSortLevelEnum, filterMinLevel?: number, filterMaxLevel?: number, acceptEncoding?: GetAllItemsQuestListAcceptEncodingEnum, filterTypeNameId?: Set<string>, options?: RawAxiosRequestConfig) {
        return QuestItemsApiFp(this.configuration).getAllItemsQuestList(language, game, sortLevel, filterMinLevel, filterMaxLevel, acceptEncoding, filterTypeNameId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific quest item with id.
     * @summary Single Quest Items
     * @param {GetItemQuestSingleLanguageEnum} language a valid language code
     * @param {number} ankamaId identifier
     * @param {GetItemQuestSingleGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestItemsApi
     */
    public getItemQuestSingle(language: GetItemQuestSingleLanguageEnum, ankamaId: number, game: GetItemQuestSingleGameEnum, options?: RawAxiosRequestConfig) {
        return QuestItemsApiFp(this.configuration).getItemQuestSingle(language, ankamaId, game, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of quest items.
     * @summary List Quest Items
     * @param {GetItemsQuestListLanguageEnum} language a valid language code
     * @param {GetItemsQuestListGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
     * @param {GetItemsQuestListSortLevelEnum} [sortLevel] sort the resulting list by level, default unsorted
     * @param {number} [filterMinLevel] only results which level is equal or above this value
     * @param {number} [filterMaxLevel] only results which level is equal or below this value
     * @param {number} [pageSize] size of the results from the list. -1 disables pagination and gets all in one response.
     * @param {number} [pageNumber] page number based on the current page[size]. So you could get page 1 with 8 entrys and page 2 would have entries 8 to 16.
     * @param {Set<GetItemsQuestListFieldsItemEnum>} [fieldsItem] adds fields from their detail endpoint to the item list entries. Multiple comma separated values allowed.
     * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestItemsApi
     */
    public getItemsQuestList(language: GetItemsQuestListLanguageEnum, game: GetItemsQuestListGameEnum, sortLevel?: GetItemsQuestListSortLevelEnum, filterMinLevel?: number, filterMaxLevel?: number, pageSize?: number, pageNumber?: number, fieldsItem?: Set<GetItemsQuestListFieldsItemEnum>, filterTypeNameId?: Set<string>, options?: RawAxiosRequestConfig) {
        return QuestItemsApiFp(this.configuration).getItemsQuestList(language, game, sortLevel, filterMinLevel, filterMaxLevel, pageSize, pageNumber, fieldsItem, filterTypeNameId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search in all names and descriptions of quest items with a query.
     * @summary Search Quest Items
     * @param {GetItemsQuestSearchLanguageEnum} language a valid language code
     * @param {GetItemsQuestSearchGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
     * @param {string} query case sensitive search query
     * @param {number} [filterMinLevel] only results which level is equal or above this value
     * @param {number} [filterMaxLevel] only results which level is equal or below this value
     * @param {number} [limit] maximum number of returned results
     * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestItemsApi
     */
    public getItemsQuestSearch(language: GetItemsQuestSearchLanguageEnum, game: GetItemsQuestSearchGameEnum, query: string, filterMinLevel?: number, filterMaxLevel?: number, limit?: number, filterTypeNameId?: Set<string>, options?: RawAxiosRequestConfig) {
        return QuestItemsApiFp(this.configuration).getItemsQuestSearch(language, game, query, filterMinLevel, filterMaxLevel, limit, filterTypeNameId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetAllItemsQuestListLanguageEnum = {
    En: 'en',
    Fr: 'fr',
    De: 'de',
    Es: 'es',
    Pt: 'pt'
} as const;
export type GetAllItemsQuestListLanguageEnum = typeof GetAllItemsQuestListLanguageEnum[keyof typeof GetAllItemsQuestListLanguageEnum];
/**
 * @export
 */
export const GetAllItemsQuestListGameEnum = {
    Dofus3: 'dofus3',
    Dofus3beta: 'dofus3beta'
} as const;
export type GetAllItemsQuestListGameEnum = typeof GetAllItemsQuestListGameEnum[keyof typeof GetAllItemsQuestListGameEnum];
/**
 * @export
 */
export const GetAllItemsQuestListSortLevelEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type GetAllItemsQuestListSortLevelEnum = typeof GetAllItemsQuestListSortLevelEnum[keyof typeof GetAllItemsQuestListSortLevelEnum];
/**
 * @export
 */
export const GetAllItemsQuestListAcceptEncodingEnum = {
    Gzip: 'gzip'
} as const;
export type GetAllItemsQuestListAcceptEncodingEnum = typeof GetAllItemsQuestListAcceptEncodingEnum[keyof typeof GetAllItemsQuestListAcceptEncodingEnum];
/**
 * @export
 */
export const GetItemQuestSingleLanguageEnum = {
    En: 'en',
    Fr: 'fr',
    De: 'de',
    Es: 'es',
    Pt: 'pt'
} as const;
export type GetItemQuestSingleLanguageEnum = typeof GetItemQuestSingleLanguageEnum[keyof typeof GetItemQuestSingleLanguageEnum];
/**
 * @export
 */
export const GetItemQuestSingleGameEnum = {
    Dofus3: 'dofus3',
    Dofus3beta: 'dofus3beta'
} as const;
export type GetItemQuestSingleGameEnum = typeof GetItemQuestSingleGameEnum[keyof typeof GetItemQuestSingleGameEnum];
/**
 * @export
 */
export const GetItemsQuestListLanguageEnum = {
    En: 'en',
    Fr: 'fr',
    De: 'de',
    Es: 'es',
    Pt: 'pt'
} as const;
export type GetItemsQuestListLanguageEnum = typeof GetItemsQuestListLanguageEnum[keyof typeof GetItemsQuestListLanguageEnum];
/**
 * @export
 */
export const GetItemsQuestListGameEnum = {
    Dofus3: 'dofus3',
    Dofus3beta: 'dofus3beta'
} as const;
export type GetItemsQuestListGameEnum = typeof GetItemsQuestListGameEnum[keyof typeof GetItemsQuestListGameEnum];
/**
 * @export
 */
export const GetItemsQuestListSortLevelEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type GetItemsQuestListSortLevelEnum = typeof GetItemsQuestListSortLevelEnum[keyof typeof GetItemsQuestListSortLevelEnum];
/**
 * @export
 */
export const GetItemsQuestListFieldsItemEnum = {
    Recipe: 'recipe',
    Description: 'description',
    Conditions: 'conditions',
    Effects: 'effects'
} as const;
export type GetItemsQuestListFieldsItemEnum = typeof GetItemsQuestListFieldsItemEnum[keyof typeof GetItemsQuestListFieldsItemEnum];
/**
 * @export
 */
export const GetItemsQuestSearchLanguageEnum = {
    En: 'en',
    Fr: 'fr',
    De: 'de',
    Es: 'es',
    Pt: 'pt'
} as const;
export type GetItemsQuestSearchLanguageEnum = typeof GetItemsQuestSearchLanguageEnum[keyof typeof GetItemsQuestSearchLanguageEnum];
/**
 * @export
 */
export const GetItemsQuestSearchGameEnum = {
    Dofus3: 'dofus3',
    Dofus3beta: 'dofus3beta'
} as const;
export type GetItemsQuestSearchGameEnum = typeof GetItemsQuestSearchGameEnum[keyof typeof GetItemsQuestSearchGameEnum];


/**
 * ResourcesApi - axios parameter creator
 * @export
 */
export const ResourcesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve all resource items with one request. This endpoint is just an alias for the a list with disabled pagination (page[size]=-1) and all fields[type] set.  If you want everything unfiltered, delete the other query parameters.  Be careful with testing or (god forbid) using /all in your browser, the returned json is huge and will slow down the browser!  Tip: set the HTTP Header \'Accept-Encoding: gzip\' for saving bandwidth. You will need to uncompress it on your end. Example with cURL: ``` curl -sH \'Accept-Encoding: gzip\' <api-endpoint> | gunzip - ```
         * @summary List All Resources
         * @param {GetAllItemsResourcesListLanguageEnum} language a valid language code
         * @param {GetAllItemsResourcesListGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {GetAllItemsResourcesListSortLevelEnum} [sortLevel] sort the resulting list by level, default unsorted
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {GetAllItemsResourcesListAcceptEncodingEnum} [acceptEncoding] optional compression for saving bandwidth
         * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllItemsResourcesList: async (language: GetAllItemsResourcesListLanguageEnum, game: GetAllItemsResourcesListGameEnum, sortLevel?: GetAllItemsResourcesListSortLevelEnum, filterMinLevel?: number, filterMaxLevel?: number, acceptEncoding?: GetAllItemsResourcesListAcceptEncodingEnum, filterTypeNameId?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getAllItemsResourcesList', 'language', language)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getAllItemsResourcesList', 'game', game)
            const localVarPath = `/{game}/v1/{language}/items/resources/all`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sortLevel !== undefined) {
                localVarQueryParameter['sort[level]'] = sortLevel;
            }

            if (filterMinLevel !== undefined) {
                localVarQueryParameter['filter[min_level]'] = filterMinLevel;
            }

            if (filterMaxLevel !== undefined) {
                localVarQueryParameter['filter[max_level]'] = filterMaxLevel;
            }

            if (filterTypeNameId) {
                localVarQueryParameter['filter[type.name_id]'] = Array.from(filterTypeNameId).join(COLLECTION_FORMATS.csv);
            }


    
            if (acceptEncoding != null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search in all names and descriptions of resource items with a query.
         * @summary Search Resources
         * @param {GetItemsResourceSearchLanguageEnum} language a valid language code
         * @param {GetItemsResourceSearchGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {string} query case sensitive search query
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {number} [limit] maximum number of returned results
         * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsResourceSearch: async (language: GetItemsResourceSearchLanguageEnum, game: GetItemsResourceSearchGameEnum, query: string, filterMinLevel?: number, filterMaxLevel?: number, limit?: number, filterTypeNameId?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getItemsResourceSearch', 'language', language)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getItemsResourceSearch', 'game', game)
            // verify required parameter 'query' is not null or undefined
            assertParamExists('getItemsResourceSearch', 'query', query)
            const localVarPath = `/{game}/v1/{language}/items/resources/search`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (filterMinLevel !== undefined) {
                localVarQueryParameter['filter[min_level]'] = filterMinLevel;
            }

            if (filterMaxLevel !== undefined) {
                localVarQueryParameter['filter[max_level]'] = filterMaxLevel;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (filterTypeNameId) {
                localVarQueryParameter['filter[type.name_id]'] = Array.from(filterTypeNameId).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of resource items.
         * @summary List Resources
         * @param {GetItemsResourcesListLanguageEnum} language a valid language code
         * @param {GetItemsResourcesListGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {GetItemsResourcesListSortLevelEnum} [sortLevel] sort the resulting list by level, default unsorted
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {number} [pageSize] size of the results from the list. -1 disables pagination and gets all in one response.
         * @param {number} [pageNumber] page number based on the current page[size]. So you could get page 1 with 8 entrys and page 2 would have entries 8 to 16.
         * @param {Set<GetItemsResourcesListFieldsItemEnum>} [fieldsItem] adds fields from their detail endpoint to the item list entries. Multiple comma separated values allowed.
         * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsResourcesList: async (language: GetItemsResourcesListLanguageEnum, game: GetItemsResourcesListGameEnum, sortLevel?: GetItemsResourcesListSortLevelEnum, filterMinLevel?: number, filterMaxLevel?: number, pageSize?: number, pageNumber?: number, fieldsItem?: Set<GetItemsResourcesListFieldsItemEnum>, filterTypeNameId?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getItemsResourcesList', 'language', language)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getItemsResourcesList', 'game', game)
            const localVarPath = `/{game}/v1/{language}/items/resources`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sortLevel !== undefined) {
                localVarQueryParameter['sort[level]'] = sortLevel;
            }

            if (filterMinLevel !== undefined) {
                localVarQueryParameter['filter[min_level]'] = filterMinLevel;
            }

            if (filterMaxLevel !== undefined) {
                localVarQueryParameter['filter[max_level]'] = filterMaxLevel;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page[size]'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['page[number]'] = pageNumber;
            }

            if (fieldsItem) {
                localVarQueryParameter['fields[item]'] = Array.from(fieldsItem).join(COLLECTION_FORMATS.csv);
            }

            if (filterTypeNameId) {
                localVarQueryParameter['filter[type.name_id]'] = Array.from(filterTypeNameId).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific resource item with id.
         * @summary Single Resources
         * @param {GetItemsResourcesSingleLanguageEnum} language a valid language code
         * @param {number} ankamaId identifier
         * @param {GetItemsResourcesSingleGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsResourcesSingle: async (language: GetItemsResourcesSingleLanguageEnum, ankamaId: number, game: GetItemsResourcesSingleGameEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getItemsResourcesSingle', 'language', language)
            // verify required parameter 'ankamaId' is not null or undefined
            assertParamExists('getItemsResourcesSingle', 'ankamaId', ankamaId)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getItemsResourcesSingle', 'game', game)
            const localVarPath = `/{game}/v1/{language}/items/resources/{ankama_id}`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"ankama_id"}}`, encodeURIComponent(String(ankamaId)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResourcesApi - functional programming interface
 * @export
 */
export const ResourcesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResourcesApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve all resource items with one request. This endpoint is just an alias for the a list with disabled pagination (page[size]=-1) and all fields[type] set.  If you want everything unfiltered, delete the other query parameters.  Be careful with testing or (god forbid) using /all in your browser, the returned json is huge and will slow down the browser!  Tip: set the HTTP Header \'Accept-Encoding: gzip\' for saving bandwidth. You will need to uncompress it on your end. Example with cURL: ``` curl -sH \'Accept-Encoding: gzip\' <api-endpoint> | gunzip - ```
         * @summary List All Resources
         * @param {GetAllItemsResourcesListLanguageEnum} language a valid language code
         * @param {GetAllItemsResourcesListGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {GetAllItemsResourcesListSortLevelEnum} [sortLevel] sort the resulting list by level, default unsorted
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {GetAllItemsResourcesListAcceptEncodingEnum} [acceptEncoding] optional compression for saving bandwidth
         * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllItemsResourcesList(language: GetAllItemsResourcesListLanguageEnum, game: GetAllItemsResourcesListGameEnum, sortLevel?: GetAllItemsResourcesListSortLevelEnum, filterMinLevel?: number, filterMaxLevel?: number, acceptEncoding?: GetAllItemsResourcesListAcceptEncodingEnum, filterTypeNameId?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllItemsResourcesList(language, game, sortLevel, filterMinLevel, filterMaxLevel, acceptEncoding, filterTypeNameId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.getAllItemsResourcesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search in all names and descriptions of resource items with a query.
         * @summary Search Resources
         * @param {GetItemsResourceSearchLanguageEnum} language a valid language code
         * @param {GetItemsResourceSearchGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {string} query case sensitive search query
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {number} [limit] maximum number of returned results
         * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemsResourceSearch(language: GetItemsResourceSearchLanguageEnum, game: GetItemsResourceSearchGameEnum, query: string, filterMinLevel?: number, filterMaxLevel?: number, limit?: number, filterTypeNameId?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemsResourceSearch(language, game, query, filterMinLevel, filterMaxLevel, limit, filterTypeNameId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.getItemsResourceSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of resource items.
         * @summary List Resources
         * @param {GetItemsResourcesListLanguageEnum} language a valid language code
         * @param {GetItemsResourcesListGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {GetItemsResourcesListSortLevelEnum} [sortLevel] sort the resulting list by level, default unsorted
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {number} [pageSize] size of the results from the list. -1 disables pagination and gets all in one response.
         * @param {number} [pageNumber] page number based on the current page[size]. So you could get page 1 with 8 entrys and page 2 would have entries 8 to 16.
         * @param {Set<GetItemsResourcesListFieldsItemEnum>} [fieldsItem] adds fields from their detail endpoint to the item list entries. Multiple comma separated values allowed.
         * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemsResourcesList(language: GetItemsResourcesListLanguageEnum, game: GetItemsResourcesListGameEnum, sortLevel?: GetItemsResourcesListSortLevelEnum, filterMinLevel?: number, filterMaxLevel?: number, pageSize?: number, pageNumber?: number, fieldsItem?: Set<GetItemsResourcesListFieldsItemEnum>, filterTypeNameId?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemsResourcesList(language, game, sortLevel, filterMinLevel, filterMaxLevel, pageSize, pageNumber, fieldsItem, filterTypeNameId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.getItemsResourcesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific resource item with id.
         * @summary Single Resources
         * @param {GetItemsResourcesSingleLanguageEnum} language a valid language code
         * @param {number} ankamaId identifier
         * @param {GetItemsResourcesSingleGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemsResourcesSingle(language: GetItemsResourcesSingleLanguageEnum, ankamaId: number, game: GetItemsResourcesSingleGameEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Resource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemsResourcesSingle(language, ankamaId, game, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.getItemsResourcesSingle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ResourcesApi - factory interface
 * @export
 */
export const ResourcesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResourcesApiFp(configuration)
    return {
        /**
         * Retrieve all resource items with one request. This endpoint is just an alias for the a list with disabled pagination (page[size]=-1) and all fields[type] set.  If you want everything unfiltered, delete the other query parameters.  Be careful with testing or (god forbid) using /all in your browser, the returned json is huge and will slow down the browser!  Tip: set the HTTP Header \'Accept-Encoding: gzip\' for saving bandwidth. You will need to uncompress it on your end. Example with cURL: ``` curl -sH \'Accept-Encoding: gzip\' <api-endpoint> | gunzip - ```
         * @summary List All Resources
         * @param {GetAllItemsResourcesListLanguageEnum} language a valid language code
         * @param {GetAllItemsResourcesListGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {GetAllItemsResourcesListSortLevelEnum} [sortLevel] sort the resulting list by level, default unsorted
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {GetAllItemsResourcesListAcceptEncodingEnum} [acceptEncoding] optional compression for saving bandwidth
         * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllItemsResourcesList(language: GetAllItemsResourcesListLanguageEnum, game: GetAllItemsResourcesListGameEnum, sortLevel?: GetAllItemsResourcesListSortLevelEnum, filterMinLevel?: number, filterMaxLevel?: number, acceptEncoding?: GetAllItemsResourcesListAcceptEncodingEnum, filterTypeNameId?: Set<string>, options?: RawAxiosRequestConfig): AxiosPromise<ListItems> {
            return localVarFp.getAllItemsResourcesList(language, game, sortLevel, filterMinLevel, filterMaxLevel, acceptEncoding, filterTypeNameId, options).then((request) => request(axios, basePath));
        },
        /**
         * Search in all names and descriptions of resource items with a query.
         * @summary Search Resources
         * @param {GetItemsResourceSearchLanguageEnum} language a valid language code
         * @param {GetItemsResourceSearchGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {string} query case sensitive search query
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {number} [limit] maximum number of returned results
         * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsResourceSearch(language: GetItemsResourceSearchLanguageEnum, game: GetItemsResourceSearchGameEnum, query: string, filterMinLevel?: number, filterMaxLevel?: number, limit?: number, filterTypeNameId?: Set<string>, options?: RawAxiosRequestConfig): AxiosPromise<Array<ListItem>> {
            return localVarFp.getItemsResourceSearch(language, game, query, filterMinLevel, filterMaxLevel, limit, filterTypeNameId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of resource items.
         * @summary List Resources
         * @param {GetItemsResourcesListLanguageEnum} language a valid language code
         * @param {GetItemsResourcesListGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {GetItemsResourcesListSortLevelEnum} [sortLevel] sort the resulting list by level, default unsorted
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {number} [pageSize] size of the results from the list. -1 disables pagination and gets all in one response.
         * @param {number} [pageNumber] page number based on the current page[size]. So you could get page 1 with 8 entrys and page 2 would have entries 8 to 16.
         * @param {Set<GetItemsResourcesListFieldsItemEnum>} [fieldsItem] adds fields from their detail endpoint to the item list entries. Multiple comma separated values allowed.
         * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsResourcesList(language: GetItemsResourcesListLanguageEnum, game: GetItemsResourcesListGameEnum, sortLevel?: GetItemsResourcesListSortLevelEnum, filterMinLevel?: number, filterMaxLevel?: number, pageSize?: number, pageNumber?: number, fieldsItem?: Set<GetItemsResourcesListFieldsItemEnum>, filterTypeNameId?: Set<string>, options?: RawAxiosRequestConfig): AxiosPromise<ListItems> {
            return localVarFp.getItemsResourcesList(language, game, sortLevel, filterMinLevel, filterMaxLevel, pageSize, pageNumber, fieldsItem, filterTypeNameId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific resource item with id.
         * @summary Single Resources
         * @param {GetItemsResourcesSingleLanguageEnum} language a valid language code
         * @param {number} ankamaId identifier
         * @param {GetItemsResourcesSingleGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsResourcesSingle(language: GetItemsResourcesSingleLanguageEnum, ankamaId: number, game: GetItemsResourcesSingleGameEnum, options?: RawAxiosRequestConfig): AxiosPromise<Resource> {
            return localVarFp.getItemsResourcesSingle(language, ankamaId, game, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResourcesApi - object-oriented interface
 * @export
 * @class ResourcesApi
 * @extends {BaseAPI}
 */
export class ResourcesApi extends BaseAPI {
    /**
     * Retrieve all resource items with one request. This endpoint is just an alias for the a list with disabled pagination (page[size]=-1) and all fields[type] set.  If you want everything unfiltered, delete the other query parameters.  Be careful with testing or (god forbid) using /all in your browser, the returned json is huge and will slow down the browser!  Tip: set the HTTP Header \'Accept-Encoding: gzip\' for saving bandwidth. You will need to uncompress it on your end. Example with cURL: ``` curl -sH \'Accept-Encoding: gzip\' <api-endpoint> | gunzip - ```
     * @summary List All Resources
     * @param {GetAllItemsResourcesListLanguageEnum} language a valid language code
     * @param {GetAllItemsResourcesListGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
     * @param {GetAllItemsResourcesListSortLevelEnum} [sortLevel] sort the resulting list by level, default unsorted
     * @param {number} [filterMinLevel] only results which level is equal or above this value
     * @param {number} [filterMaxLevel] only results which level is equal or below this value
     * @param {GetAllItemsResourcesListAcceptEncodingEnum} [acceptEncoding] optional compression for saving bandwidth
     * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourcesApi
     */
    public getAllItemsResourcesList(language: GetAllItemsResourcesListLanguageEnum, game: GetAllItemsResourcesListGameEnum, sortLevel?: GetAllItemsResourcesListSortLevelEnum, filterMinLevel?: number, filterMaxLevel?: number, acceptEncoding?: GetAllItemsResourcesListAcceptEncodingEnum, filterTypeNameId?: Set<string>, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).getAllItemsResourcesList(language, game, sortLevel, filterMinLevel, filterMaxLevel, acceptEncoding, filterTypeNameId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search in all names and descriptions of resource items with a query.
     * @summary Search Resources
     * @param {GetItemsResourceSearchLanguageEnum} language a valid language code
     * @param {GetItemsResourceSearchGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
     * @param {string} query case sensitive search query
     * @param {number} [filterMinLevel] only results which level is equal or above this value
     * @param {number} [filterMaxLevel] only results which level is equal or below this value
     * @param {number} [limit] maximum number of returned results
     * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourcesApi
     */
    public getItemsResourceSearch(language: GetItemsResourceSearchLanguageEnum, game: GetItemsResourceSearchGameEnum, query: string, filterMinLevel?: number, filterMaxLevel?: number, limit?: number, filterTypeNameId?: Set<string>, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).getItemsResourceSearch(language, game, query, filterMinLevel, filterMaxLevel, limit, filterTypeNameId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of resource items.
     * @summary List Resources
     * @param {GetItemsResourcesListLanguageEnum} language a valid language code
     * @param {GetItemsResourcesListGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
     * @param {GetItemsResourcesListSortLevelEnum} [sortLevel] sort the resulting list by level, default unsorted
     * @param {number} [filterMinLevel] only results which level is equal or above this value
     * @param {number} [filterMaxLevel] only results which level is equal or below this value
     * @param {number} [pageSize] size of the results from the list. -1 disables pagination and gets all in one response.
     * @param {number} [pageNumber] page number based on the current page[size]. So you could get page 1 with 8 entrys and page 2 would have entries 8 to 16.
     * @param {Set<GetItemsResourcesListFieldsItemEnum>} [fieldsItem] adds fields from their detail endpoint to the item list entries. Multiple comma separated values allowed.
     * @param {Set<string>} [filterTypeNameId] multi-filter results with the english type name. Add with \&quot;wood\&quot; or \&quot;+wood\&quot; and exclude with \&quot;-wood\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourcesApi
     */
    public getItemsResourcesList(language: GetItemsResourcesListLanguageEnum, game: GetItemsResourcesListGameEnum, sortLevel?: GetItemsResourcesListSortLevelEnum, filterMinLevel?: number, filterMaxLevel?: number, pageSize?: number, pageNumber?: number, fieldsItem?: Set<GetItemsResourcesListFieldsItemEnum>, filterTypeNameId?: Set<string>, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).getItemsResourcesList(language, game, sortLevel, filterMinLevel, filterMaxLevel, pageSize, pageNumber, fieldsItem, filterTypeNameId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific resource item with id.
     * @summary Single Resources
     * @param {GetItemsResourcesSingleLanguageEnum} language a valid language code
     * @param {number} ankamaId identifier
     * @param {GetItemsResourcesSingleGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourcesApi
     */
    public getItemsResourcesSingle(language: GetItemsResourcesSingleLanguageEnum, ankamaId: number, game: GetItemsResourcesSingleGameEnum, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).getItemsResourcesSingle(language, ankamaId, game, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetAllItemsResourcesListLanguageEnum = {
    En: 'en',
    Fr: 'fr',
    De: 'de',
    Es: 'es',
    Pt: 'pt'
} as const;
export type GetAllItemsResourcesListLanguageEnum = typeof GetAllItemsResourcesListLanguageEnum[keyof typeof GetAllItemsResourcesListLanguageEnum];
/**
 * @export
 */
export const GetAllItemsResourcesListGameEnum = {
    Dofus3: 'dofus3',
    Dofus3beta: 'dofus3beta'
} as const;
export type GetAllItemsResourcesListGameEnum = typeof GetAllItemsResourcesListGameEnum[keyof typeof GetAllItemsResourcesListGameEnum];
/**
 * @export
 */
export const GetAllItemsResourcesListSortLevelEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type GetAllItemsResourcesListSortLevelEnum = typeof GetAllItemsResourcesListSortLevelEnum[keyof typeof GetAllItemsResourcesListSortLevelEnum];
/**
 * @export
 */
export const GetAllItemsResourcesListAcceptEncodingEnum = {
    Gzip: 'gzip'
} as const;
export type GetAllItemsResourcesListAcceptEncodingEnum = typeof GetAllItemsResourcesListAcceptEncodingEnum[keyof typeof GetAllItemsResourcesListAcceptEncodingEnum];
/**
 * @export
 */
export const GetItemsResourceSearchLanguageEnum = {
    En: 'en',
    Fr: 'fr',
    De: 'de',
    Es: 'es',
    Pt: 'pt'
} as const;
export type GetItemsResourceSearchLanguageEnum = typeof GetItemsResourceSearchLanguageEnum[keyof typeof GetItemsResourceSearchLanguageEnum];
/**
 * @export
 */
export const GetItemsResourceSearchGameEnum = {
    Dofus3: 'dofus3',
    Dofus3beta: 'dofus3beta'
} as const;
export type GetItemsResourceSearchGameEnum = typeof GetItemsResourceSearchGameEnum[keyof typeof GetItemsResourceSearchGameEnum];
/**
 * @export
 */
export const GetItemsResourcesListLanguageEnum = {
    En: 'en',
    Fr: 'fr',
    De: 'de',
    Es: 'es',
    Pt: 'pt'
} as const;
export type GetItemsResourcesListLanguageEnum = typeof GetItemsResourcesListLanguageEnum[keyof typeof GetItemsResourcesListLanguageEnum];
/**
 * @export
 */
export const GetItemsResourcesListGameEnum = {
    Dofus3: 'dofus3',
    Dofus3beta: 'dofus3beta'
} as const;
export type GetItemsResourcesListGameEnum = typeof GetItemsResourcesListGameEnum[keyof typeof GetItemsResourcesListGameEnum];
/**
 * @export
 */
export const GetItemsResourcesListSortLevelEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type GetItemsResourcesListSortLevelEnum = typeof GetItemsResourcesListSortLevelEnum[keyof typeof GetItemsResourcesListSortLevelEnum];
/**
 * @export
 */
export const GetItemsResourcesListFieldsItemEnum = {
    Recipe: 'recipe',
    Description: 'description',
    Conditions: 'conditions',
    Effects: 'effects'
} as const;
export type GetItemsResourcesListFieldsItemEnum = typeof GetItemsResourcesListFieldsItemEnum[keyof typeof GetItemsResourcesListFieldsItemEnum];
/**
 * @export
 */
export const GetItemsResourcesSingleLanguageEnum = {
    En: 'en',
    Fr: 'fr',
    De: 'de',
    Es: 'es',
    Pt: 'pt'
} as const;
export type GetItemsResourcesSingleLanguageEnum = typeof GetItemsResourcesSingleLanguageEnum[keyof typeof GetItemsResourcesSingleLanguageEnum];
/**
 * @export
 */
export const GetItemsResourcesSingleGameEnum = {
    Dofus3: 'dofus3',
    Dofus3beta: 'dofus3beta'
} as const;
export type GetItemsResourcesSingleGameEnum = typeof GetItemsResourcesSingleGameEnum[keyof typeof GetItemsResourcesSingleGameEnum];


/**
 * SetsApi - axios parameter creator
 * @export
 */
export const SetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve all sets with one request. This endpoint is just an alias for the a list with disabled pagination (page[size]=-1) and all fields[type] set.  If you want everything unfiltered, delete the other query parameters.  Be careful with testing or (god forbid) using /all in your browser, the returned json is huge and will slow down the browser!  Tip: set the HTTP Header \'Accept-Encoding: gzip\' for saving bandwidth. You will need to uncompress it on your end. Example with cURL: ``` curl -sH \'Accept-Encoding: gzip\' <api-endpoint> | gunzip - ```
         * @summary List All Sets
         * @param {GetAllSetsListLanguageEnum} language a valid language code
         * @param {GetAllSetsListGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {GetAllSetsListSortLevelEnum} [sortLevel] sort the resulting list by level, default unsorted
         * @param {number} [filterMinHighestEquipmentLevel] only results where the equipment with the highest level is above or equal to this value
         * @param {number} [filterMaxHighestEquipmentLevel] only results where the equipment with the highest level is below or equal to this value
         * @param {GetAllSetsListAcceptEncodingEnum} [acceptEncoding] optional compression for saving bandwidth
         * @param {boolean} [filterContainsCosmeticsOnly] filter sets based on if they only got cosmetic items in it. If true, the item ids are for the cosmetic endpoints instead of equipment.
         * @param {boolean} [filterContainsCosmetics] filter sets based on if they got cosmetic items in it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSetsList: async (language: GetAllSetsListLanguageEnum, game: GetAllSetsListGameEnum, sortLevel?: GetAllSetsListSortLevelEnum, filterMinHighestEquipmentLevel?: number, filterMaxHighestEquipmentLevel?: number, acceptEncoding?: GetAllSetsListAcceptEncodingEnum, filterContainsCosmeticsOnly?: boolean, filterContainsCosmetics?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getAllSetsList', 'language', language)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getAllSetsList', 'game', game)
            const localVarPath = `/{game}/v1/{language}/sets/all`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sortLevel !== undefined) {
                localVarQueryParameter['sort[level]'] = sortLevel;
            }

            if (filterMinHighestEquipmentLevel !== undefined) {
                localVarQueryParameter['filter[min_highest_equipment_level]'] = filterMinHighestEquipmentLevel;
            }

            if (filterMaxHighestEquipmentLevel !== undefined) {
                localVarQueryParameter['filter[max_highest_equipment_level]'] = filterMaxHighestEquipmentLevel;
            }

            if (filterContainsCosmeticsOnly !== undefined) {
                localVarQueryParameter['filter[contains_cosmetics_only]'] = filterContainsCosmeticsOnly;
            }

            if (filterContainsCosmetics !== undefined) {
                localVarQueryParameter['filter[contains_cosmetics]'] = filterContainsCosmetics;
            }


    
            if (acceptEncoding != null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of sets.
         * @summary List Sets
         * @param {GetSetsListLanguageEnum} language a valid language code
         * @param {GetSetsListGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {GetSetsListSortLevelEnum} [sortLevel] sort the resulting list by level, default unsorted
         * @param {number} [filterMinHighestEquipmentLevel] only results where the equipment with the highest level is above or equal to this value
         * @param {number} [filterMaxHighestEquipmentLevel] only results where the equipment with the highest level is below or equal to this value
         * @param {number} [pageSize] size of the results from the list. -1 disables pagination and gets all in one response.
         * @param {number} [pageNumber] page number based on the current page[size]. So you could get page 1 with 8 entrys and page 2 would have entries 8 to 16.
         * @param {Set<GetSetsListFieldsSetEnum>} [fieldsSet] adds fields from their detail endpoint to the item list entries. Multiple comma separated values allowed.
         * @param {boolean} [filterContainsCosmeticsOnly] filter sets based on if they only got cosmetic items in it. If true, the item ids are for the cosmetic endpoints instead of equipment.
         * @param {boolean} [filterContainsCosmetics] filter sets based on if they got cosmetic items in it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSetsList: async (language: GetSetsListLanguageEnum, game: GetSetsListGameEnum, sortLevel?: GetSetsListSortLevelEnum, filterMinHighestEquipmentLevel?: number, filterMaxHighestEquipmentLevel?: number, pageSize?: number, pageNumber?: number, fieldsSet?: Set<GetSetsListFieldsSetEnum>, filterContainsCosmeticsOnly?: boolean, filterContainsCosmetics?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getSetsList', 'language', language)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getSetsList', 'game', game)
            const localVarPath = `/{game}/v1/{language}/sets`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sortLevel !== undefined) {
                localVarQueryParameter['sort[level]'] = sortLevel;
            }

            if (filterMinHighestEquipmentLevel !== undefined) {
                localVarQueryParameter['filter[min_highest_equipment_level]'] = filterMinHighestEquipmentLevel;
            }

            if (filterMaxHighestEquipmentLevel !== undefined) {
                localVarQueryParameter['filter[max_highest_equipment_level]'] = filterMaxHighestEquipmentLevel;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page[size]'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['page[number]'] = pageNumber;
            }

            if (fieldsSet) {
                localVarQueryParameter['fields[set]'] = Array.from(fieldsSet).join(COLLECTION_FORMATS.csv);
            }

            if (filterContainsCosmeticsOnly !== undefined) {
                localVarQueryParameter['filter[contains_cosmetics_only]'] = filterContainsCosmeticsOnly;
            }

            if (filterContainsCosmetics !== undefined) {
                localVarQueryParameter['filter[contains_cosmetics]'] = filterContainsCosmetics;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search in all names and descriptions of sets with a query.
         * @summary Search Sets
         * @param {GetSetsSearchLanguageEnum} language a valid language code
         * @param {GetSetsSearchGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {string} query case sensitive search query
         * @param {number} [filterMinHighestEquipmentLevel] only results where the equipment with the highest level is above or equal to this value
         * @param {number} [filterMaxHighestEquipmentLevel] only results where the equipment with the highest level is below or equal to this value
         * @param {number} [limit] maximum number of returned results
         * @param {boolean} [filterContainsCosmeticsOnly] filter sets based on if they only got cosmetic items in it. If true, the item ids are for the cosmetic endpoints instead of equipment.
         * @param {boolean} [filterContainsCosmetics] filter sets based on if they got any cosmetic items in it
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSetsSearch: async (language: GetSetsSearchLanguageEnum, game: GetSetsSearchGameEnum, query: string, filterMinHighestEquipmentLevel?: number, filterMaxHighestEquipmentLevel?: number, limit?: number, filterContainsCosmeticsOnly?: boolean, filterContainsCosmetics?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getSetsSearch', 'language', language)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getSetsSearch', 'game', game)
            // verify required parameter 'query' is not null or undefined
            assertParamExists('getSetsSearch', 'query', query)
            const localVarPath = `/{game}/v1/{language}/sets/search`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (filterMinHighestEquipmentLevel !== undefined) {
                localVarQueryParameter['filter[min_highest_equipment_level]'] = filterMinHighestEquipmentLevel;
            }

            if (filterMaxHighestEquipmentLevel !== undefined) {
                localVarQueryParameter['filter[max_highest_equipment_level]'] = filterMaxHighestEquipmentLevel;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (filterContainsCosmeticsOnly !== undefined) {
                localVarQueryParameter['filter[contains_cosmetics_only]'] = filterContainsCosmeticsOnly;
            }

            if (filterContainsCosmetics !== undefined) {
                localVarQueryParameter['filter[contains_cosmetics]'] = filterContainsCosmetics;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific set with id.
         * @summary Single Sets
         * @param {GetSetsSingleLanguageEnum} language a valid language code
         * @param {number} ankamaId identifier
         * @param {GetSetsSingleGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSetsSingle: async (language: GetSetsSingleLanguageEnum, ankamaId: number, game: GetSetsSingleGameEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getSetsSingle', 'language', language)
            // verify required parameter 'ankamaId' is not null or undefined
            assertParamExists('getSetsSingle', 'ankamaId', ankamaId)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getSetsSingle', 'game', game)
            const localVarPath = `/{game}/v1/{language}/sets/{ankama_id}`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"ankama_id"}}`, encodeURIComponent(String(ankamaId)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SetsApi - functional programming interface
 * @export
 */
export const SetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SetsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve all sets with one request. This endpoint is just an alias for the a list with disabled pagination (page[size]=-1) and all fields[type] set.  If you want everything unfiltered, delete the other query parameters.  Be careful with testing or (god forbid) using /all in your browser, the returned json is huge and will slow down the browser!  Tip: set the HTTP Header \'Accept-Encoding: gzip\' for saving bandwidth. You will need to uncompress it on your end. Example with cURL: ``` curl -sH \'Accept-Encoding: gzip\' <api-endpoint> | gunzip - ```
         * @summary List All Sets
         * @param {GetAllSetsListLanguageEnum} language a valid language code
         * @param {GetAllSetsListGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {GetAllSetsListSortLevelEnum} [sortLevel] sort the resulting list by level, default unsorted
         * @param {number} [filterMinHighestEquipmentLevel] only results where the equipment with the highest level is above or equal to this value
         * @param {number} [filterMaxHighestEquipmentLevel] only results where the equipment with the highest level is below or equal to this value
         * @param {GetAllSetsListAcceptEncodingEnum} [acceptEncoding] optional compression for saving bandwidth
         * @param {boolean} [filterContainsCosmeticsOnly] filter sets based on if they only got cosmetic items in it. If true, the item ids are for the cosmetic endpoints instead of equipment.
         * @param {boolean} [filterContainsCosmetics] filter sets based on if they got cosmetic items in it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllSetsList(language: GetAllSetsListLanguageEnum, game: GetAllSetsListGameEnum, sortLevel?: GetAllSetsListSortLevelEnum, filterMinHighestEquipmentLevel?: number, filterMaxHighestEquipmentLevel?: number, acceptEncoding?: GetAllSetsListAcceptEncodingEnum, filterContainsCosmeticsOnly?: boolean, filterContainsCosmetics?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListEquipmentSets>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllSetsList(language, game, sortLevel, filterMinHighestEquipmentLevel, filterMaxHighestEquipmentLevel, acceptEncoding, filterContainsCosmeticsOnly, filterContainsCosmetics, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SetsApi.getAllSetsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of sets.
         * @summary List Sets
         * @param {GetSetsListLanguageEnum} language a valid language code
         * @param {GetSetsListGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {GetSetsListSortLevelEnum} [sortLevel] sort the resulting list by level, default unsorted
         * @param {number} [filterMinHighestEquipmentLevel] only results where the equipment with the highest level is above or equal to this value
         * @param {number} [filterMaxHighestEquipmentLevel] only results where the equipment with the highest level is below or equal to this value
         * @param {number} [pageSize] size of the results from the list. -1 disables pagination and gets all in one response.
         * @param {number} [pageNumber] page number based on the current page[size]. So you could get page 1 with 8 entrys and page 2 would have entries 8 to 16.
         * @param {Set<GetSetsListFieldsSetEnum>} [fieldsSet] adds fields from their detail endpoint to the item list entries. Multiple comma separated values allowed.
         * @param {boolean} [filterContainsCosmeticsOnly] filter sets based on if they only got cosmetic items in it. If true, the item ids are for the cosmetic endpoints instead of equipment.
         * @param {boolean} [filterContainsCosmetics] filter sets based on if they got cosmetic items in it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSetsList(language: GetSetsListLanguageEnum, game: GetSetsListGameEnum, sortLevel?: GetSetsListSortLevelEnum, filterMinHighestEquipmentLevel?: number, filterMaxHighestEquipmentLevel?: number, pageSize?: number, pageNumber?: number, fieldsSet?: Set<GetSetsListFieldsSetEnum>, filterContainsCosmeticsOnly?: boolean, filterContainsCosmetics?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListEquipmentSets>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSetsList(language, game, sortLevel, filterMinHighestEquipmentLevel, filterMaxHighestEquipmentLevel, pageSize, pageNumber, fieldsSet, filterContainsCosmeticsOnly, filterContainsCosmetics, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SetsApi.getSetsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search in all names and descriptions of sets with a query.
         * @summary Search Sets
         * @param {GetSetsSearchLanguageEnum} language a valid language code
         * @param {GetSetsSearchGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {string} query case sensitive search query
         * @param {number} [filterMinHighestEquipmentLevel] only results where the equipment with the highest level is above or equal to this value
         * @param {number} [filterMaxHighestEquipmentLevel] only results where the equipment with the highest level is below or equal to this value
         * @param {number} [limit] maximum number of returned results
         * @param {boolean} [filterContainsCosmeticsOnly] filter sets based on if they only got cosmetic items in it. If true, the item ids are for the cosmetic endpoints instead of equipment.
         * @param {boolean} [filterContainsCosmetics] filter sets based on if they got any cosmetic items in it
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSetsSearch(language: GetSetsSearchLanguageEnum, game: GetSetsSearchGameEnum, query: string, filterMinHighestEquipmentLevel?: number, filterMaxHighestEquipmentLevel?: number, limit?: number, filterContainsCosmeticsOnly?: boolean, filterContainsCosmetics?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListEquipmentSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSetsSearch(language, game, query, filterMinHighestEquipmentLevel, filterMaxHighestEquipmentLevel, limit, filterContainsCosmeticsOnly, filterContainsCosmetics, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SetsApi.getSetsSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific set with id.
         * @summary Single Sets
         * @param {GetSetsSingleLanguageEnum} language a valid language code
         * @param {number} ankamaId identifier
         * @param {GetSetsSingleGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSetsSingle(language: GetSetsSingleLanguageEnum, ankamaId: number, game: GetSetsSingleGameEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EquipmentSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSetsSingle(language, ankamaId, game, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SetsApi.getSetsSingle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SetsApi - factory interface
 * @export
 */
export const SetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SetsApiFp(configuration)
    return {
        /**
         * Retrieve all sets with one request. This endpoint is just an alias for the a list with disabled pagination (page[size]=-1) and all fields[type] set.  If you want everything unfiltered, delete the other query parameters.  Be careful with testing or (god forbid) using /all in your browser, the returned json is huge and will slow down the browser!  Tip: set the HTTP Header \'Accept-Encoding: gzip\' for saving bandwidth. You will need to uncompress it on your end. Example with cURL: ``` curl -sH \'Accept-Encoding: gzip\' <api-endpoint> | gunzip - ```
         * @summary List All Sets
         * @param {GetAllSetsListLanguageEnum} language a valid language code
         * @param {GetAllSetsListGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {GetAllSetsListSortLevelEnum} [sortLevel] sort the resulting list by level, default unsorted
         * @param {number} [filterMinHighestEquipmentLevel] only results where the equipment with the highest level is above or equal to this value
         * @param {number} [filterMaxHighestEquipmentLevel] only results where the equipment with the highest level is below or equal to this value
         * @param {GetAllSetsListAcceptEncodingEnum} [acceptEncoding] optional compression for saving bandwidth
         * @param {boolean} [filterContainsCosmeticsOnly] filter sets based on if they only got cosmetic items in it. If true, the item ids are for the cosmetic endpoints instead of equipment.
         * @param {boolean} [filterContainsCosmetics] filter sets based on if they got cosmetic items in it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSetsList(language: GetAllSetsListLanguageEnum, game: GetAllSetsListGameEnum, sortLevel?: GetAllSetsListSortLevelEnum, filterMinHighestEquipmentLevel?: number, filterMaxHighestEquipmentLevel?: number, acceptEncoding?: GetAllSetsListAcceptEncodingEnum, filterContainsCosmeticsOnly?: boolean, filterContainsCosmetics?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<ListEquipmentSets> {
            return localVarFp.getAllSetsList(language, game, sortLevel, filterMinHighestEquipmentLevel, filterMaxHighestEquipmentLevel, acceptEncoding, filterContainsCosmeticsOnly, filterContainsCosmetics, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of sets.
         * @summary List Sets
         * @param {GetSetsListLanguageEnum} language a valid language code
         * @param {GetSetsListGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {GetSetsListSortLevelEnum} [sortLevel] sort the resulting list by level, default unsorted
         * @param {number} [filterMinHighestEquipmentLevel] only results where the equipment with the highest level is above or equal to this value
         * @param {number} [filterMaxHighestEquipmentLevel] only results where the equipment with the highest level is below or equal to this value
         * @param {number} [pageSize] size of the results from the list. -1 disables pagination and gets all in one response.
         * @param {number} [pageNumber] page number based on the current page[size]. So you could get page 1 with 8 entrys and page 2 would have entries 8 to 16.
         * @param {Set<GetSetsListFieldsSetEnum>} [fieldsSet] adds fields from their detail endpoint to the item list entries. Multiple comma separated values allowed.
         * @param {boolean} [filterContainsCosmeticsOnly] filter sets based on if they only got cosmetic items in it. If true, the item ids are for the cosmetic endpoints instead of equipment.
         * @param {boolean} [filterContainsCosmetics] filter sets based on if they got cosmetic items in it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSetsList(language: GetSetsListLanguageEnum, game: GetSetsListGameEnum, sortLevel?: GetSetsListSortLevelEnum, filterMinHighestEquipmentLevel?: number, filterMaxHighestEquipmentLevel?: number, pageSize?: number, pageNumber?: number, fieldsSet?: Set<GetSetsListFieldsSetEnum>, filterContainsCosmeticsOnly?: boolean, filterContainsCosmetics?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<ListEquipmentSets> {
            return localVarFp.getSetsList(language, game, sortLevel, filterMinHighestEquipmentLevel, filterMaxHighestEquipmentLevel, pageSize, pageNumber, fieldsSet, filterContainsCosmeticsOnly, filterContainsCosmetics, options).then((request) => request(axios, basePath));
        },
        /**
         * Search in all names and descriptions of sets with a query.
         * @summary Search Sets
         * @param {GetSetsSearchLanguageEnum} language a valid language code
         * @param {GetSetsSearchGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {string} query case sensitive search query
         * @param {number} [filterMinHighestEquipmentLevel] only results where the equipment with the highest level is above or equal to this value
         * @param {number} [filterMaxHighestEquipmentLevel] only results where the equipment with the highest level is below or equal to this value
         * @param {number} [limit] maximum number of returned results
         * @param {boolean} [filterContainsCosmeticsOnly] filter sets based on if they only got cosmetic items in it. If true, the item ids are for the cosmetic endpoints instead of equipment.
         * @param {boolean} [filterContainsCosmetics] filter sets based on if they got any cosmetic items in it
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSetsSearch(language: GetSetsSearchLanguageEnum, game: GetSetsSearchGameEnum, query: string, filterMinHighestEquipmentLevel?: number, filterMaxHighestEquipmentLevel?: number, limit?: number, filterContainsCosmeticsOnly?: boolean, filterContainsCosmetics?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<ListEquipmentSet>> {
            return localVarFp.getSetsSearch(language, game, query, filterMinHighestEquipmentLevel, filterMaxHighestEquipmentLevel, limit, filterContainsCosmeticsOnly, filterContainsCosmetics, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific set with id.
         * @summary Single Sets
         * @param {GetSetsSingleLanguageEnum} language a valid language code
         * @param {number} ankamaId identifier
         * @param {GetSetsSingleGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSetsSingle(language: GetSetsSingleLanguageEnum, ankamaId: number, game: GetSetsSingleGameEnum, options?: RawAxiosRequestConfig): AxiosPromise<EquipmentSet> {
            return localVarFp.getSetsSingle(language, ankamaId, game, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SetsApi - object-oriented interface
 * @export
 * @class SetsApi
 * @extends {BaseAPI}
 */
export class SetsApi extends BaseAPI {
    /**
     * Retrieve all sets with one request. This endpoint is just an alias for the a list with disabled pagination (page[size]=-1) and all fields[type] set.  If you want everything unfiltered, delete the other query parameters.  Be careful with testing or (god forbid) using /all in your browser, the returned json is huge and will slow down the browser!  Tip: set the HTTP Header \'Accept-Encoding: gzip\' for saving bandwidth. You will need to uncompress it on your end. Example with cURL: ``` curl -sH \'Accept-Encoding: gzip\' <api-endpoint> | gunzip - ```
     * @summary List All Sets
     * @param {GetAllSetsListLanguageEnum} language a valid language code
     * @param {GetAllSetsListGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
     * @param {GetAllSetsListSortLevelEnum} [sortLevel] sort the resulting list by level, default unsorted
     * @param {number} [filterMinHighestEquipmentLevel] only results where the equipment with the highest level is above or equal to this value
     * @param {number} [filterMaxHighestEquipmentLevel] only results where the equipment with the highest level is below or equal to this value
     * @param {GetAllSetsListAcceptEncodingEnum} [acceptEncoding] optional compression for saving bandwidth
     * @param {boolean} [filterContainsCosmeticsOnly] filter sets based on if they only got cosmetic items in it. If true, the item ids are for the cosmetic endpoints instead of equipment.
     * @param {boolean} [filterContainsCosmetics] filter sets based on if they got cosmetic items in it.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetsApi
     */
    public getAllSetsList(language: GetAllSetsListLanguageEnum, game: GetAllSetsListGameEnum, sortLevel?: GetAllSetsListSortLevelEnum, filterMinHighestEquipmentLevel?: number, filterMaxHighestEquipmentLevel?: number, acceptEncoding?: GetAllSetsListAcceptEncodingEnum, filterContainsCosmeticsOnly?: boolean, filterContainsCosmetics?: boolean, options?: RawAxiosRequestConfig) {
        return SetsApiFp(this.configuration).getAllSetsList(language, game, sortLevel, filterMinHighestEquipmentLevel, filterMaxHighestEquipmentLevel, acceptEncoding, filterContainsCosmeticsOnly, filterContainsCosmetics, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of sets.
     * @summary List Sets
     * @param {GetSetsListLanguageEnum} language a valid language code
     * @param {GetSetsListGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
     * @param {GetSetsListSortLevelEnum} [sortLevel] sort the resulting list by level, default unsorted
     * @param {number} [filterMinHighestEquipmentLevel] only results where the equipment with the highest level is above or equal to this value
     * @param {number} [filterMaxHighestEquipmentLevel] only results where the equipment with the highest level is below or equal to this value
     * @param {number} [pageSize] size of the results from the list. -1 disables pagination and gets all in one response.
     * @param {number} [pageNumber] page number based on the current page[size]. So you could get page 1 with 8 entrys and page 2 would have entries 8 to 16.
     * @param {Set<GetSetsListFieldsSetEnum>} [fieldsSet] adds fields from their detail endpoint to the item list entries. Multiple comma separated values allowed.
     * @param {boolean} [filterContainsCosmeticsOnly] filter sets based on if they only got cosmetic items in it. If true, the item ids are for the cosmetic endpoints instead of equipment.
     * @param {boolean} [filterContainsCosmetics] filter sets based on if they got cosmetic items in it.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetsApi
     */
    public getSetsList(language: GetSetsListLanguageEnum, game: GetSetsListGameEnum, sortLevel?: GetSetsListSortLevelEnum, filterMinHighestEquipmentLevel?: number, filterMaxHighestEquipmentLevel?: number, pageSize?: number, pageNumber?: number, fieldsSet?: Set<GetSetsListFieldsSetEnum>, filterContainsCosmeticsOnly?: boolean, filterContainsCosmetics?: boolean, options?: RawAxiosRequestConfig) {
        return SetsApiFp(this.configuration).getSetsList(language, game, sortLevel, filterMinHighestEquipmentLevel, filterMaxHighestEquipmentLevel, pageSize, pageNumber, fieldsSet, filterContainsCosmeticsOnly, filterContainsCosmetics, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search in all names and descriptions of sets with a query.
     * @summary Search Sets
     * @param {GetSetsSearchLanguageEnum} language a valid language code
     * @param {GetSetsSearchGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
     * @param {string} query case sensitive search query
     * @param {number} [filterMinHighestEquipmentLevel] only results where the equipment with the highest level is above or equal to this value
     * @param {number} [filterMaxHighestEquipmentLevel] only results where the equipment with the highest level is below or equal to this value
     * @param {number} [limit] maximum number of returned results
     * @param {boolean} [filterContainsCosmeticsOnly] filter sets based on if they only got cosmetic items in it. If true, the item ids are for the cosmetic endpoints instead of equipment.
     * @param {boolean} [filterContainsCosmetics] filter sets based on if they got any cosmetic items in it
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetsApi
     */
    public getSetsSearch(language: GetSetsSearchLanguageEnum, game: GetSetsSearchGameEnum, query: string, filterMinHighestEquipmentLevel?: number, filterMaxHighestEquipmentLevel?: number, limit?: number, filterContainsCosmeticsOnly?: boolean, filterContainsCosmetics?: boolean, options?: RawAxiosRequestConfig) {
        return SetsApiFp(this.configuration).getSetsSearch(language, game, query, filterMinHighestEquipmentLevel, filterMaxHighestEquipmentLevel, limit, filterContainsCosmeticsOnly, filterContainsCosmetics, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific set with id.
     * @summary Single Sets
     * @param {GetSetsSingleLanguageEnum} language a valid language code
     * @param {number} ankamaId identifier
     * @param {GetSetsSingleGameEnum} game game main \&#39;dofus3\&#39; or beta channel \&#39;dofus3beta\&#39;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetsApi
     */
    public getSetsSingle(language: GetSetsSingleLanguageEnum, ankamaId: number, game: GetSetsSingleGameEnum, options?: RawAxiosRequestConfig) {
        return SetsApiFp(this.configuration).getSetsSingle(language, ankamaId, game, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetAllSetsListLanguageEnum = {
    En: 'en',
    Fr: 'fr',
    De: 'de',
    Es: 'es',
    Pt: 'pt'
} as const;
export type GetAllSetsListLanguageEnum = typeof GetAllSetsListLanguageEnum[keyof typeof GetAllSetsListLanguageEnum];
/**
 * @export
 */
export const GetAllSetsListGameEnum = {
    Dofus3: 'dofus3',
    Dofus3beta: 'dofus3beta'
} as const;
export type GetAllSetsListGameEnum = typeof GetAllSetsListGameEnum[keyof typeof GetAllSetsListGameEnum];
/**
 * @export
 */
export const GetAllSetsListSortLevelEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type GetAllSetsListSortLevelEnum = typeof GetAllSetsListSortLevelEnum[keyof typeof GetAllSetsListSortLevelEnum];
/**
 * @export
 */
export const GetAllSetsListAcceptEncodingEnum = {
    Gzip: 'gzip'
} as const;
export type GetAllSetsListAcceptEncodingEnum = typeof GetAllSetsListAcceptEncodingEnum[keyof typeof GetAllSetsListAcceptEncodingEnum];
/**
 * @export
 */
export const GetSetsListLanguageEnum = {
    En: 'en',
    Fr: 'fr',
    De: 'de',
    Es: 'es',
    Pt: 'pt'
} as const;
export type GetSetsListLanguageEnum = typeof GetSetsListLanguageEnum[keyof typeof GetSetsListLanguageEnum];
/**
 * @export
 */
export const GetSetsListGameEnum = {
    Dofus3: 'dofus3',
    Dofus3beta: 'dofus3beta'
} as const;
export type GetSetsListGameEnum = typeof GetSetsListGameEnum[keyof typeof GetSetsListGameEnum];
/**
 * @export
 */
export const GetSetsListSortLevelEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type GetSetsListSortLevelEnum = typeof GetSetsListSortLevelEnum[keyof typeof GetSetsListSortLevelEnum];
/**
 * @export
 */
export const GetSetsListFieldsSetEnum = {
    Effects: 'effects',
    EquipmentIds: 'equipment_ids'
} as const;
export type GetSetsListFieldsSetEnum = typeof GetSetsListFieldsSetEnum[keyof typeof GetSetsListFieldsSetEnum];
/**
 * @export
 */
export const GetSetsSearchLanguageEnum = {
    En: 'en',
    Fr: 'fr',
    De: 'de',
    Es: 'es',
    Pt: 'pt'
} as const;
export type GetSetsSearchLanguageEnum = typeof GetSetsSearchLanguageEnum[keyof typeof GetSetsSearchLanguageEnum];
/**
 * @export
 */
export const GetSetsSearchGameEnum = {
    Dofus3: 'dofus3',
    Dofus3beta: 'dofus3beta'
} as const;
export type GetSetsSearchGameEnum = typeof GetSetsSearchGameEnum[keyof typeof GetSetsSearchGameEnum];
/**
 * @export
 */
export const GetSetsSingleLanguageEnum = {
    En: 'en',
    Fr: 'fr',
    De: 'de',
    Es: 'es',
    Pt: 'pt'
} as const;
export type GetSetsSingleLanguageEnum = typeof GetSetsSingleLanguageEnum[keyof typeof GetSetsSingleLanguageEnum];
/**
 * @export
 */
export const GetSetsSingleGameEnum = {
    Dofus3: 'dofus3',
    Dofus3beta: 'dofus3beta'
} as const;
export type GetSetsSingleGameEnum = typeof GetSetsSingleGameEnum[keyof typeof GetSetsSingleGameEnum];


/**
 * WebhooksApi - axios parameter creator
 * @export
 */
export const WebhooksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a Webhook from the service.
         * @summary Unregister Almanax Hook
         * @param {string} id the ID returned from the API when creating the webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhooksAlmanaxId: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteWebhooksAlmanaxId', 'id', id)
            const localVarPath = `/webhooks/almanax/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Webhook from the service.
         * @summary Unregister RSS Hook
         * @param {string} id the ID returned from the API when creating the webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhooksRssId: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteWebhooksRssId', 'id', id)
            const localVarPath = `/webhooks/rss/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Webhook from the service.
         * @summary Unregister Twitter Hook
         * @param {string} id the ID returned from the API when creating the webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhooksTwitterId: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteWebhooksTwitterId', 'id', id)
            const localVarPath = `/webhooks/twitter/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all available subscriptions. 
         * @summary Get Almanax Hook Metainfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetaWebhooksAlmanax: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/meta/webhooks/almanax`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all available subscriptions. 
         * @summary Get RSS Hook Metainfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetaWebhooksRss: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/meta/webhooks/rss`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all available subscriptions. 
         * @summary Get Twitter Hook Metainfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetaWebhooksTwitter: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/meta/webhooks/twitter`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details about an existing Almanax Webhook with a given uuid.
         * @summary Get Almanax Hook
         * @param {string} id the ID returned from the API when creating the webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooksAlmanaxId: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWebhooksAlmanaxId', 'id', id)
            const localVarPath = `/webhooks/almanax/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details about an existing RSS Webhook with a given uuid.
         * @summary Get RSS Hook
         * @param {string} id the ID returned from the API when creating the webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooksRssId: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWebhooksRssId', 'id', id)
            const localVarPath = `/webhooks/rss/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details about an existing Twitter Webhook with a given uuid.
         * @summary Get Twitter Hook
         * @param {string} id the ID returned from the API when creating the webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooksTwitterId: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWebhooksTwitterId', 'id', id)
            const localVarPath = `/webhooks/twitter/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register a new Webhook to post Almanax updates.
         * @summary Register Almanax Hook
         * @param {CreateAlmanaxWebhook} [createAlmanaxWebhook] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWebhooksAlmanax: async (createAlmanaxWebhook?: CreateAlmanaxWebhook, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/webhooks/almanax`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAlmanaxWebhook, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register a new Webhook to post RSS news as soon as they are posted.
         * @summary Register RSS Hook
         * @param {CreateRSSWebhook} [createRSSWebhook] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWebhooksRss: async (createRSSWebhook?: CreateRSSWebhook, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/webhooks/rss`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRSSWebhook, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register a new Webhook to post Twitter updates as soon as they are posted.
         * @summary Register Twitter Hook
         * @param {CreateTwitterWebhook} [createTwitterWebhook] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWebhooksTwitter: async (createTwitterWebhook?: CreateTwitterWebhook, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/webhooks/twitter`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTwitterWebhook, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the details of an Almanax Webhook. All fields are optional and arrays will be overwritten, so always put all selected items of an array.
         * @summary Update Almanax Hook
         * @param {string} id the ID returned from the API when creating the webhook
         * @param {PutAlmanaxWebhook} [putAlmanaxWebhook] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putWebhooksAlmanaxId: async (id: string, putAlmanaxWebhook?: PutAlmanaxWebhook, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putWebhooksAlmanaxId', 'id', id)
            const localVarPath = `/webhooks/almanax/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(putAlmanaxWebhook, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the details of a RSS Webhook. All fields are optional and arrays will be overwritten, so always put all selected items of an array.
         * @summary Update RSS Hook
         * @param {string} id the ID returned from the API when creating the webhook
         * @param {PutRSSWebhook} [putRSSWebhook] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putWebhooksRssId: async (id: string, putRSSWebhook?: PutRSSWebhook, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putWebhooksRssId', 'id', id)
            const localVarPath = `/webhooks/rss/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(putRSSWebhook, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the details of a Twitter Webhook. All fields are optional and arrays will be overwritten, so always put all selected items of an array.
         * @summary Update Twitter Hook
         * @param {string} id the ID returned from the API when creating the webhook
         * @param {PutTwitterWebhook} [putTwitterWebhook] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putWebhooksTwitterId: async (id: string, putTwitterWebhook?: PutTwitterWebhook, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putWebhooksTwitterId', 'id', id)
            const localVarPath = `/webhooks/twitter/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(putTwitterWebhook, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhooksApi - functional programming interface
 * @export
 */
export const WebhooksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhooksApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a Webhook from the service.
         * @summary Unregister Almanax Hook
         * @param {string} id the ID returned from the API when creating the webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWebhooksAlmanaxId(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWebhooksAlmanaxId(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.deleteWebhooksAlmanaxId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a Webhook from the service.
         * @summary Unregister RSS Hook
         * @param {string} id the ID returned from the API when creating the webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWebhooksRssId(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWebhooksRssId(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.deleteWebhooksRssId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a Webhook from the service.
         * @summary Unregister Twitter Hook
         * @param {string} id the ID returned from the API when creating the webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWebhooksTwitterId(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWebhooksTwitterId(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.deleteWebhooksTwitterId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of all available subscriptions. 
         * @summary Get Almanax Hook Metainfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetaWebhooksAlmanax(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMetaWebhooksTwitter200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetaWebhooksAlmanax(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.getMetaWebhooksAlmanax']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of all available subscriptions. 
         * @summary Get RSS Hook Metainfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetaWebhooksRss(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMetaWebhooksTwitter200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetaWebhooksRss(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.getMetaWebhooksRss']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of all available subscriptions. 
         * @summary Get Twitter Hook Metainfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetaWebhooksTwitter(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMetaWebhooksTwitter200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetaWebhooksTwitter(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.getMetaWebhooksTwitter']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve details about an existing Almanax Webhook with a given uuid.
         * @summary Get Almanax Hook
         * @param {string} id the ID returned from the API when creating the webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWebhooksAlmanaxId(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlmanaxWebhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWebhooksAlmanaxId(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.getWebhooksAlmanaxId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve details about an existing RSS Webhook with a given uuid.
         * @summary Get RSS Hook
         * @param {string} id the ID returned from the API when creating the webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWebhooksRssId(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RssWebhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWebhooksRssId(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.getWebhooksRssId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve details about an existing Twitter Webhook with a given uuid.
         * @summary Get Twitter Hook
         * @param {string} id the ID returned from the API when creating the webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWebhooksTwitterId(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TwitterWebhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWebhooksTwitterId(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.getWebhooksTwitterId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Register a new Webhook to post Almanax updates.
         * @summary Register Almanax Hook
         * @param {CreateAlmanaxWebhook} [createAlmanaxWebhook] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postWebhooksAlmanax(createAlmanaxWebhook?: CreateAlmanaxWebhook, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postWebhooksAlmanax(createAlmanaxWebhook, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.postWebhooksAlmanax']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Register a new Webhook to post RSS news as soon as they are posted.
         * @summary Register RSS Hook
         * @param {CreateRSSWebhook} [createRSSWebhook] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postWebhooksRss(createRSSWebhook?: CreateRSSWebhook, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postWebhooksRss(createRSSWebhook, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.postWebhooksRss']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Register a new Webhook to post Twitter updates as soon as they are posted.
         * @summary Register Twitter Hook
         * @param {CreateTwitterWebhook} [createTwitterWebhook] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postWebhooksTwitter(createTwitterWebhook?: CreateTwitterWebhook, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postWebhooksTwitter(createTwitterWebhook, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.postWebhooksTwitter']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the details of an Almanax Webhook. All fields are optional and arrays will be overwritten, so always put all selected items of an array.
         * @summary Update Almanax Hook
         * @param {string} id the ID returned from the API when creating the webhook
         * @param {PutAlmanaxWebhook} [putAlmanaxWebhook] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putWebhooksAlmanaxId(id: string, putAlmanaxWebhook?: PutAlmanaxWebhook, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlmanaxWebhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putWebhooksAlmanaxId(id, putAlmanaxWebhook, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.putWebhooksAlmanaxId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the details of a RSS Webhook. All fields are optional and arrays will be overwritten, so always put all selected items of an array.
         * @summary Update RSS Hook
         * @param {string} id the ID returned from the API when creating the webhook
         * @param {PutRSSWebhook} [putRSSWebhook] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putWebhooksRssId(id: string, putRSSWebhook?: PutRSSWebhook, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RssWebhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putWebhooksRssId(id, putRSSWebhook, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.putWebhooksRssId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the details of a Twitter Webhook. All fields are optional and arrays will be overwritten, so always put all selected items of an array.
         * @summary Update Twitter Hook
         * @param {string} id the ID returned from the API when creating the webhook
         * @param {PutTwitterWebhook} [putTwitterWebhook] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putWebhooksTwitterId(id: string, putTwitterWebhook?: PutTwitterWebhook, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TwitterWebhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putWebhooksTwitterId(id, putTwitterWebhook, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.putWebhooksTwitterId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WebhooksApi - factory interface
 * @export
 */
export const WebhooksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhooksApiFp(configuration)
    return {
        /**
         * Delete a Webhook from the service.
         * @summary Unregister Almanax Hook
         * @param {string} id the ID returned from the API when creating the webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhooksAlmanaxId(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteWebhooksAlmanaxId(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Webhook from the service.
         * @summary Unregister RSS Hook
         * @param {string} id the ID returned from the API when creating the webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhooksRssId(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteWebhooksRssId(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Webhook from the service.
         * @summary Unregister Twitter Hook
         * @param {string} id the ID returned from the API when creating the webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhooksTwitterId(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteWebhooksTwitterId(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all available subscriptions. 
         * @summary Get Almanax Hook Metainfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetaWebhooksAlmanax(options?: RawAxiosRequestConfig): AxiosPromise<GetMetaWebhooksTwitter200Response> {
            return localVarFp.getMetaWebhooksAlmanax(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all available subscriptions. 
         * @summary Get RSS Hook Metainfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetaWebhooksRss(options?: RawAxiosRequestConfig): AxiosPromise<GetMetaWebhooksTwitter200Response> {
            return localVarFp.getMetaWebhooksRss(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all available subscriptions. 
         * @summary Get Twitter Hook Metainfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetaWebhooksTwitter(options?: RawAxiosRequestConfig): AxiosPromise<GetMetaWebhooksTwitter200Response> {
            return localVarFp.getMetaWebhooksTwitter(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve details about an existing Almanax Webhook with a given uuid.
         * @summary Get Almanax Hook
         * @param {string} id the ID returned from the API when creating the webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooksAlmanaxId(id: string, options?: RawAxiosRequestConfig): AxiosPromise<AlmanaxWebhook> {
            return localVarFp.getWebhooksAlmanaxId(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve details about an existing RSS Webhook with a given uuid.
         * @summary Get RSS Hook
         * @param {string} id the ID returned from the API when creating the webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooksRssId(id: string, options?: RawAxiosRequestConfig): AxiosPromise<RssWebhook> {
            return localVarFp.getWebhooksRssId(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve details about an existing Twitter Webhook with a given uuid.
         * @summary Get Twitter Hook
         * @param {string} id the ID returned from the API when creating the webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooksTwitterId(id: string, options?: RawAxiosRequestConfig): AxiosPromise<TwitterWebhook> {
            return localVarFp.getWebhooksTwitterId(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Register a new Webhook to post Almanax updates.
         * @summary Register Almanax Hook
         * @param {CreateAlmanaxWebhook} [createAlmanaxWebhook] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWebhooksAlmanax(createAlmanaxWebhook?: CreateAlmanaxWebhook, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postWebhooksAlmanax(createAlmanaxWebhook, options).then((request) => request(axios, basePath));
        },
        /**
         * Register a new Webhook to post RSS news as soon as they are posted.
         * @summary Register RSS Hook
         * @param {CreateRSSWebhook} [createRSSWebhook] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWebhooksRss(createRSSWebhook?: CreateRSSWebhook, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postWebhooksRss(createRSSWebhook, options).then((request) => request(axios, basePath));
        },
        /**
         * Register a new Webhook to post Twitter updates as soon as they are posted.
         * @summary Register Twitter Hook
         * @param {CreateTwitterWebhook} [createTwitterWebhook] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWebhooksTwitter(createTwitterWebhook?: CreateTwitterWebhook, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postWebhooksTwitter(createTwitterWebhook, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the details of an Almanax Webhook. All fields are optional and arrays will be overwritten, so always put all selected items of an array.
         * @summary Update Almanax Hook
         * @param {string} id the ID returned from the API when creating the webhook
         * @param {PutAlmanaxWebhook} [putAlmanaxWebhook] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putWebhooksAlmanaxId(id: string, putAlmanaxWebhook?: PutAlmanaxWebhook, options?: RawAxiosRequestConfig): AxiosPromise<AlmanaxWebhook> {
            return localVarFp.putWebhooksAlmanaxId(id, putAlmanaxWebhook, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the details of a RSS Webhook. All fields are optional and arrays will be overwritten, so always put all selected items of an array.
         * @summary Update RSS Hook
         * @param {string} id the ID returned from the API when creating the webhook
         * @param {PutRSSWebhook} [putRSSWebhook] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putWebhooksRssId(id: string, putRSSWebhook?: PutRSSWebhook, options?: RawAxiosRequestConfig): AxiosPromise<RssWebhook> {
            return localVarFp.putWebhooksRssId(id, putRSSWebhook, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the details of a Twitter Webhook. All fields are optional and arrays will be overwritten, so always put all selected items of an array.
         * @summary Update Twitter Hook
         * @param {string} id the ID returned from the API when creating the webhook
         * @param {PutTwitterWebhook} [putTwitterWebhook] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putWebhooksTwitterId(id: string, putTwitterWebhook?: PutTwitterWebhook, options?: RawAxiosRequestConfig): AxiosPromise<TwitterWebhook> {
            return localVarFp.putWebhooksTwitterId(id, putTwitterWebhook, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebhooksApi - object-oriented interface
 * @export
 * @class WebhooksApi
 * @extends {BaseAPI}
 */
export class WebhooksApi extends BaseAPI {
    /**
     * Delete a Webhook from the service.
     * @summary Unregister Almanax Hook
     * @param {string} id the ID returned from the API when creating the webhook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public deleteWebhooksAlmanaxId(id: string, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).deleteWebhooksAlmanaxId(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a Webhook from the service.
     * @summary Unregister RSS Hook
     * @param {string} id the ID returned from the API when creating the webhook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public deleteWebhooksRssId(id: string, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).deleteWebhooksRssId(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a Webhook from the service.
     * @summary Unregister Twitter Hook
     * @param {string} id the ID returned from the API when creating the webhook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public deleteWebhooksTwitterId(id: string, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).deleteWebhooksTwitterId(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all available subscriptions. 
     * @summary Get Almanax Hook Metainfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public getMetaWebhooksAlmanax(options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).getMetaWebhooksAlmanax(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all available subscriptions. 
     * @summary Get RSS Hook Metainfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public getMetaWebhooksRss(options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).getMetaWebhooksRss(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all available subscriptions. 
     * @summary Get Twitter Hook Metainfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public getMetaWebhooksTwitter(options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).getMetaWebhooksTwitter(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve details about an existing Almanax Webhook with a given uuid.
     * @summary Get Almanax Hook
     * @param {string} id the ID returned from the API when creating the webhook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public getWebhooksAlmanaxId(id: string, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).getWebhooksAlmanaxId(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve details about an existing RSS Webhook with a given uuid.
     * @summary Get RSS Hook
     * @param {string} id the ID returned from the API when creating the webhook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public getWebhooksRssId(id: string, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).getWebhooksRssId(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve details about an existing Twitter Webhook with a given uuid.
     * @summary Get Twitter Hook
     * @param {string} id the ID returned from the API when creating the webhook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public getWebhooksTwitterId(id: string, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).getWebhooksTwitterId(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register a new Webhook to post Almanax updates.
     * @summary Register Almanax Hook
     * @param {CreateAlmanaxWebhook} [createAlmanaxWebhook] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public postWebhooksAlmanax(createAlmanaxWebhook?: CreateAlmanaxWebhook, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).postWebhooksAlmanax(createAlmanaxWebhook, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register a new Webhook to post RSS news as soon as they are posted.
     * @summary Register RSS Hook
     * @param {CreateRSSWebhook} [createRSSWebhook] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public postWebhooksRss(createRSSWebhook?: CreateRSSWebhook, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).postWebhooksRss(createRSSWebhook, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register a new Webhook to post Twitter updates as soon as they are posted.
     * @summary Register Twitter Hook
     * @param {CreateTwitterWebhook} [createTwitterWebhook] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public postWebhooksTwitter(createTwitterWebhook?: CreateTwitterWebhook, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).postWebhooksTwitter(createTwitterWebhook, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the details of an Almanax Webhook. All fields are optional and arrays will be overwritten, so always put all selected items of an array.
     * @summary Update Almanax Hook
     * @param {string} id the ID returned from the API when creating the webhook
     * @param {PutAlmanaxWebhook} [putAlmanaxWebhook] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public putWebhooksAlmanaxId(id: string, putAlmanaxWebhook?: PutAlmanaxWebhook, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).putWebhooksAlmanaxId(id, putAlmanaxWebhook, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the details of a RSS Webhook. All fields are optional and arrays will be overwritten, so always put all selected items of an array.
     * @summary Update RSS Hook
     * @param {string} id the ID returned from the API when creating the webhook
     * @param {PutRSSWebhook} [putRSSWebhook] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public putWebhooksRssId(id: string, putRSSWebhook?: PutRSSWebhook, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).putWebhooksRssId(id, putRSSWebhook, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the details of a Twitter Webhook. All fields are optional and arrays will be overwritten, so always put all selected items of an array.
     * @summary Update Twitter Hook
     * @param {string} id the ID returned from the API when creating the webhook
     * @param {PutTwitterWebhook} [putTwitterWebhook] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public putWebhooksTwitterId(id: string, putTwitterWebhook?: PutTwitterWebhook, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).putWebhooksTwitterId(id, putTwitterWebhook, options).then((request) => request(this.axios, this.basePath));
    }
}



