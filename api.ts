/* tslint:disable */
/* eslint-disable */
/**
 * Dofusdude
 * # A project for you - the developer. The free, always-up-to-date, low-latency, insert-buzzword-here Ankama API for your next cool project!  ## Client SDKs Don\'t write types or functions yourself - I already (kinda) did! üòâ - [Javascript](https://github.com/dofusdude/dofusdude-js) npm i dofusdude-js --save - [Typescript](https://github.com/dofusdude/dofusdude-ts) npm i dofusdude-ts --save - [Go](https://github.com/dofusdude/dodugo) go get -u github.com/dofusdude/dodugo - [Python](https://github.com/dofusdude/dofusdude-py) pip install dofusdude  Everything, including this site, is generated out of the [Docs Repo](https://github.com/dofusdude/api-docs). Consider it the Single Source of Truth. If there is a problem with the SDKs, create an issue there.  Your favorite language is missing? Please let me know!  # Main Features - ü•∑ **Seamless Auto-Update** load data in the background when a new Dofus version is released and serving it within 2 minutes with atomic data source switching. No downtime and no effects for the user, just always up-to-date.  - ‚ö° **Blazingly Fast** all data in-memory, aggressive caching over short time spans, HTTP/2 multiplexing, written in Go, optimized for low latency, hosted on bare metal in üá©üá™.  - ü©∏ **Dofus 2 Beta** from stable to bleeding edge by replacing /dofus2 with /dofus2beta.  - üó£Ô∏è **Multilingual** supporting _en_, _fr_, _es_, _pt_ including the dropped languages from the Dofus website _de_ and _it_.  - üß† **Search by Relevance** allowing typos in name and description, handled by language specific text analysis and indexing by the powerful [Meilisearch](https://www.meilisearch.com) written in Rust.  - üïµÔ∏è **Complete** actual data from the game including items invisible to the encyclopedia like quest items.  - üñºÔ∏è **HD Images** rendering vector graphics into PNGs up to 800x800 px in the background.   ## Current state - Weapons ‚úÖ - Equipment ‚úÖ - Sets ‚úÖ - Resources ‚úÖ - Consumables ‚úÖ - Pets ‚úÖ - Mounts ‚úÖ - Cosmetics/Ceremonial Items ‚úÖ - Harnesses ‚úÖ - Quest Items ‚úÖ - Almanax ‚úÖ - Monsters ‚ùå - Spells ‚ùå  ... and much more on the Roadmap on my Discord.   ## Deploy now. Use forever. Everything you see here on this site, you can use now and forever. Updates could introduce new fields, new paths or parameter but never break backwards compatibility, so no field or parameter will be deleted.  There is one exception! **The API will _always_ choose being up-to-date over everything else**. So if Ankama decides to drop languages from the game like they did with their website, the API will loose support for them, too.  ## Only the beginning... ü§Ø I want this project to be useful and not just add plain GET-categories no one needs.  There is a long list of features I want to add (see the Roadmap on my [Discord](https://discord.gg/3EtHskZD8h)). But they are all focussed on you, the developers. So please let me know what you need. I will change the list based on demand.  # Get started! ü•≥ Scroll down and try it for yourself!  Or see how these other awesome projects use it: - [KaellyBot](https://github.com/Kaysoro/KaellyBot) by Kaysoro - [Dofus Craftlist](https://dofuscraftlist-dev.netlify.app) by Lystina - [AlmanaxApp](https://almanaxapp.netlify.app) by Lystina - [luwnarya.fr](https://luwnarya.fr)  I highly recommend using the SDKs for quick results. I use them myself for microservices for the API.  ## Thank you! I highly welcome everyone on my [Discord](https://discord.gg/3EtHskZD8h) to just talk about projects and use cases or give feedback of any kind.  The servers have a fixed monthly cost to provide very fast responses. If you want to help me keeping them running or simply  donate, consider becoming a [GitHub Sponsor](https://github.com/sponsors/dofusdude).  
 *
 * The version of the OpenAPI document: 0.6.0
 * Contact: stelzo@steado.de
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AlmanaxEntry
 */
export interface AlmanaxEntry {
    /**
     * 
     * @type {AlmanaxEntryBonus}
     * @memberof AlmanaxEntry
     */
    'bonus'?: AlmanaxEntryBonus;
    /**
     * 
     * @type {string}
     * @memberof AlmanaxEntry
     */
    'date'?: string;
    /**
     * 
     * @type {AlmanaxEntryTribute}
     * @memberof AlmanaxEntry
     */
    'tribute'?: AlmanaxEntryTribute;
}
/**
 * 
 * @export
 * @interface AlmanaxEntryBonus
 */
export interface AlmanaxEntryBonus {
    /**
     * 
     * @type {string}
     * @memberof AlmanaxEntryBonus
     */
    'description'?: string;
    /**
     * 
     * @type {GetMetaAlmanaxBonuses200ResponseInner}
     * @memberof AlmanaxEntryBonus
     */
    'type'?: GetMetaAlmanaxBonuses200ResponseInner;
}
/**
 * 
 * @export
 * @interface AlmanaxEntryTribute
 */
export interface AlmanaxEntryTribute {
    /**
     * 
     * @type {AlmanaxEntryTributeItem}
     * @memberof AlmanaxEntryTribute
     */
    'item'?: AlmanaxEntryTributeItem;
    /**
     * 
     * @type {number}
     * @memberof AlmanaxEntryTribute
     */
    'quantity'?: number;
}
/**
 * 
 * @export
 * @interface AlmanaxEntryTributeItem
 */
export interface AlmanaxEntryTributeItem {
    /**
     * 
     * @type {number}
     * @memberof AlmanaxEntryTributeItem
     */
    'ankama_id'?: number;
    /**
     * 
     * @type {ImageUrls}
     * @memberof AlmanaxEntryTributeItem
     */
    'image_urls'?: ImageUrls;
    /**
     * 
     * @type {string}
     * @memberof AlmanaxEntryTributeItem
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AlmanaxEntryTributeItem
     */
    'subtype'?: string;
}
/**
 * 
 * @export
 * @interface ConditionEntry
 */
export interface ConditionEntry {
    /**
     * 
     * @type {string}
     * @memberof ConditionEntry
     */
    'operator'?: string;
    /**
     * 
     * @type {number}
     * @memberof ConditionEntry
     */
    'int_value'?: number;
    /**
     * 
     * @type {EffectsEntryType}
     * @memberof ConditionEntry
     */
    'element'?: EffectsEntryType;
}
/**
 * 
 * @export
 * @interface Cosmetic
 */
export interface Cosmetic {
    /**
     * 
     * @type {number}
     * @memberof Cosmetic
     */
    'ankama_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Cosmetic
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Cosmetic
     */
    'description'?: string;
    /**
     * 
     * @type {ItemsListEntryTypedType}
     * @memberof Cosmetic
     */
    'type'?: ItemsListEntryTypedType;
    /**
     * 
     * @type {number}
     * @memberof Cosmetic
     */
    'level'?: number;
    /**
     * 
     * @type {number}
     * @memberof Cosmetic
     */
    'pods'?: number;
    /**
     * 
     * @type {ImageUrls}
     * @memberof Cosmetic
     */
    'image_urls'?: ImageUrls;
    /**
     * 
     * @type {Array<EffectsEntry>}
     * @memberof Cosmetic
     */
    'effects'?: Array<EffectsEntry> | null;
    /**
     * 
     * @type {Array<ConditionEntry>}
     * @memberof Cosmetic
     */
    'conditions'?: Array<ConditionEntry> | null;
    /**
     * 
     * @type {Array<RecipeEntry>}
     * @memberof Cosmetic
     */
    'recipe'?: Array<RecipeEntry> | null;
}
/**
 * 
 * @export
 * @interface EffectsEntry
 */
export interface EffectsEntry {
    /**
     * minimum int value, can be a single if ignore_int_max and no ignore_int_min
     * @type {number}
     * @memberof EffectsEntry
     */
    'int_minimum'?: number;
    /**
     * maximum int value, if not ignore_int_max and not ignore_int_min, the effect has a range value
     * @type {number}
     * @memberof EffectsEntry
     */
    'int_maximum'?: number;
    /**
     * 
     * @type {EffectsEntryType}
     * @memberof EffectsEntry
     */
    'type'?: EffectsEntryType;
    /**
     * ignore the int min field because the actual value is a string. For readability the templated field is the only important field in this case. 
     * @type {boolean}
     * @memberof EffectsEntry
     */
    'ignore_int_min'?: boolean;
    /**
     * ignore the int max field, if ignore_int_min is true, int min is a single value
     * @type {boolean}
     * @memberof EffectsEntry
     */
    'ignore_int_max'?: boolean;
    /**
     * all fields from above encoded in a single string
     * @type {string}
     * @memberof EffectsEntry
     */
    'formatted'?: string;
}
/**
 * 
 * @export
 * @interface EffectsEntryType
 */
export interface EffectsEntryType {
    /**
     * 
     * @type {string}
     * @memberof EffectsEntryType
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof EffectsEntryType
     */
    'id'?: number;
    /**
     * true if a type is generated from the Api instead of Ankama. In that case, always prefer showing the templated string and omit everything else. The \"name\" field will have an english description of the meta type. An example for such effects are class sets effects.
     * @type {boolean}
     * @memberof EffectsEntryType
     */
    'is_meta'?: boolean;
}
/**
 * 
 * @export
 * @interface Equipment
 */
export interface Equipment {
    /**
     * 
     * @type {number}
     * @memberof Equipment
     */
    'ankama_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Equipment
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Equipment
     */
    'description'?: string;
    /**
     * 
     * @type {ItemsListEntryTypedType}
     * @memberof Equipment
     */
    'type'?: ItemsListEntryTypedType;
    /**
     * 
     * @type {boolean}
     * @memberof Equipment
     */
    'is_weapon'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Equipment
     */
    'level'?: number;
    /**
     * 
     * @type {number}
     * @memberof Equipment
     */
    'pods'?: number;
    /**
     * 
     * @type {ImageUrls}
     * @memberof Equipment
     */
    'image_urls'?: ImageUrls;
    /**
     * 
     * @type {Array<EffectsEntry>}
     * @memberof Equipment
     */
    'effects'?: Array<EffectsEntry> | null;
    /**
     * 
     * @type {Array<ConditionEntry>}
     * @memberof Equipment
     */
    'conditions'?: Array<ConditionEntry> | null;
    /**
     * 
     * @type {Array<RecipeEntry>}
     * @memberof Equipment
     */
    'recipe'?: Array<RecipeEntry> | null;
    /**
     * 
     * @type {EquipmentParentSet}
     * @memberof Equipment
     */
    'parent_set'?: EquipmentParentSet | null;
}
/**
 * 
 * @export
 * @interface EquipmentParentSet
 */
export interface EquipmentParentSet {
    /**
     * 
     * @type {number}
     * @memberof EquipmentParentSet
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof EquipmentParentSet
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface EquipmentSet
 */
export interface EquipmentSet {
    /**
     * 
     * @type {number}
     * @memberof EquipmentSet
     */
    'ankama_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof EquipmentSet
     */
    'name'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof EquipmentSet
     */
    'equipment_ids'?: Array<number>;
    /**
     * 
     * @type {Array<Array<EffectsEntry>>}
     * @memberof EquipmentSet
     */
    'effects'?: Array<Array<EffectsEntry>> | null;
    /**
     * 
     * @type {number}
     * @memberof EquipmentSet
     */
    'level'?: number;
}
/**
 * 
 * @export
 * @interface GetMetaAlmanaxBonuses200ResponseInner
 */
export interface GetMetaAlmanaxBonuses200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof GetMetaAlmanaxBonuses200ResponseInner
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetMetaAlmanaxBonuses200ResponseInner
     */
    'name'?: string;
}
/**
 * All images except icon are rendered in the background which can take some time (up to hours if all data is completely generated from scratch). Because of this, they can be null if they are not yet rendered.
 * @export
 * @interface ImageUrls
 */
export interface ImageUrls {
    /**
     * 60x60 px, always available
     * @type {string}
     * @memberof ImageUrls
     */
    'icon'?: string;
    /**
     * 200x200 px
     * @type {string}
     * @memberof ImageUrls
     */
    'sd'?: string | null;
    /**
     * 400x400 px
     * @type {string}
     * @memberof ImageUrls
     */
    'hq'?: string | null;
    /**
     * 800x800 px
     * @type {string}
     * @memberof ImageUrls
     */
    'hd'?: string | null;
}
/**
 * 
 * @export
 * @interface ItemListEntry
 */
export interface ItemListEntry {
    /**
     * 
     * @type {number}
     * @memberof ItemListEntry
     */
    'ankama_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ItemListEntry
     */
    'name'?: string;
    /**
     * 
     * @type {ItemsListEntryTypedType}
     * @memberof ItemListEntry
     */
    'type'?: ItemsListEntryTypedType;
    /**
     * 
     * @type {number}
     * @memberof ItemListEntry
     */
    'level'?: number;
    /**
     * 
     * @type {ImageUrls}
     * @memberof ItemListEntry
     */
    'image_urls'?: ImageUrls;
    /**
     * 
     * @type {Array<RecipeEntry>}
     * @memberof ItemListEntry
     */
    'recipe'?: Array<RecipeEntry> | null;
}
/**
 * 
 * @export
 * @interface ItemsListEntryTyped
 */
export interface ItemsListEntryTyped {
    /**
     * 
     * @type {number}
     * @memberof ItemsListEntryTyped
     */
    'ankama_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ItemsListEntryTyped
     */
    'name'?: string;
    /**
     * 
     * @type {ItemsListEntryTypedType}
     * @memberof ItemsListEntryTyped
     */
    'type'?: ItemsListEntryTypedType;
    /**
     * The API item category. Can be used to build the request URL for this particular item. Always english.
     * @type {string}
     * @memberof ItemsListEntryTyped
     */
    'item_subtype'?: string;
    /**
     * 
     * @type {number}
     * @memberof ItemsListEntryTyped
     */
    'level'?: number;
    /**
     * 
     * @type {ImageUrls}
     * @memberof ItemsListEntryTyped
     */
    'image_urls'?: ImageUrls;
}
/**
 * 
 * @export
 * @interface ItemsListEntryTypedType
 */
export interface ItemsListEntryTypedType {
    /**
     * 
     * @type {string}
     * @memberof ItemsListEntryTypedType
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ItemsListPaged
 */
export interface ItemsListPaged {
    /**
     * 
     * @type {LinksPaged}
     * @memberof ItemsListPaged
     */
    '_links'?: LinksPaged;
    /**
     * 
     * @type {Array<ItemListEntry>}
     * @memberof ItemsListPaged
     */
    'items'?: Array<ItemListEntry>;
}
/**
 * 
 * @export
 * @interface LinksPaged
 */
export interface LinksPaged {
    /**
     * 
     * @type {string}
     * @memberof LinksPaged
     */
    'first'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LinksPaged
     */
    'prev'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LinksPaged
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LinksPaged
     */
    'last'?: string | null;
}
/**
 * 
 * @export
 * @interface Mount
 */
export interface Mount {
    /**
     * 
     * @type {number}
     * @memberof Mount
     */
    'ankama_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Mount
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Mount
     */
    'family_name'?: string;
    /**
     * 
     * @type {ImageUrls}
     * @memberof Mount
     */
    'image_urls'?: ImageUrls;
    /**
     * 
     * @type {Array<EffectsEntry>}
     * @memberof Mount
     */
    'effects'?: Array<EffectsEntry> | null;
}
/**
 * 
 * @export
 * @interface MountListEntry
 */
export interface MountListEntry {
    /**
     * 
     * @type {number}
     * @memberof MountListEntry
     */
    'ankama_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof MountListEntry
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof MountListEntry
     */
    'family_name'?: string;
    /**
     * 
     * @type {ImageUrls}
     * @memberof MountListEntry
     */
    'image_urls'?: ImageUrls;
}
/**
 * 
 * @export
 * @interface MountsListPaged
 */
export interface MountsListPaged {
    /**
     * 
     * @type {LinksPaged}
     * @memberof MountsListPaged
     */
    '_links'?: LinksPaged;
    /**
     * 
     * @type {Array<MountListEntry>}
     * @memberof MountsListPaged
     */
    'items'?: Array<MountListEntry>;
}
/**
 * 
 * @export
 * @interface RecipeEntry
 */
export interface RecipeEntry {
    /**
     * 
     * @type {number}
     * @memberof RecipeEntry
     */
    'item_ankama_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof RecipeEntry
     */
    'item_subtype'?: string;
    /**
     * 
     * @type {number}
     * @memberof RecipeEntry
     */
    'quantity'?: number;
}
/**
 * 
 * @export
 * @interface Resource
 */
export interface Resource {
    /**
     * 
     * @type {number}
     * @memberof Resource
     */
    'ankama_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Resource
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Resource
     */
    'description'?: string;
    /**
     * 
     * @type {ItemsListEntryTypedType}
     * @memberof Resource
     */
    'type'?: ItemsListEntryTypedType;
    /**
     * 
     * @type {number}
     * @memberof Resource
     */
    'level'?: number;
    /**
     * 
     * @type {number}
     * @memberof Resource
     */
    'pods'?: number;
    /**
     * 
     * @type {ImageUrls}
     * @memberof Resource
     */
    'image_urls'?: ImageUrls;
    /**
     * 
     * @type {Array<EffectsEntry>}
     * @memberof Resource
     */
    'effects'?: Array<EffectsEntry> | null;
    /**
     * 
     * @type {Array<ConditionEntry>}
     * @memberof Resource
     */
    'conditions'?: Array<ConditionEntry> | null;
    /**
     * 
     * @type {Array<RecipeEntry>}
     * @memberof Resource
     */
    'recipe'?: Array<RecipeEntry> | null;
}
/**
 * 
 * @export
 * @interface SetListEntry
 */
export interface SetListEntry {
    /**
     * 
     * @type {number}
     * @memberof SetListEntry
     */
    'ankama_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof SetListEntry
     */
    'name'?: string;
    /**
     * amount
     * @type {number}
     * @memberof SetListEntry
     */
    'items'?: number;
    /**
     * 
     * @type {number}
     * @memberof SetListEntry
     */
    'level'?: number;
}
/**
 * 
 * @export
 * @interface SetsListPaged
 */
export interface SetsListPaged {
    /**
     * 
     * @type {LinksPaged}
     * @memberof SetsListPaged
     */
    '_links'?: LinksPaged;
    /**
     * 
     * @type {Array<SetListEntry>}
     * @memberof SetsListPaged
     */
    'items'?: Array<SetListEntry>;
}
/**
 * 
 * @export
 * @interface Weapon
 */
export interface Weapon {
    /**
     * 
     * @type {number}
     * @memberof Weapon
     */
    'ankama_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Weapon
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Weapon
     */
    'description'?: string;
    /**
     * 
     * @type {ItemsListEntryTypedType}
     * @memberof Weapon
     */
    'type'?: ItemsListEntryTypedType;
    /**
     * always true when the item is a weapon. Many fields are now available. Always check for this flag first when getting single equipment items.
     * @type {boolean}
     * @memberof Weapon
     */
    'is_weapon'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Weapon
     */
    'level'?: number;
    /**
     * 
     * @type {number}
     * @memberof Weapon
     */
    'pods'?: number;
    /**
     * 
     * @type {ImageUrls}
     * @memberof Weapon
     */
    'image_urls'?: ImageUrls;
    /**
     * 
     * @type {Array<EffectsEntry>}
     * @memberof Weapon
     */
    'effects'?: Array<EffectsEntry> | null;
    /**
     * 
     * @type {Array<ConditionEntry>}
     * @memberof Weapon
     */
    'conditions'?: Array<ConditionEntry> | null;
    /**
     * 
     * @type {number}
     * @memberof Weapon
     */
    'critical_hit_probability'?: number;
    /**
     * 
     * @type {number}
     * @memberof Weapon
     */
    'critical_hit_bonus'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Weapon
     */
    'is_two_handed'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Weapon
     */
    'max_cast_per_turn'?: number;
    /**
     * 
     * @type {number}
     * @memberof Weapon
     */
    'ap_cost'?: number;
    /**
     * 
     * @type {WeaponRange}
     * @memberof Weapon
     */
    'range'?: WeaponRange;
    /**
     * 
     * @type {Array<RecipeEntry>}
     * @memberof Weapon
     */
    'recipe'?: Array<RecipeEntry> | null;
    /**
     * 
     * @type {EquipmentParentSet}
     * @memberof Weapon
     */
    'parent_set'?: EquipmentParentSet | null;
}
/**
 * 
 * @export
 * @interface WeaponRange
 */
export interface WeaponRange {
    /**
     * 
     * @type {number}
     * @memberof WeaponRange
     */
    'min'?: number;
    /**
     * 
     * @type {number}
     * @memberof WeaponRange
     */
    'max'?: number;
}

/**
 * AllItemsApi - axios parameter creator
 * @export
 */
export const AllItemsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Search in all names and descriptions of Dofus items (including all subtypes) with a query.
         * @summary Search All Items
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {string} query case sensitive search query
         * @param {string} [filterTypeName] only results with the translated type name across all item_subtypes
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsAllSearch: async (language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', query: string, filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getItemsAllSearch', 'language', language)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getItemsAllSearch', 'game', game)
            // verify required parameter 'query' is not null or undefined
            assertParamExists('getItemsAllSearch', 'query', query)
            const localVarPath = `/{game}/{language}/items/search`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (filterTypeName !== undefined) {
                localVarQueryParameter['filter[type_name]'] = filterTypeName;
            }

            if (filterMinLevel !== undefined) {
                localVarQueryParameter['filter[min_level]'] = filterMinLevel;
            }

            if (filterMaxLevel !== undefined) {
                localVarQueryParameter['filter[max_level]'] = filterMaxLevel;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AllItemsApi - functional programming interface
 * @export
 */
export const AllItemsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AllItemsApiAxiosParamCreator(configuration)
    return {
        /**
         * Search in all names and descriptions of Dofus items (including all subtypes) with a query.
         * @summary Search All Items
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {string} query case sensitive search query
         * @param {string} [filterTypeName] only results with the translated type name across all item_subtypes
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemsAllSearch(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', query: string, filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ItemsListEntryTyped>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemsAllSearch(language, game, query, filterTypeName, filterMinLevel, filterMaxLevel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AllItemsApi - factory interface
 * @export
 */
export const AllItemsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AllItemsApiFp(configuration)
    return {
        /**
         * Search in all names and descriptions of Dofus items (including all subtypes) with a query.
         * @summary Search All Items
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {string} query case sensitive search query
         * @param {string} [filterTypeName] only results with the translated type name across all item_subtypes
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsAllSearch(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', query: string, filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, options?: any): AxiosPromise<Array<ItemsListEntryTyped>> {
            return localVarFp.getItemsAllSearch(language, game, query, filterTypeName, filterMinLevel, filterMaxLevel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AllItemsApi - object-oriented interface
 * @export
 * @class AllItemsApi
 * @extends {BaseAPI}
 */
export class AllItemsApi extends BaseAPI {
    /**
     * Search in all names and descriptions of Dofus items (including all subtypes) with a query.
     * @summary Search All Items
     * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
     * @param {'dofus2' | 'dofus2beta'} game 
     * @param {string} query case sensitive search query
     * @param {string} [filterTypeName] only results with the translated type name across all item_subtypes
     * @param {number} [filterMinLevel] only results which level is equal or above this value
     * @param {number} [filterMaxLevel] only results which level is equal or below this value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AllItemsApi
     */
    public getItemsAllSearch(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', query: string, filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, options?: AxiosRequestConfig) {
        return AllItemsApiFp(this.configuration).getItemsAllSearch(language, game, query, filterTypeName, filterMinLevel, filterMaxLevel, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AlmanaxApi - axios parameter creator
 * @export
 */
export const AlmanaxApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a single date. There are not more details in the returned object than the normal range endpoint.
         * @summary Single Almanax Date
         * @param {'en' | 'fr' | 'de' | 'it' | 'es'} language code
         * @param {string} date yyyy-mm-dd
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlmanaxDate: async (language: 'en' | 'fr' | 'de' | 'it' | 'es', date: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getAlmanaxDate', 'language', language)
            // verify required parameter 'date' is not null or undefined
            assertParamExists('getAlmanaxDate', 'date', date)
            const localVarPath = `/dofus2/{language}/almanax/{date}`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a range of dates, defaults to today + 6 following days but can specified by the query parameters.   filter[bonus_type] can be used seperately and does not have an effect on the other parameters.  range[from] changes the start date, everything else defaults to 6 following dates from this start date.  range[to] when used without anything else, it will use today as start date and this parameter as end. All ranges are inclusive.  range[from] + range[to] = inclusive range over the specified dates, should never be farther apart than 35 days.  range[from|to] + range[size] no need to specify the date, just following days with [from] (0 is today) or go backwards in time with only [to] and [size].  Not all combinations are listed but this should give you an idea how to they could work.
         * @summary Almanax Range
         * @param {'en' | 'fr' | 'de' | 'it' | 'es'} language code
         * @param {string} [filterBonusType] ids from meta/{language}/almanax/bonuses
         * @param {string} [rangeFrom] yyyy-mm-dd
         * @param {string} [rangeTo] yyyy-mm-dd
         * @param {number} [rangeSize] size of the returned range
         * @param {string} [timezone] determine what the current time is. If you live in Brazil, \&quot;today\&quot; will be hours apart from Paris. Use your timezone to get results relative to your location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlmanaxRange: async (language: 'en' | 'fr' | 'de' | 'it' | 'es', filterBonusType?: string, rangeFrom?: string, rangeTo?: string, rangeSize?: number, timezone?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getAlmanaxRange', 'language', language)
            const localVarPath = `/dofus2/{language}/almanax`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filterBonusType !== undefined) {
                localVarQueryParameter['filter[bonus_type]'] = filterBonusType;
            }

            if (rangeFrom !== undefined) {
                localVarQueryParameter['range[from]'] = (rangeFrom as any instanceof Date) ?
                    (rangeFrom as any).toISOString().substr(0,10) :
                    rangeFrom;
            }

            if (rangeTo !== undefined) {
                localVarQueryParameter['range[to]'] = (rangeTo as any instanceof Date) ?
                    (rangeTo as any).toISOString().substr(0,10) :
                    rangeTo;
            }

            if (rangeSize !== undefined) {
                localVarQueryParameter['range[size]'] = rangeSize;
            }

            if (timezone !== undefined) {
                localVarQueryParameter['timezone'] = timezone;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AlmanaxApi - functional programming interface
 * @export
 */
export const AlmanaxApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AlmanaxApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a single date. There are not more details in the returned object than the normal range endpoint.
         * @summary Single Almanax Date
         * @param {'en' | 'fr' | 'de' | 'it' | 'es'} language code
         * @param {string} date yyyy-mm-dd
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAlmanaxDate(language: 'en' | 'fr' | 'de' | 'it' | 'es', date: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlmanaxEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAlmanaxDate(language, date, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a range of dates, defaults to today + 6 following days but can specified by the query parameters.   filter[bonus_type] can be used seperately and does not have an effect on the other parameters.  range[from] changes the start date, everything else defaults to 6 following dates from this start date.  range[to] when used without anything else, it will use today as start date and this parameter as end. All ranges are inclusive.  range[from] + range[to] = inclusive range over the specified dates, should never be farther apart than 35 days.  range[from|to] + range[size] no need to specify the date, just following days with [from] (0 is today) or go backwards in time with only [to] and [size].  Not all combinations are listed but this should give you an idea how to they could work.
         * @summary Almanax Range
         * @param {'en' | 'fr' | 'de' | 'it' | 'es'} language code
         * @param {string} [filterBonusType] ids from meta/{language}/almanax/bonuses
         * @param {string} [rangeFrom] yyyy-mm-dd
         * @param {string} [rangeTo] yyyy-mm-dd
         * @param {number} [rangeSize] size of the returned range
         * @param {string} [timezone] determine what the current time is. If you live in Brazil, \&quot;today\&quot; will be hours apart from Paris. Use your timezone to get results relative to your location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAlmanaxRange(language: 'en' | 'fr' | 'de' | 'it' | 'es', filterBonusType?: string, rangeFrom?: string, rangeTo?: string, rangeSize?: number, timezone?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AlmanaxEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAlmanaxRange(language, filterBonusType, rangeFrom, rangeTo, rangeSize, timezone, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AlmanaxApi - factory interface
 * @export
 */
export const AlmanaxApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AlmanaxApiFp(configuration)
    return {
        /**
         * Get a single date. There are not more details in the returned object than the normal range endpoint.
         * @summary Single Almanax Date
         * @param {'en' | 'fr' | 'de' | 'it' | 'es'} language code
         * @param {string} date yyyy-mm-dd
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlmanaxDate(language: 'en' | 'fr' | 'de' | 'it' | 'es', date: string, options?: any): AxiosPromise<AlmanaxEntry> {
            return localVarFp.getAlmanaxDate(language, date, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a range of dates, defaults to today + 6 following days but can specified by the query parameters.   filter[bonus_type] can be used seperately and does not have an effect on the other parameters.  range[from] changes the start date, everything else defaults to 6 following dates from this start date.  range[to] when used without anything else, it will use today as start date and this parameter as end. All ranges are inclusive.  range[from] + range[to] = inclusive range over the specified dates, should never be farther apart than 35 days.  range[from|to] + range[size] no need to specify the date, just following days with [from] (0 is today) or go backwards in time with only [to] and [size].  Not all combinations are listed but this should give you an idea how to they could work.
         * @summary Almanax Range
         * @param {'en' | 'fr' | 'de' | 'it' | 'es'} language code
         * @param {string} [filterBonusType] ids from meta/{language}/almanax/bonuses
         * @param {string} [rangeFrom] yyyy-mm-dd
         * @param {string} [rangeTo] yyyy-mm-dd
         * @param {number} [rangeSize] size of the returned range
         * @param {string} [timezone] determine what the current time is. If you live in Brazil, \&quot;today\&quot; will be hours apart from Paris. Use your timezone to get results relative to your location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlmanaxRange(language: 'en' | 'fr' | 'de' | 'it' | 'es', filterBonusType?: string, rangeFrom?: string, rangeTo?: string, rangeSize?: number, timezone?: string, options?: any): AxiosPromise<Array<AlmanaxEntry>> {
            return localVarFp.getAlmanaxRange(language, filterBonusType, rangeFrom, rangeTo, rangeSize, timezone, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AlmanaxApi - object-oriented interface
 * @export
 * @class AlmanaxApi
 * @extends {BaseAPI}
 */
export class AlmanaxApi extends BaseAPI {
    /**
     * Get a single date. There are not more details in the returned object than the normal range endpoint.
     * @summary Single Almanax Date
     * @param {'en' | 'fr' | 'de' | 'it' | 'es'} language code
     * @param {string} date yyyy-mm-dd
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlmanaxApi
     */
    public getAlmanaxDate(language: 'en' | 'fr' | 'de' | 'it' | 'es', date: string, options?: AxiosRequestConfig) {
        return AlmanaxApiFp(this.configuration).getAlmanaxDate(language, date, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a range of dates, defaults to today + 6 following days but can specified by the query parameters.   filter[bonus_type] can be used seperately and does not have an effect on the other parameters.  range[from] changes the start date, everything else defaults to 6 following dates from this start date.  range[to] when used without anything else, it will use today as start date and this parameter as end. All ranges are inclusive.  range[from] + range[to] = inclusive range over the specified dates, should never be farther apart than 35 days.  range[from|to] + range[size] no need to specify the date, just following days with [from] (0 is today) or go backwards in time with only [to] and [size].  Not all combinations are listed but this should give you an idea how to they could work.
     * @summary Almanax Range
     * @param {'en' | 'fr' | 'de' | 'it' | 'es'} language code
     * @param {string} [filterBonusType] ids from meta/{language}/almanax/bonuses
     * @param {string} [rangeFrom] yyyy-mm-dd
     * @param {string} [rangeTo] yyyy-mm-dd
     * @param {number} [rangeSize] size of the returned range
     * @param {string} [timezone] determine what the current time is. If you live in Brazil, \&quot;today\&quot; will be hours apart from Paris. Use your timezone to get results relative to your location.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlmanaxApi
     */
    public getAlmanaxRange(language: 'en' | 'fr' | 'de' | 'it' | 'es', filterBonusType?: string, rangeFrom?: string, rangeTo?: string, rangeSize?: number, timezone?: string, options?: AxiosRequestConfig) {
        return AlmanaxApiFp(this.configuration).getAlmanaxRange(language, filterBonusType, rangeFrom, rangeTo, rangeSize, timezone, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ConsumablesApi - axios parameter creator
 * @export
 */
export const ConsumablesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve all consumable items with one request. This endpoint is just an alias for the a list with disabled pagination (page[size]=-1) and all fields[type] set.  If you want everything unfiltered, delete the other query parameters.  Be careful with testing or (god forbid) using /all in your browser, the returned json is huge and will slow down the browser!  Tip: set the HTTP Header \'Accept-Encoding: gzip\' for saving bandwidth. You will need to uncompress it on your end. Example with cURL: ``` curl -sH \'Accept-Encoding: gzip\' <api-endpoint> | gunzip - ```
         * @summary List All Consumables
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {'asc' | 'desc'} [sortLevel] sort the resulting list by level, default unsorted
         * @param {string} [filterTypeName] only results with the translated type name
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {'gzip'} [acceptEncoding] optional compression for saving bandwidth
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllItemsConsumablesList: async (language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', sortLevel?: 'asc' | 'desc', filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, acceptEncoding?: 'gzip', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getAllItemsConsumablesList', 'language', language)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getAllItemsConsumablesList', 'game', game)
            const localVarPath = `/{game}/{language}/items/consumables/all`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sortLevel !== undefined) {
                localVarQueryParameter['sort[level]'] = sortLevel;
            }

            if (filterTypeName !== undefined) {
                localVarQueryParameter['filter[type_name]'] = filterTypeName;
            }

            if (filterMinLevel !== undefined) {
                localVarQueryParameter['filter[min_level]'] = filterMinLevel;
            }

            if (filterMaxLevel !== undefined) {
                localVarQueryParameter['filter[max_level]'] = filterMaxLevel;
            }

            if (acceptEncoding != null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of consumable items.
         * @summary List Consumables
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {'asc' | 'desc'} [sortLevel] sort the resulting list by level, default unsorted
         * @param {string} [filterTypeName] only results with the translated type name
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {number} [pageSize] size of the results from the list. -1 disables pagination and gets all in one response.
         * @param {number} [pageNumber] page number based on the current page[size]. So you could get page 1 with 8 entrys and page 2 would have entries 8 to 16.
         * @param {Set<'recipe' | 'description' | 'conditions' | 'effects'>} [fieldsItem] adds fields from their detail endpoint to the item list entries. Multiple comma separated values allowed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsConsumablesList: async (language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', sortLevel?: 'asc' | 'desc', filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, pageSize?: number, pageNumber?: number, fieldsItem?: Set<'recipe' | 'description' | 'conditions' | 'effects'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getItemsConsumablesList', 'language', language)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getItemsConsumablesList', 'game', game)
            const localVarPath = `/{game}/{language}/items/consumables`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sortLevel !== undefined) {
                localVarQueryParameter['sort[level]'] = sortLevel;
            }

            if (filterTypeName !== undefined) {
                localVarQueryParameter['filter[type_name]'] = filterTypeName;
            }

            if (filterMinLevel !== undefined) {
                localVarQueryParameter['filter[min_level]'] = filterMinLevel;
            }

            if (filterMaxLevel !== undefined) {
                localVarQueryParameter['filter[max_level]'] = filterMaxLevel;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page[size]'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['page[number]'] = pageNumber;
            }

            if (fieldsItem) {
                localVarQueryParameter['fields[item]'] = Array.from(fieldsItem).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search in all names and descriptions of consumable items with a query.
         * @summary Search Consumables
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {string} query case sensitive search query
         * @param {string} [filterTypeName] only results with the translated type name
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsConsumablesSearch: async (language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', query: string, filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getItemsConsumablesSearch', 'language', language)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getItemsConsumablesSearch', 'game', game)
            // verify required parameter 'query' is not null or undefined
            assertParamExists('getItemsConsumablesSearch', 'query', query)
            const localVarPath = `/{game}/{language}/items/consumables/search`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (filterTypeName !== undefined) {
                localVarQueryParameter['filter[type_name]'] = filterTypeName;
            }

            if (filterMinLevel !== undefined) {
                localVarQueryParameter['filter[min_level]'] = filterMinLevel;
            }

            if (filterMaxLevel !== undefined) {
                localVarQueryParameter['filter[max_level]'] = filterMaxLevel;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific consumable item with id.
         * @summary Single Consumables
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {number} ankamaId identifier
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsConsumablesSingle: async (language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', ankamaId: number, game: 'dofus2' | 'dofus2beta', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getItemsConsumablesSingle', 'language', language)
            // verify required parameter 'ankamaId' is not null or undefined
            assertParamExists('getItemsConsumablesSingle', 'ankamaId', ankamaId)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getItemsConsumablesSingle', 'game', game)
            const localVarPath = `/{game}/{language}/items/consumables/{ankama_id}`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"ankama_id"}}`, encodeURIComponent(String(ankamaId)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConsumablesApi - functional programming interface
 * @export
 */
export const ConsumablesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConsumablesApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve all consumable items with one request. This endpoint is just an alias for the a list with disabled pagination (page[size]=-1) and all fields[type] set.  If you want everything unfiltered, delete the other query parameters.  Be careful with testing or (god forbid) using /all in your browser, the returned json is huge and will slow down the browser!  Tip: set the HTTP Header \'Accept-Encoding: gzip\' for saving bandwidth. You will need to uncompress it on your end. Example with cURL: ``` curl -sH \'Accept-Encoding: gzip\' <api-endpoint> | gunzip - ```
         * @summary List All Consumables
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {'asc' | 'desc'} [sortLevel] sort the resulting list by level, default unsorted
         * @param {string} [filterTypeName] only results with the translated type name
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {'gzip'} [acceptEncoding] optional compression for saving bandwidth
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllItemsConsumablesList(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', sortLevel?: 'asc' | 'desc', filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, acceptEncoding?: 'gzip', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemsListPaged>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllItemsConsumablesList(language, game, sortLevel, filterTypeName, filterMinLevel, filterMaxLevel, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a list of consumable items.
         * @summary List Consumables
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {'asc' | 'desc'} [sortLevel] sort the resulting list by level, default unsorted
         * @param {string} [filterTypeName] only results with the translated type name
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {number} [pageSize] size of the results from the list. -1 disables pagination and gets all in one response.
         * @param {number} [pageNumber] page number based on the current page[size]. So you could get page 1 with 8 entrys and page 2 would have entries 8 to 16.
         * @param {Set<'recipe' | 'description' | 'conditions' | 'effects'>} [fieldsItem] adds fields from their detail endpoint to the item list entries. Multiple comma separated values allowed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemsConsumablesList(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', sortLevel?: 'asc' | 'desc', filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, pageSize?: number, pageNumber?: number, fieldsItem?: Set<'recipe' | 'description' | 'conditions' | 'effects'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemsListPaged>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemsConsumablesList(language, game, sortLevel, filterTypeName, filterMinLevel, filterMaxLevel, pageSize, pageNumber, fieldsItem, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Search in all names and descriptions of consumable items with a query.
         * @summary Search Consumables
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {string} query case sensitive search query
         * @param {string} [filterTypeName] only results with the translated type name
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemsConsumablesSearch(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', query: string, filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ItemListEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemsConsumablesSearch(language, game, query, filterTypeName, filterMinLevel, filterMaxLevel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a specific consumable item with id.
         * @summary Single Consumables
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {number} ankamaId identifier
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemsConsumablesSingle(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', ankamaId: number, game: 'dofus2' | 'dofus2beta', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Resource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemsConsumablesSingle(language, ankamaId, game, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ConsumablesApi - factory interface
 * @export
 */
export const ConsumablesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConsumablesApiFp(configuration)
    return {
        /**
         * Retrieve all consumable items with one request. This endpoint is just an alias for the a list with disabled pagination (page[size]=-1) and all fields[type] set.  If you want everything unfiltered, delete the other query parameters.  Be careful with testing or (god forbid) using /all in your browser, the returned json is huge and will slow down the browser!  Tip: set the HTTP Header \'Accept-Encoding: gzip\' for saving bandwidth. You will need to uncompress it on your end. Example with cURL: ``` curl -sH \'Accept-Encoding: gzip\' <api-endpoint> | gunzip - ```
         * @summary List All Consumables
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {'asc' | 'desc'} [sortLevel] sort the resulting list by level, default unsorted
         * @param {string} [filterTypeName] only results with the translated type name
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {'gzip'} [acceptEncoding] optional compression for saving bandwidth
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllItemsConsumablesList(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', sortLevel?: 'asc' | 'desc', filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, acceptEncoding?: 'gzip', options?: any): AxiosPromise<ItemsListPaged> {
            return localVarFp.getAllItemsConsumablesList(language, game, sortLevel, filterTypeName, filterMinLevel, filterMaxLevel, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of consumable items.
         * @summary List Consumables
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {'asc' | 'desc'} [sortLevel] sort the resulting list by level, default unsorted
         * @param {string} [filterTypeName] only results with the translated type name
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {number} [pageSize] size of the results from the list. -1 disables pagination and gets all in one response.
         * @param {number} [pageNumber] page number based on the current page[size]. So you could get page 1 with 8 entrys and page 2 would have entries 8 to 16.
         * @param {Set<'recipe' | 'description' | 'conditions' | 'effects'>} [fieldsItem] adds fields from their detail endpoint to the item list entries. Multiple comma separated values allowed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsConsumablesList(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', sortLevel?: 'asc' | 'desc', filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, pageSize?: number, pageNumber?: number, fieldsItem?: Set<'recipe' | 'description' | 'conditions' | 'effects'>, options?: any): AxiosPromise<ItemsListPaged> {
            return localVarFp.getItemsConsumablesList(language, game, sortLevel, filterTypeName, filterMinLevel, filterMaxLevel, pageSize, pageNumber, fieldsItem, options).then((request) => request(axios, basePath));
        },
        /**
         * Search in all names and descriptions of consumable items with a query.
         * @summary Search Consumables
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {string} query case sensitive search query
         * @param {string} [filterTypeName] only results with the translated type name
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsConsumablesSearch(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', query: string, filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, options?: any): AxiosPromise<Array<ItemListEntry>> {
            return localVarFp.getItemsConsumablesSearch(language, game, query, filterTypeName, filterMinLevel, filterMaxLevel, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific consumable item with id.
         * @summary Single Consumables
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {number} ankamaId identifier
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsConsumablesSingle(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', ankamaId: number, game: 'dofus2' | 'dofus2beta', options?: any): AxiosPromise<Resource> {
            return localVarFp.getItemsConsumablesSingle(language, ankamaId, game, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConsumablesApi - object-oriented interface
 * @export
 * @class ConsumablesApi
 * @extends {BaseAPI}
 */
export class ConsumablesApi extends BaseAPI {
    /**
     * Retrieve all consumable items with one request. This endpoint is just an alias for the a list with disabled pagination (page[size]=-1) and all fields[type] set.  If you want everything unfiltered, delete the other query parameters.  Be careful with testing or (god forbid) using /all in your browser, the returned json is huge and will slow down the browser!  Tip: set the HTTP Header \'Accept-Encoding: gzip\' for saving bandwidth. You will need to uncompress it on your end. Example with cURL: ``` curl -sH \'Accept-Encoding: gzip\' <api-endpoint> | gunzip - ```
     * @summary List All Consumables
     * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
     * @param {'dofus2' | 'dofus2beta'} game 
     * @param {'asc' | 'desc'} [sortLevel] sort the resulting list by level, default unsorted
     * @param {string} [filterTypeName] only results with the translated type name
     * @param {number} [filterMinLevel] only results which level is equal or above this value
     * @param {number} [filterMaxLevel] only results which level is equal or below this value
     * @param {'gzip'} [acceptEncoding] optional compression for saving bandwidth
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsumablesApi
     */
    public getAllItemsConsumablesList(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', sortLevel?: 'asc' | 'desc', filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, acceptEncoding?: 'gzip', options?: AxiosRequestConfig) {
        return ConsumablesApiFp(this.configuration).getAllItemsConsumablesList(language, game, sortLevel, filterTypeName, filterMinLevel, filterMaxLevel, acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of consumable items.
     * @summary List Consumables
     * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
     * @param {'dofus2' | 'dofus2beta'} game 
     * @param {'asc' | 'desc'} [sortLevel] sort the resulting list by level, default unsorted
     * @param {string} [filterTypeName] only results with the translated type name
     * @param {number} [filterMinLevel] only results which level is equal or above this value
     * @param {number} [filterMaxLevel] only results which level is equal or below this value
     * @param {number} [pageSize] size of the results from the list. -1 disables pagination and gets all in one response.
     * @param {number} [pageNumber] page number based on the current page[size]. So you could get page 1 with 8 entrys and page 2 would have entries 8 to 16.
     * @param {Set<'recipe' | 'description' | 'conditions' | 'effects'>} [fieldsItem] adds fields from their detail endpoint to the item list entries. Multiple comma separated values allowed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsumablesApi
     */
    public getItemsConsumablesList(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', sortLevel?: 'asc' | 'desc', filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, pageSize?: number, pageNumber?: number, fieldsItem?: Set<'recipe' | 'description' | 'conditions' | 'effects'>, options?: AxiosRequestConfig) {
        return ConsumablesApiFp(this.configuration).getItemsConsumablesList(language, game, sortLevel, filterTypeName, filterMinLevel, filterMaxLevel, pageSize, pageNumber, fieldsItem, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search in all names and descriptions of consumable items with a query.
     * @summary Search Consumables
     * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
     * @param {'dofus2' | 'dofus2beta'} game 
     * @param {string} query case sensitive search query
     * @param {string} [filterTypeName] only results with the translated type name
     * @param {number} [filterMinLevel] only results which level is equal or above this value
     * @param {number} [filterMaxLevel] only results which level is equal or below this value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsumablesApi
     */
    public getItemsConsumablesSearch(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', query: string, filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, options?: AxiosRequestConfig) {
        return ConsumablesApiFp(this.configuration).getItemsConsumablesSearch(language, game, query, filterTypeName, filterMinLevel, filterMaxLevel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific consumable item with id.
     * @summary Single Consumables
     * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
     * @param {number} ankamaId identifier
     * @param {'dofus2' | 'dofus2beta'} game 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsumablesApi
     */
    public getItemsConsumablesSingle(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', ankamaId: number, game: 'dofus2' | 'dofus2beta', options?: AxiosRequestConfig) {
        return ConsumablesApiFp(this.configuration).getItemsConsumablesSingle(language, ankamaId, game, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CosmeticsApi - axios parameter creator
 * @export
 */
export const CosmeticsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve all cosmetic items with one request. This endpoint is just an alias for the a list with disabled pagination (page[size]=-1) and all fields[type] set.  If you want everything unfiltered, delete the other query parameters.  Be careful with testing or (god forbid) using /all in your browser, the returned json is huge and will slow down the browser!  Tip: set the HTTP Header \'Accept-Encoding: gzip\' for saving bandwidth. You will need to uncompress it on your end. Example with cURL: ``` curl -sH \'Accept-Encoding: gzip\' <api-endpoint> | gunzip - ```
         * @summary List All Cosmetics
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {'asc' | 'desc'} [sortLevel] sort the resulting list by level, default unsorted
         * @param {string} [filterTypeName] only results with the translated type name
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {'gzip'} [acceptEncoding] optional compression for saving bandwidth
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCosmeticsList: async (language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', sortLevel?: 'asc' | 'desc', filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, acceptEncoding?: 'gzip', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getAllCosmeticsList', 'language', language)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getAllCosmeticsList', 'game', game)
            const localVarPath = `/{game}/{language}/items/cosmetics/all`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sortLevel !== undefined) {
                localVarQueryParameter['sort[level]'] = sortLevel;
            }

            if (filterTypeName !== undefined) {
                localVarQueryParameter['filter[type_name]'] = filterTypeName;
            }

            if (filterMinLevel !== undefined) {
                localVarQueryParameter['filter[min_level]'] = filterMinLevel;
            }

            if (filterMaxLevel !== undefined) {
                localVarQueryParameter['filter[max_level]'] = filterMaxLevel;
            }

            if (acceptEncoding != null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of cosmetic items.
         * @summary List Cosmetics
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {'asc' | 'desc'} [sortLevel] sort the resulting list by level, default unsorted
         * @param {string} [filterTypeName] only results with the translated type name
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {number} [pageSize] size of the results from the list. -1 disables pagination and gets all in one response.
         * @param {number} [pageNumber] page number based on the current page[size]. So you could get page 1 with 8 entrys and page 2 would have entries 8 to 16.
         * @param {Set<'recipe' | 'description' | 'conditions' | 'effects'>} [fieldsItem] adds fields from their detail endpoint to the item list entries. Multiple comma separated values allowed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCosmeticsList: async (language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', sortLevel?: 'asc' | 'desc', filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, pageSize?: number, pageNumber?: number, fieldsItem?: Set<'recipe' | 'description' | 'conditions' | 'effects'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getCosmeticsList', 'language', language)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getCosmeticsList', 'game', game)
            const localVarPath = `/{game}/{language}/items/cosmetics`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sortLevel !== undefined) {
                localVarQueryParameter['sort[level]'] = sortLevel;
            }

            if (filterTypeName !== undefined) {
                localVarQueryParameter['filter[type_name]'] = filterTypeName;
            }

            if (filterMinLevel !== undefined) {
                localVarQueryParameter['filter[min_level]'] = filterMinLevel;
            }

            if (filterMaxLevel !== undefined) {
                localVarQueryParameter['filter[max_level]'] = filterMaxLevel;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page[size]'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['page[number]'] = pageNumber;
            }

            if (fieldsItem) {
                localVarQueryParameter['fields[item]'] = Array.from(fieldsItem).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search in all names and descriptions of cosmetic items with a query.
         * @summary Search Cosmetics
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {string} query case sensitive search query
         * @param {string} [filterTypeName] only results with the translated type name
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCosmeticsSearch: async (language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', query: string, filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getCosmeticsSearch', 'language', language)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getCosmeticsSearch', 'game', game)
            // verify required parameter 'query' is not null or undefined
            assertParamExists('getCosmeticsSearch', 'query', query)
            const localVarPath = `/{game}/{language}/items/cosmetics/search`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (filterTypeName !== undefined) {
                localVarQueryParameter['filter[type_name]'] = filterTypeName;
            }

            if (filterMinLevel !== undefined) {
                localVarQueryParameter['filter[min_level]'] = filterMinLevel;
            }

            if (filterMaxLevel !== undefined) {
                localVarQueryParameter['filter[max_level]'] = filterMaxLevel;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific cosmetic item with id.
         * @summary Single Cosmetics
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {number} ankamaId identifier
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCosmeticsSingle: async (language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', ankamaId: number, game: 'dofus2' | 'dofus2beta', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getCosmeticsSingle', 'language', language)
            // verify required parameter 'ankamaId' is not null or undefined
            assertParamExists('getCosmeticsSingle', 'ankamaId', ankamaId)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getCosmeticsSingle', 'game', game)
            const localVarPath = `/{game}/{language}/items/cosmetics/{ankama_id}`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"ankama_id"}}`, encodeURIComponent(String(ankamaId)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CosmeticsApi - functional programming interface
 * @export
 */
export const CosmeticsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CosmeticsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve all cosmetic items with one request. This endpoint is just an alias for the a list with disabled pagination (page[size]=-1) and all fields[type] set.  If you want everything unfiltered, delete the other query parameters.  Be careful with testing or (god forbid) using /all in your browser, the returned json is huge and will slow down the browser!  Tip: set the HTTP Header \'Accept-Encoding: gzip\' for saving bandwidth. You will need to uncompress it on your end. Example with cURL: ``` curl -sH \'Accept-Encoding: gzip\' <api-endpoint> | gunzip - ```
         * @summary List All Cosmetics
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {'asc' | 'desc'} [sortLevel] sort the resulting list by level, default unsorted
         * @param {string} [filterTypeName] only results with the translated type name
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {'gzip'} [acceptEncoding] optional compression for saving bandwidth
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllCosmeticsList(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', sortLevel?: 'asc' | 'desc', filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, acceptEncoding?: 'gzip', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemsListPaged>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllCosmeticsList(language, game, sortLevel, filterTypeName, filterMinLevel, filterMaxLevel, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a list of cosmetic items.
         * @summary List Cosmetics
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {'asc' | 'desc'} [sortLevel] sort the resulting list by level, default unsorted
         * @param {string} [filterTypeName] only results with the translated type name
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {number} [pageSize] size of the results from the list. -1 disables pagination and gets all in one response.
         * @param {number} [pageNumber] page number based on the current page[size]. So you could get page 1 with 8 entrys and page 2 would have entries 8 to 16.
         * @param {Set<'recipe' | 'description' | 'conditions' | 'effects'>} [fieldsItem] adds fields from their detail endpoint to the item list entries. Multiple comma separated values allowed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCosmeticsList(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', sortLevel?: 'asc' | 'desc', filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, pageSize?: number, pageNumber?: number, fieldsItem?: Set<'recipe' | 'description' | 'conditions' | 'effects'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemsListPaged>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCosmeticsList(language, game, sortLevel, filterTypeName, filterMinLevel, filterMaxLevel, pageSize, pageNumber, fieldsItem, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Search in all names and descriptions of cosmetic items with a query.
         * @summary Search Cosmetics
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {string} query case sensitive search query
         * @param {string} [filterTypeName] only results with the translated type name
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCosmeticsSearch(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', query: string, filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ItemListEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCosmeticsSearch(language, game, query, filterTypeName, filterMinLevel, filterMaxLevel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a specific cosmetic item with id.
         * @summary Single Cosmetics
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {number} ankamaId identifier
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCosmeticsSingle(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', ankamaId: number, game: 'dofus2' | 'dofus2beta', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cosmetic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCosmeticsSingle(language, ankamaId, game, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CosmeticsApi - factory interface
 * @export
 */
export const CosmeticsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CosmeticsApiFp(configuration)
    return {
        /**
         * Retrieve all cosmetic items with one request. This endpoint is just an alias for the a list with disabled pagination (page[size]=-1) and all fields[type] set.  If you want everything unfiltered, delete the other query parameters.  Be careful with testing or (god forbid) using /all in your browser, the returned json is huge and will slow down the browser!  Tip: set the HTTP Header \'Accept-Encoding: gzip\' for saving bandwidth. You will need to uncompress it on your end. Example with cURL: ``` curl -sH \'Accept-Encoding: gzip\' <api-endpoint> | gunzip - ```
         * @summary List All Cosmetics
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {'asc' | 'desc'} [sortLevel] sort the resulting list by level, default unsorted
         * @param {string} [filterTypeName] only results with the translated type name
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {'gzip'} [acceptEncoding] optional compression for saving bandwidth
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCosmeticsList(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', sortLevel?: 'asc' | 'desc', filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, acceptEncoding?: 'gzip', options?: any): AxiosPromise<ItemsListPaged> {
            return localVarFp.getAllCosmeticsList(language, game, sortLevel, filterTypeName, filterMinLevel, filterMaxLevel, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of cosmetic items.
         * @summary List Cosmetics
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {'asc' | 'desc'} [sortLevel] sort the resulting list by level, default unsorted
         * @param {string} [filterTypeName] only results with the translated type name
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {number} [pageSize] size of the results from the list. -1 disables pagination and gets all in one response.
         * @param {number} [pageNumber] page number based on the current page[size]. So you could get page 1 with 8 entrys and page 2 would have entries 8 to 16.
         * @param {Set<'recipe' | 'description' | 'conditions' | 'effects'>} [fieldsItem] adds fields from their detail endpoint to the item list entries. Multiple comma separated values allowed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCosmeticsList(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', sortLevel?: 'asc' | 'desc', filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, pageSize?: number, pageNumber?: number, fieldsItem?: Set<'recipe' | 'description' | 'conditions' | 'effects'>, options?: any): AxiosPromise<ItemsListPaged> {
            return localVarFp.getCosmeticsList(language, game, sortLevel, filterTypeName, filterMinLevel, filterMaxLevel, pageSize, pageNumber, fieldsItem, options).then((request) => request(axios, basePath));
        },
        /**
         * Search in all names and descriptions of cosmetic items with a query.
         * @summary Search Cosmetics
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {string} query case sensitive search query
         * @param {string} [filterTypeName] only results with the translated type name
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCosmeticsSearch(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', query: string, filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, options?: any): AxiosPromise<Array<ItemListEntry>> {
            return localVarFp.getCosmeticsSearch(language, game, query, filterTypeName, filterMinLevel, filterMaxLevel, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific cosmetic item with id.
         * @summary Single Cosmetics
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {number} ankamaId identifier
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCosmeticsSingle(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', ankamaId: number, game: 'dofus2' | 'dofus2beta', options?: any): AxiosPromise<Cosmetic> {
            return localVarFp.getCosmeticsSingle(language, ankamaId, game, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CosmeticsApi - object-oriented interface
 * @export
 * @class CosmeticsApi
 * @extends {BaseAPI}
 */
export class CosmeticsApi extends BaseAPI {
    /**
     * Retrieve all cosmetic items with one request. This endpoint is just an alias for the a list with disabled pagination (page[size]=-1) and all fields[type] set.  If you want everything unfiltered, delete the other query parameters.  Be careful with testing or (god forbid) using /all in your browser, the returned json is huge and will slow down the browser!  Tip: set the HTTP Header \'Accept-Encoding: gzip\' for saving bandwidth. You will need to uncompress it on your end. Example with cURL: ``` curl -sH \'Accept-Encoding: gzip\' <api-endpoint> | gunzip - ```
     * @summary List All Cosmetics
     * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
     * @param {'dofus2' | 'dofus2beta'} game 
     * @param {'asc' | 'desc'} [sortLevel] sort the resulting list by level, default unsorted
     * @param {string} [filterTypeName] only results with the translated type name
     * @param {number} [filterMinLevel] only results which level is equal or above this value
     * @param {number} [filterMaxLevel] only results which level is equal or below this value
     * @param {'gzip'} [acceptEncoding] optional compression for saving bandwidth
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CosmeticsApi
     */
    public getAllCosmeticsList(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', sortLevel?: 'asc' | 'desc', filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, acceptEncoding?: 'gzip', options?: AxiosRequestConfig) {
        return CosmeticsApiFp(this.configuration).getAllCosmeticsList(language, game, sortLevel, filterTypeName, filterMinLevel, filterMaxLevel, acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of cosmetic items.
     * @summary List Cosmetics
     * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
     * @param {'dofus2' | 'dofus2beta'} game 
     * @param {'asc' | 'desc'} [sortLevel] sort the resulting list by level, default unsorted
     * @param {string} [filterTypeName] only results with the translated type name
     * @param {number} [filterMinLevel] only results which level is equal or above this value
     * @param {number} [filterMaxLevel] only results which level is equal or below this value
     * @param {number} [pageSize] size of the results from the list. -1 disables pagination and gets all in one response.
     * @param {number} [pageNumber] page number based on the current page[size]. So you could get page 1 with 8 entrys and page 2 would have entries 8 to 16.
     * @param {Set<'recipe' | 'description' | 'conditions' | 'effects'>} [fieldsItem] adds fields from their detail endpoint to the item list entries. Multiple comma separated values allowed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CosmeticsApi
     */
    public getCosmeticsList(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', sortLevel?: 'asc' | 'desc', filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, pageSize?: number, pageNumber?: number, fieldsItem?: Set<'recipe' | 'description' | 'conditions' | 'effects'>, options?: AxiosRequestConfig) {
        return CosmeticsApiFp(this.configuration).getCosmeticsList(language, game, sortLevel, filterTypeName, filterMinLevel, filterMaxLevel, pageSize, pageNumber, fieldsItem, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search in all names and descriptions of cosmetic items with a query.
     * @summary Search Cosmetics
     * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
     * @param {'dofus2' | 'dofus2beta'} game 
     * @param {string} query case sensitive search query
     * @param {string} [filterTypeName] only results with the translated type name
     * @param {number} [filterMinLevel] only results which level is equal or above this value
     * @param {number} [filterMaxLevel] only results which level is equal or below this value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CosmeticsApi
     */
    public getCosmeticsSearch(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', query: string, filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, options?: AxiosRequestConfig) {
        return CosmeticsApiFp(this.configuration).getCosmeticsSearch(language, game, query, filterTypeName, filterMinLevel, filterMaxLevel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific cosmetic item with id.
     * @summary Single Cosmetics
     * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
     * @param {number} ankamaId identifier
     * @param {'dofus2' | 'dofus2beta'} game 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CosmeticsApi
     */
    public getCosmeticsSingle(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', ankamaId: number, game: 'dofus2' | 'dofus2beta', options?: AxiosRequestConfig) {
        return CosmeticsApiFp(this.configuration).getCosmeticsSingle(language, ankamaId, game, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EquipmentApi - axios parameter creator
 * @export
 */
export const EquipmentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve all equipment items with one request. This endpoint is just an alias for the a list with disabled pagination (page[size]=-1) and all fields[type] set.  If you want everything unfiltered, delete the other query parameters.  Be careful with testing or (god forbid) using /all in your browser, the returned json is huge and will slow down the browser!  Tip: set the HTTP Header \'Accept-Encoding: gzip\' for saving bandwidth. You will need to uncompress it on your end. Example with cURL: ``` curl -sH \'Accept-Encoding: gzip\' <api-endpoint> | gunzip - ```
         * @summary List All Equipment
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {'asc' | 'desc'} [sortLevel] sort the resulting list by level, default unsorted
         * @param {string} [filterTypeName] only results with the translated type name
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {'gzip'} [acceptEncoding] optional compression for saving bandwidth
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllItemsEquipmentList: async (language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', sortLevel?: 'asc' | 'desc', filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, acceptEncoding?: 'gzip', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getAllItemsEquipmentList', 'language', language)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getAllItemsEquipmentList', 'game', game)
            const localVarPath = `/{game}/{language}/items/equipment/all`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sortLevel !== undefined) {
                localVarQueryParameter['sort[level]'] = sortLevel;
            }

            if (filterTypeName !== undefined) {
                localVarQueryParameter['filter[type_name]'] = filterTypeName;
            }

            if (filterMinLevel !== undefined) {
                localVarQueryParameter['filter[min_level]'] = filterMinLevel;
            }

            if (filterMaxLevel !== undefined) {
                localVarQueryParameter['filter[max_level]'] = filterMaxLevel;
            }

            if (acceptEncoding != null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of equipment items.
         * @summary List Equipment
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {'asc' | 'desc'} [sortLevel] sort the resulting list by level, default unsorted
         * @param {string} [filterTypeName] only results with the translated type name
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {number} [pageSize] size of the results from the list. -1 disables pagination and gets all in one response.
         * @param {number} [pageNumber] page number based on the current page[size]. So you could get page 1 with 8 entrys and page 2 would have entries 8 to 16.
         * @param {Set<'recipe' | 'description' | 'conditions' | 'effects' | 'is_weapon' | 'pods' | 'parent_set' | 'critical_hit_probability' | 'critical_hit_bonus' | 'is_two_handed' | 'max_cast_per_turn' | 'ap_cost' | 'range'>} [fieldsItem] adds fields from their detail endpoint to the item list entries. Multiple comma separated values allowed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsEquipmentList: async (language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', sortLevel?: 'asc' | 'desc', filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, pageSize?: number, pageNumber?: number, fieldsItem?: Set<'recipe' | 'description' | 'conditions' | 'effects' | 'is_weapon' | 'pods' | 'parent_set' | 'critical_hit_probability' | 'critical_hit_bonus' | 'is_two_handed' | 'max_cast_per_turn' | 'ap_cost' | 'range'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getItemsEquipmentList', 'language', language)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getItemsEquipmentList', 'game', game)
            const localVarPath = `/{game}/{language}/items/equipment`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sortLevel !== undefined) {
                localVarQueryParameter['sort[level]'] = sortLevel;
            }

            if (filterTypeName !== undefined) {
                localVarQueryParameter['filter[type_name]'] = filterTypeName;
            }

            if (filterMinLevel !== undefined) {
                localVarQueryParameter['filter[min_level]'] = filterMinLevel;
            }

            if (filterMaxLevel !== undefined) {
                localVarQueryParameter['filter[max_level]'] = filterMaxLevel;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page[size]'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['page[number]'] = pageNumber;
            }

            if (fieldsItem) {
                localVarQueryParameter['fields[item]'] = Array.from(fieldsItem).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search in all names and descriptions of equipment items with a query.
         * @summary Search Equipment
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {string} query case sensitive search query
         * @param {string} [filterTypeName] only results with the translated type name
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsEquipmentSearch: async (language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', query: string, filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getItemsEquipmentSearch', 'language', language)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getItemsEquipmentSearch', 'game', game)
            // verify required parameter 'query' is not null or undefined
            assertParamExists('getItemsEquipmentSearch', 'query', query)
            const localVarPath = `/{game}/{language}/items/equipment/search`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (filterTypeName !== undefined) {
                localVarQueryParameter['filter[type_name]'] = filterTypeName;
            }

            if (filterMinLevel !== undefined) {
                localVarQueryParameter['filter[min_level]'] = filterMinLevel;
            }

            if (filterMaxLevel !== undefined) {
                localVarQueryParameter['filter[max_level]'] = filterMaxLevel;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific equipment item with id.
         * @summary Single Equipment
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {number} ankamaId identifier
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsEquipmentSingle: async (language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', ankamaId: number, game: 'dofus2' | 'dofus2beta', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getItemsEquipmentSingle', 'language', language)
            // verify required parameter 'ankamaId' is not null or undefined
            assertParamExists('getItemsEquipmentSingle', 'ankamaId', ankamaId)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getItemsEquipmentSingle', 'game', game)
            const localVarPath = `/{game}/{language}/items/equipment/{ankama_id}`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"ankama_id"}}`, encodeURIComponent(String(ankamaId)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EquipmentApi - functional programming interface
 * @export
 */
export const EquipmentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EquipmentApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve all equipment items with one request. This endpoint is just an alias for the a list with disabled pagination (page[size]=-1) and all fields[type] set.  If you want everything unfiltered, delete the other query parameters.  Be careful with testing or (god forbid) using /all in your browser, the returned json is huge and will slow down the browser!  Tip: set the HTTP Header \'Accept-Encoding: gzip\' for saving bandwidth. You will need to uncompress it on your end. Example with cURL: ``` curl -sH \'Accept-Encoding: gzip\' <api-endpoint> | gunzip - ```
         * @summary List All Equipment
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {'asc' | 'desc'} [sortLevel] sort the resulting list by level, default unsorted
         * @param {string} [filterTypeName] only results with the translated type name
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {'gzip'} [acceptEncoding] optional compression for saving bandwidth
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllItemsEquipmentList(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', sortLevel?: 'asc' | 'desc', filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, acceptEncoding?: 'gzip', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemsListPaged>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllItemsEquipmentList(language, game, sortLevel, filterTypeName, filterMinLevel, filterMaxLevel, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a list of equipment items.
         * @summary List Equipment
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {'asc' | 'desc'} [sortLevel] sort the resulting list by level, default unsorted
         * @param {string} [filterTypeName] only results with the translated type name
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {number} [pageSize] size of the results from the list. -1 disables pagination and gets all in one response.
         * @param {number} [pageNumber] page number based on the current page[size]. So you could get page 1 with 8 entrys and page 2 would have entries 8 to 16.
         * @param {Set<'recipe' | 'description' | 'conditions' | 'effects' | 'is_weapon' | 'pods' | 'parent_set' | 'critical_hit_probability' | 'critical_hit_bonus' | 'is_two_handed' | 'max_cast_per_turn' | 'ap_cost' | 'range'>} [fieldsItem] adds fields from their detail endpoint to the item list entries. Multiple comma separated values allowed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemsEquipmentList(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', sortLevel?: 'asc' | 'desc', filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, pageSize?: number, pageNumber?: number, fieldsItem?: Set<'recipe' | 'description' | 'conditions' | 'effects' | 'is_weapon' | 'pods' | 'parent_set' | 'critical_hit_probability' | 'critical_hit_bonus' | 'is_two_handed' | 'max_cast_per_turn' | 'ap_cost' | 'range'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemsListPaged>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemsEquipmentList(language, game, sortLevel, filterTypeName, filterMinLevel, filterMaxLevel, pageSize, pageNumber, fieldsItem, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Search in all names and descriptions of equipment items with a query.
         * @summary Search Equipment
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {string} query case sensitive search query
         * @param {string} [filterTypeName] only results with the translated type name
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemsEquipmentSearch(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', query: string, filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ItemListEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemsEquipmentSearch(language, game, query, filterTypeName, filterMinLevel, filterMaxLevel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a specific equipment item with id.
         * @summary Single Equipment
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {number} ankamaId identifier
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemsEquipmentSingle(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', ankamaId: number, game: 'dofus2' | 'dofus2beta', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Weapon>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemsEquipmentSingle(language, ankamaId, game, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EquipmentApi - factory interface
 * @export
 */
export const EquipmentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EquipmentApiFp(configuration)
    return {
        /**
         * Retrieve all equipment items with one request. This endpoint is just an alias for the a list with disabled pagination (page[size]=-1) and all fields[type] set.  If you want everything unfiltered, delete the other query parameters.  Be careful with testing or (god forbid) using /all in your browser, the returned json is huge and will slow down the browser!  Tip: set the HTTP Header \'Accept-Encoding: gzip\' for saving bandwidth. You will need to uncompress it on your end. Example with cURL: ``` curl -sH \'Accept-Encoding: gzip\' <api-endpoint> | gunzip - ```
         * @summary List All Equipment
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {'asc' | 'desc'} [sortLevel] sort the resulting list by level, default unsorted
         * @param {string} [filterTypeName] only results with the translated type name
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {'gzip'} [acceptEncoding] optional compression for saving bandwidth
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllItemsEquipmentList(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', sortLevel?: 'asc' | 'desc', filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, acceptEncoding?: 'gzip', options?: any): AxiosPromise<ItemsListPaged> {
            return localVarFp.getAllItemsEquipmentList(language, game, sortLevel, filterTypeName, filterMinLevel, filterMaxLevel, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of equipment items.
         * @summary List Equipment
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {'asc' | 'desc'} [sortLevel] sort the resulting list by level, default unsorted
         * @param {string} [filterTypeName] only results with the translated type name
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {number} [pageSize] size of the results from the list. -1 disables pagination and gets all in one response.
         * @param {number} [pageNumber] page number based on the current page[size]. So you could get page 1 with 8 entrys and page 2 would have entries 8 to 16.
         * @param {Set<'recipe' | 'description' | 'conditions' | 'effects' | 'is_weapon' | 'pods' | 'parent_set' | 'critical_hit_probability' | 'critical_hit_bonus' | 'is_two_handed' | 'max_cast_per_turn' | 'ap_cost' | 'range'>} [fieldsItem] adds fields from their detail endpoint to the item list entries. Multiple comma separated values allowed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsEquipmentList(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', sortLevel?: 'asc' | 'desc', filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, pageSize?: number, pageNumber?: number, fieldsItem?: Set<'recipe' | 'description' | 'conditions' | 'effects' | 'is_weapon' | 'pods' | 'parent_set' | 'critical_hit_probability' | 'critical_hit_bonus' | 'is_two_handed' | 'max_cast_per_turn' | 'ap_cost' | 'range'>, options?: any): AxiosPromise<ItemsListPaged> {
            return localVarFp.getItemsEquipmentList(language, game, sortLevel, filterTypeName, filterMinLevel, filterMaxLevel, pageSize, pageNumber, fieldsItem, options).then((request) => request(axios, basePath));
        },
        /**
         * Search in all names and descriptions of equipment items with a query.
         * @summary Search Equipment
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {string} query case sensitive search query
         * @param {string} [filterTypeName] only results with the translated type name
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsEquipmentSearch(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', query: string, filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, options?: any): AxiosPromise<Array<ItemListEntry>> {
            return localVarFp.getItemsEquipmentSearch(language, game, query, filterTypeName, filterMinLevel, filterMaxLevel, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific equipment item with id.
         * @summary Single Equipment
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {number} ankamaId identifier
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsEquipmentSingle(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', ankamaId: number, game: 'dofus2' | 'dofus2beta', options?: any): AxiosPromise<Weapon> {
            return localVarFp.getItemsEquipmentSingle(language, ankamaId, game, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EquipmentApi - object-oriented interface
 * @export
 * @class EquipmentApi
 * @extends {BaseAPI}
 */
export class EquipmentApi extends BaseAPI {
    /**
     * Retrieve all equipment items with one request. This endpoint is just an alias for the a list with disabled pagination (page[size]=-1) and all fields[type] set.  If you want everything unfiltered, delete the other query parameters.  Be careful with testing or (god forbid) using /all in your browser, the returned json is huge and will slow down the browser!  Tip: set the HTTP Header \'Accept-Encoding: gzip\' for saving bandwidth. You will need to uncompress it on your end. Example with cURL: ``` curl -sH \'Accept-Encoding: gzip\' <api-endpoint> | gunzip - ```
     * @summary List All Equipment
     * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
     * @param {'dofus2' | 'dofus2beta'} game 
     * @param {'asc' | 'desc'} [sortLevel] sort the resulting list by level, default unsorted
     * @param {string} [filterTypeName] only results with the translated type name
     * @param {number} [filterMinLevel] only results which level is equal or above this value
     * @param {number} [filterMaxLevel] only results which level is equal or below this value
     * @param {'gzip'} [acceptEncoding] optional compression for saving bandwidth
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EquipmentApi
     */
    public getAllItemsEquipmentList(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', sortLevel?: 'asc' | 'desc', filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, acceptEncoding?: 'gzip', options?: AxiosRequestConfig) {
        return EquipmentApiFp(this.configuration).getAllItemsEquipmentList(language, game, sortLevel, filterTypeName, filterMinLevel, filterMaxLevel, acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of equipment items.
     * @summary List Equipment
     * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
     * @param {'dofus2' | 'dofus2beta'} game 
     * @param {'asc' | 'desc'} [sortLevel] sort the resulting list by level, default unsorted
     * @param {string} [filterTypeName] only results with the translated type name
     * @param {number} [filterMinLevel] only results which level is equal or above this value
     * @param {number} [filterMaxLevel] only results which level is equal or below this value
     * @param {number} [pageSize] size of the results from the list. -1 disables pagination and gets all in one response.
     * @param {number} [pageNumber] page number based on the current page[size]. So you could get page 1 with 8 entrys and page 2 would have entries 8 to 16.
     * @param {Set<'recipe' | 'description' | 'conditions' | 'effects' | 'is_weapon' | 'pods' | 'parent_set' | 'critical_hit_probability' | 'critical_hit_bonus' | 'is_two_handed' | 'max_cast_per_turn' | 'ap_cost' | 'range'>} [fieldsItem] adds fields from their detail endpoint to the item list entries. Multiple comma separated values allowed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EquipmentApi
     */
    public getItemsEquipmentList(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', sortLevel?: 'asc' | 'desc', filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, pageSize?: number, pageNumber?: number, fieldsItem?: Set<'recipe' | 'description' | 'conditions' | 'effects' | 'is_weapon' | 'pods' | 'parent_set' | 'critical_hit_probability' | 'critical_hit_bonus' | 'is_two_handed' | 'max_cast_per_turn' | 'ap_cost' | 'range'>, options?: AxiosRequestConfig) {
        return EquipmentApiFp(this.configuration).getItemsEquipmentList(language, game, sortLevel, filterTypeName, filterMinLevel, filterMaxLevel, pageSize, pageNumber, fieldsItem, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search in all names and descriptions of equipment items with a query.
     * @summary Search Equipment
     * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
     * @param {'dofus2' | 'dofus2beta'} game 
     * @param {string} query case sensitive search query
     * @param {string} [filterTypeName] only results with the translated type name
     * @param {number} [filterMinLevel] only results which level is equal or above this value
     * @param {number} [filterMaxLevel] only results which level is equal or below this value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EquipmentApi
     */
    public getItemsEquipmentSearch(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', query: string, filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, options?: AxiosRequestConfig) {
        return EquipmentApiFp(this.configuration).getItemsEquipmentSearch(language, game, query, filterTypeName, filterMinLevel, filterMaxLevel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific equipment item with id.
     * @summary Single Equipment
     * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
     * @param {number} ankamaId identifier
     * @param {'dofus2' | 'dofus2beta'} game 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EquipmentApi
     */
    public getItemsEquipmentSingle(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', ankamaId: number, game: 'dofus2' | 'dofus2beta', options?: AxiosRequestConfig) {
        return EquipmentApiFp(this.configuration).getItemsEquipmentSingle(language, ankamaId, game, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MetaApi - axios parameter creator
 * @export
 */
export const MetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all the available bonuses and their id for filtering them in the range endpoint.
         * @summary Available Almanax Bonuses
         * @param {'en' | 'fr' | 'de' | 'it' | 'es'} language 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetaAlmanaxBonuses: async (language: 'en' | 'fr' | 'de' | 'it' | 'es', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getMetaAlmanaxBonuses', 'language', language)
            const localVarPath = `/dofus2/meta/{language}/almanax/bonuses`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the mappings for all specific elements that are linked in the dataset. All names are english. Translations are not needed because of a global unique id which is the index inside the array. Future elements will get a higher id.
         * @summary Effects and Condition Elements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetaElements: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dofus2/meta/elements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetaApi - functional programming interface
 * @export
 */
export const MetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetaApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all the available bonuses and their id for filtering them in the range endpoint.
         * @summary Available Almanax Bonuses
         * @param {'en' | 'fr' | 'de' | 'it' | 'es'} language 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetaAlmanaxBonuses(language: 'en' | 'fr' | 'de' | 'it' | 'es', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetMetaAlmanaxBonuses200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetaAlmanaxBonuses(language, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the mappings for all specific elements that are linked in the dataset. All names are english. Translations are not needed because of a global unique id which is the index inside the array. Future elements will get a higher id.
         * @summary Effects and Condition Elements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetaElements(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetaElements(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MetaApi - factory interface
 * @export
 */
export const MetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetaApiFp(configuration)
    return {
        /**
         * Get all the available bonuses and their id for filtering them in the range endpoint.
         * @summary Available Almanax Bonuses
         * @param {'en' | 'fr' | 'de' | 'it' | 'es'} language 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetaAlmanaxBonuses(language: 'en' | 'fr' | 'de' | 'it' | 'es', options?: any): AxiosPromise<Array<GetMetaAlmanaxBonuses200ResponseInner>> {
            return localVarFp.getMetaAlmanaxBonuses(language, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the mappings for all specific elements that are linked in the dataset. All names are english. Translations are not needed because of a global unique id which is the index inside the array. Future elements will get a higher id.
         * @summary Effects and Condition Elements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetaElements(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getMetaElements(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetaApi - object-oriented interface
 * @export
 * @class MetaApi
 * @extends {BaseAPI}
 */
export class MetaApi extends BaseAPI {
    /**
     * Get all the available bonuses and their id for filtering them in the range endpoint.
     * @summary Available Almanax Bonuses
     * @param {'en' | 'fr' | 'de' | 'it' | 'es'} language 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetaApi
     */
    public getMetaAlmanaxBonuses(language: 'en' | 'fr' | 'de' | 'it' | 'es', options?: AxiosRequestConfig) {
        return MetaApiFp(this.configuration).getMetaAlmanaxBonuses(language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the mappings for all specific elements that are linked in the dataset. All names are english. Translations are not needed because of a global unique id which is the index inside the array. Future elements will get a higher id.
     * @summary Effects and Condition Elements
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetaApi
     */
    public getMetaElements(options?: AxiosRequestConfig) {
        return MetaApiFp(this.configuration).getMetaElements(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MountsApi - axios parameter creator
 * @export
 */
export const MountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve all mounts with one request. This endpoint is just an alias for the a list with disabled pagination (page[size]=-1) and all fields[type] set.  If you want everything unfiltered, delete the other query parameters.  Be careful with testing or (god forbid) using /all in your browser, the returned json is huge and will slow down the browser!  Tip: set the HTTP Header \'Accept-Encoding: gzip\' for saving bandwidth. You will need to uncompress it on your end. Example with cURL: ``` curl -sH \'Accept-Encoding: gzip\' <api-endpoint> | gunzip - ```
         * @summary List All Mounts
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {string} [filterFamilyName] only results with the translated family name
         * @param {'gzip'} [acceptEncoding] optional compression for saving bandwidth
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMountsList: async (language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', filterFamilyName?: string, acceptEncoding?: 'gzip', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getAllMountsList', 'language', language)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getAllMountsList', 'game', game)
            const localVarPath = `/{game}/{language}/mounts/all`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filterFamilyName !== undefined) {
                localVarQueryParameter['filter[family_name]'] = filterFamilyName;
            }

            if (acceptEncoding != null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of mounts.
         * @summary List Mounts
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {string} [filterFamilyName] only results with the translated family name
         * @param {number} [pageSize] size of the results from the list. -1 disables pagination and gets all in one response.
         * @param {number} [pageNumber] page number based on the current page[size]. So you could get page 1 with 8 entrys and page 2 would have entries 8 to 16.
         * @param {Set<'effects'>} [fieldsMount] adds fields from their detail endpoint to the item list entries. Multiple comma separated values allowed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMountsList: async (language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', filterFamilyName?: string, pageSize?: number, pageNumber?: number, fieldsMount?: Set<'effects'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getMountsList', 'language', language)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getMountsList', 'game', game)
            const localVarPath = `/{game}/{language}/mounts`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filterFamilyName !== undefined) {
                localVarQueryParameter['filter[family_name]'] = filterFamilyName;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page[size]'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['page[number]'] = pageNumber;
            }

            if (fieldsMount) {
                localVarQueryParameter['fields[mount]'] = Array.from(fieldsMount).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search in all names and descriptions of mounts with a query.
         * @summary Search Mounts
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {string} query case sensitive search query
         * @param {string} [filterFamilyName] only results with the translated family name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMountsSearch: async (language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', query: string, filterFamilyName?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getMountsSearch', 'language', language)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getMountsSearch', 'game', game)
            // verify required parameter 'query' is not null or undefined
            assertParamExists('getMountsSearch', 'query', query)
            const localVarPath = `/{game}/{language}/mounts/search`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (filterFamilyName !== undefined) {
                localVarQueryParameter['filter[family_name]'] = filterFamilyName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific mount with id.
         * @summary Single Mounts
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {number} ankamaId identifier
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMountsSingle: async (language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', ankamaId: number, game: 'dofus2' | 'dofus2beta', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getMountsSingle', 'language', language)
            // verify required parameter 'ankamaId' is not null or undefined
            assertParamExists('getMountsSingle', 'ankamaId', ankamaId)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getMountsSingle', 'game', game)
            const localVarPath = `/{game}/{language}/mounts/{ankama_id}`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"ankama_id"}}`, encodeURIComponent(String(ankamaId)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MountsApi - functional programming interface
 * @export
 */
export const MountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MountsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve all mounts with one request. This endpoint is just an alias for the a list with disabled pagination (page[size]=-1) and all fields[type] set.  If you want everything unfiltered, delete the other query parameters.  Be careful with testing or (god forbid) using /all in your browser, the returned json is huge and will slow down the browser!  Tip: set the HTTP Header \'Accept-Encoding: gzip\' for saving bandwidth. You will need to uncompress it on your end. Example with cURL: ``` curl -sH \'Accept-Encoding: gzip\' <api-endpoint> | gunzip - ```
         * @summary List All Mounts
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {string} [filterFamilyName] only results with the translated family name
         * @param {'gzip'} [acceptEncoding] optional compression for saving bandwidth
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllMountsList(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', filterFamilyName?: string, acceptEncoding?: 'gzip', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MountsListPaged>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllMountsList(language, game, filterFamilyName, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a list of mounts.
         * @summary List Mounts
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {string} [filterFamilyName] only results with the translated family name
         * @param {number} [pageSize] size of the results from the list. -1 disables pagination and gets all in one response.
         * @param {number} [pageNumber] page number based on the current page[size]. So you could get page 1 with 8 entrys and page 2 would have entries 8 to 16.
         * @param {Set<'effects'>} [fieldsMount] adds fields from their detail endpoint to the item list entries. Multiple comma separated values allowed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMountsList(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', filterFamilyName?: string, pageSize?: number, pageNumber?: number, fieldsMount?: Set<'effects'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MountsListPaged>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMountsList(language, game, filterFamilyName, pageSize, pageNumber, fieldsMount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Search in all names and descriptions of mounts with a query.
         * @summary Search Mounts
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {string} query case sensitive search query
         * @param {string} [filterFamilyName] only results with the translated family name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMountsSearch(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', query: string, filterFamilyName?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MountListEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMountsSearch(language, game, query, filterFamilyName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a specific mount with id.
         * @summary Single Mounts
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {number} ankamaId identifier
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMountsSingle(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', ankamaId: number, game: 'dofus2' | 'dofus2beta', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Mount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMountsSingle(language, ankamaId, game, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MountsApi - factory interface
 * @export
 */
export const MountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MountsApiFp(configuration)
    return {
        /**
         * Retrieve all mounts with one request. This endpoint is just an alias for the a list with disabled pagination (page[size]=-1) and all fields[type] set.  If you want everything unfiltered, delete the other query parameters.  Be careful with testing or (god forbid) using /all in your browser, the returned json is huge and will slow down the browser!  Tip: set the HTTP Header \'Accept-Encoding: gzip\' for saving bandwidth. You will need to uncompress it on your end. Example with cURL: ``` curl -sH \'Accept-Encoding: gzip\' <api-endpoint> | gunzip - ```
         * @summary List All Mounts
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {string} [filterFamilyName] only results with the translated family name
         * @param {'gzip'} [acceptEncoding] optional compression for saving bandwidth
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMountsList(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', filterFamilyName?: string, acceptEncoding?: 'gzip', options?: any): AxiosPromise<MountsListPaged> {
            return localVarFp.getAllMountsList(language, game, filterFamilyName, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of mounts.
         * @summary List Mounts
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {string} [filterFamilyName] only results with the translated family name
         * @param {number} [pageSize] size of the results from the list. -1 disables pagination and gets all in one response.
         * @param {number} [pageNumber] page number based on the current page[size]. So you could get page 1 with 8 entrys and page 2 would have entries 8 to 16.
         * @param {Set<'effects'>} [fieldsMount] adds fields from their detail endpoint to the item list entries. Multiple comma separated values allowed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMountsList(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', filterFamilyName?: string, pageSize?: number, pageNumber?: number, fieldsMount?: Set<'effects'>, options?: any): AxiosPromise<MountsListPaged> {
            return localVarFp.getMountsList(language, game, filterFamilyName, pageSize, pageNumber, fieldsMount, options).then((request) => request(axios, basePath));
        },
        /**
         * Search in all names and descriptions of mounts with a query.
         * @summary Search Mounts
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {string} query case sensitive search query
         * @param {string} [filterFamilyName] only results with the translated family name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMountsSearch(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', query: string, filterFamilyName?: string, options?: any): AxiosPromise<Array<MountListEntry>> {
            return localVarFp.getMountsSearch(language, game, query, filterFamilyName, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific mount with id.
         * @summary Single Mounts
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {number} ankamaId identifier
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMountsSingle(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', ankamaId: number, game: 'dofus2' | 'dofus2beta', options?: any): AxiosPromise<Mount> {
            return localVarFp.getMountsSingle(language, ankamaId, game, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MountsApi - object-oriented interface
 * @export
 * @class MountsApi
 * @extends {BaseAPI}
 */
export class MountsApi extends BaseAPI {
    /**
     * Retrieve all mounts with one request. This endpoint is just an alias for the a list with disabled pagination (page[size]=-1) and all fields[type] set.  If you want everything unfiltered, delete the other query parameters.  Be careful with testing or (god forbid) using /all in your browser, the returned json is huge and will slow down the browser!  Tip: set the HTTP Header \'Accept-Encoding: gzip\' for saving bandwidth. You will need to uncompress it on your end. Example with cURL: ``` curl -sH \'Accept-Encoding: gzip\' <api-endpoint> | gunzip - ```
     * @summary List All Mounts
     * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
     * @param {'dofus2' | 'dofus2beta'} game 
     * @param {string} [filterFamilyName] only results with the translated family name
     * @param {'gzip'} [acceptEncoding] optional compression for saving bandwidth
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MountsApi
     */
    public getAllMountsList(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', filterFamilyName?: string, acceptEncoding?: 'gzip', options?: AxiosRequestConfig) {
        return MountsApiFp(this.configuration).getAllMountsList(language, game, filterFamilyName, acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of mounts.
     * @summary List Mounts
     * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
     * @param {'dofus2' | 'dofus2beta'} game 
     * @param {string} [filterFamilyName] only results with the translated family name
     * @param {number} [pageSize] size of the results from the list. -1 disables pagination and gets all in one response.
     * @param {number} [pageNumber] page number based on the current page[size]. So you could get page 1 with 8 entrys and page 2 would have entries 8 to 16.
     * @param {Set<'effects'>} [fieldsMount] adds fields from their detail endpoint to the item list entries. Multiple comma separated values allowed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MountsApi
     */
    public getMountsList(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', filterFamilyName?: string, pageSize?: number, pageNumber?: number, fieldsMount?: Set<'effects'>, options?: AxiosRequestConfig) {
        return MountsApiFp(this.configuration).getMountsList(language, game, filterFamilyName, pageSize, pageNumber, fieldsMount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search in all names and descriptions of mounts with a query.
     * @summary Search Mounts
     * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
     * @param {'dofus2' | 'dofus2beta'} game 
     * @param {string} query case sensitive search query
     * @param {string} [filterFamilyName] only results with the translated family name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MountsApi
     */
    public getMountsSearch(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', query: string, filterFamilyName?: string, options?: AxiosRequestConfig) {
        return MountsApiFp(this.configuration).getMountsSearch(language, game, query, filterFamilyName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific mount with id.
     * @summary Single Mounts
     * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
     * @param {number} ankamaId identifier
     * @param {'dofus2' | 'dofus2beta'} game 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MountsApi
     */
    public getMountsSingle(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', ankamaId: number, game: 'dofus2' | 'dofus2beta', options?: AxiosRequestConfig) {
        return MountsApiFp(this.configuration).getMountsSingle(language, ankamaId, game, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * QuestItemsApi - axios parameter creator
 * @export
 */
export const QuestItemsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve all quest items with one request. This endpoint is just an alias for the a list with disabled pagination (page[size]=-1) and all fields[type] set.  If you want everything unfiltered, delete the other query parameters.  Be careful with testing or (god forbid) using /all in your browser, the returned json is huge and will slow down the browser!  Tip: set the HTTP Header \'Accept-Encoding: gzip\' for saving bandwidth. You will need to uncompress it on your end. Example with cURL: ``` curl -sH \'Accept-Encoding: gzip\' <api-endpoint> | gunzip - ```
         * @summary List All Quest Items
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {'asc' | 'desc'} [sortLevel] sort the resulting list by level, default unsorted
         * @param {string} [filterTypeName] only results with the translated type name
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {'gzip'} [acceptEncoding] optional compression for saving bandwidth
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllItemsQuestList: async (language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', sortLevel?: 'asc' | 'desc', filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, acceptEncoding?: 'gzip', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getAllItemsQuestList', 'language', language)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getAllItemsQuestList', 'game', game)
            const localVarPath = `/{game}/{language}/items/quest/all`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sortLevel !== undefined) {
                localVarQueryParameter['sort[level]'] = sortLevel;
            }

            if (filterTypeName !== undefined) {
                localVarQueryParameter['filter[type_name]'] = filterTypeName;
            }

            if (filterMinLevel !== undefined) {
                localVarQueryParameter['filter[min_level]'] = filterMinLevel;
            }

            if (filterMaxLevel !== undefined) {
                localVarQueryParameter['filter[max_level]'] = filterMaxLevel;
            }

            if (acceptEncoding != null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific quest item with id.
         * @summary Single Quest Items
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {number} ankamaId identifier
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemQuestSingle: async (language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', ankamaId: number, game: 'dofus2' | 'dofus2beta', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getItemQuestSingle', 'language', language)
            // verify required parameter 'ankamaId' is not null or undefined
            assertParamExists('getItemQuestSingle', 'ankamaId', ankamaId)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getItemQuestSingle', 'game', game)
            const localVarPath = `/{game}/{language}/items/quest/{ankama_id}`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"ankama_id"}}`, encodeURIComponent(String(ankamaId)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of quest items.
         * @summary List Quest Items
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {'asc' | 'desc'} [sortLevel] sort the resulting list by level, default unsorted
         * @param {string} [filterTypeName] only results with the translated type name
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {number} [pageSize] size of the results from the list. -1 disables pagination and gets all in one response.
         * @param {number} [pageNumber] page number based on the current page[size]. So you could get page 1 with 8 entrys and page 2 would have entries 8 to 16.
         * @param {Set<'recipe' | 'description' | 'conditions' | 'effects'>} [fieldsItem] adds fields from their detail endpoint to the item list entries. Multiple comma separated values allowed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsQuestList: async (language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', sortLevel?: 'asc' | 'desc', filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, pageSize?: number, pageNumber?: number, fieldsItem?: Set<'recipe' | 'description' | 'conditions' | 'effects'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getItemsQuestList', 'language', language)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getItemsQuestList', 'game', game)
            const localVarPath = `/{game}/{language}/items/quest`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sortLevel !== undefined) {
                localVarQueryParameter['sort[level]'] = sortLevel;
            }

            if (filterTypeName !== undefined) {
                localVarQueryParameter['filter[type_name]'] = filterTypeName;
            }

            if (filterMinLevel !== undefined) {
                localVarQueryParameter['filter[min_level]'] = filterMinLevel;
            }

            if (filterMaxLevel !== undefined) {
                localVarQueryParameter['filter[max_level]'] = filterMaxLevel;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page[size]'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['page[number]'] = pageNumber;
            }

            if (fieldsItem) {
                localVarQueryParameter['fields[item]'] = Array.from(fieldsItem).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search in all names and descriptions of quest items with a query.
         * @summary Search Quest Items
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {string} query case sensitive search query
         * @param {string} [filterTypeName] only results with the translated type name
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsQuestSearch: async (language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', query: string, filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getItemsQuestSearch', 'language', language)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getItemsQuestSearch', 'game', game)
            // verify required parameter 'query' is not null or undefined
            assertParamExists('getItemsQuestSearch', 'query', query)
            const localVarPath = `/{game}/{language}/items/quest/search`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (filterTypeName !== undefined) {
                localVarQueryParameter['filter[type_name]'] = filterTypeName;
            }

            if (filterMinLevel !== undefined) {
                localVarQueryParameter['filter[min_level]'] = filterMinLevel;
            }

            if (filterMaxLevel !== undefined) {
                localVarQueryParameter['filter[max_level]'] = filterMaxLevel;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuestItemsApi - functional programming interface
 * @export
 */
export const QuestItemsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QuestItemsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve all quest items with one request. This endpoint is just an alias for the a list with disabled pagination (page[size]=-1) and all fields[type] set.  If you want everything unfiltered, delete the other query parameters.  Be careful with testing or (god forbid) using /all in your browser, the returned json is huge and will slow down the browser!  Tip: set the HTTP Header \'Accept-Encoding: gzip\' for saving bandwidth. You will need to uncompress it on your end. Example with cURL: ``` curl -sH \'Accept-Encoding: gzip\' <api-endpoint> | gunzip - ```
         * @summary List All Quest Items
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {'asc' | 'desc'} [sortLevel] sort the resulting list by level, default unsorted
         * @param {string} [filterTypeName] only results with the translated type name
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {'gzip'} [acceptEncoding] optional compression for saving bandwidth
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllItemsQuestList(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', sortLevel?: 'asc' | 'desc', filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, acceptEncoding?: 'gzip', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemsListPaged>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllItemsQuestList(language, game, sortLevel, filterTypeName, filterMinLevel, filterMaxLevel, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a specific quest item with id.
         * @summary Single Quest Items
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {number} ankamaId identifier
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemQuestSingle(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', ankamaId: number, game: 'dofus2' | 'dofus2beta', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Resource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemQuestSingle(language, ankamaId, game, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a list of quest items.
         * @summary List Quest Items
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {'asc' | 'desc'} [sortLevel] sort the resulting list by level, default unsorted
         * @param {string} [filterTypeName] only results with the translated type name
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {number} [pageSize] size of the results from the list. -1 disables pagination and gets all in one response.
         * @param {number} [pageNumber] page number based on the current page[size]. So you could get page 1 with 8 entrys and page 2 would have entries 8 to 16.
         * @param {Set<'recipe' | 'description' | 'conditions' | 'effects'>} [fieldsItem] adds fields from their detail endpoint to the item list entries. Multiple comma separated values allowed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemsQuestList(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', sortLevel?: 'asc' | 'desc', filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, pageSize?: number, pageNumber?: number, fieldsItem?: Set<'recipe' | 'description' | 'conditions' | 'effects'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemsListPaged>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemsQuestList(language, game, sortLevel, filterTypeName, filterMinLevel, filterMaxLevel, pageSize, pageNumber, fieldsItem, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Search in all names and descriptions of quest items with a query.
         * @summary Search Quest Items
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {string} query case sensitive search query
         * @param {string} [filterTypeName] only results with the translated type name
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemsQuestSearch(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', query: string, filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ItemListEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemsQuestSearch(language, game, query, filterTypeName, filterMinLevel, filterMaxLevel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * QuestItemsApi - factory interface
 * @export
 */
export const QuestItemsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QuestItemsApiFp(configuration)
    return {
        /**
         * Retrieve all quest items with one request. This endpoint is just an alias for the a list with disabled pagination (page[size]=-1) and all fields[type] set.  If you want everything unfiltered, delete the other query parameters.  Be careful with testing or (god forbid) using /all in your browser, the returned json is huge and will slow down the browser!  Tip: set the HTTP Header \'Accept-Encoding: gzip\' for saving bandwidth. You will need to uncompress it on your end. Example with cURL: ``` curl -sH \'Accept-Encoding: gzip\' <api-endpoint> | gunzip - ```
         * @summary List All Quest Items
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {'asc' | 'desc'} [sortLevel] sort the resulting list by level, default unsorted
         * @param {string} [filterTypeName] only results with the translated type name
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {'gzip'} [acceptEncoding] optional compression for saving bandwidth
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllItemsQuestList(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', sortLevel?: 'asc' | 'desc', filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, acceptEncoding?: 'gzip', options?: any): AxiosPromise<ItemsListPaged> {
            return localVarFp.getAllItemsQuestList(language, game, sortLevel, filterTypeName, filterMinLevel, filterMaxLevel, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific quest item with id.
         * @summary Single Quest Items
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {number} ankamaId identifier
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemQuestSingle(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', ankamaId: number, game: 'dofus2' | 'dofus2beta', options?: any): AxiosPromise<Resource> {
            return localVarFp.getItemQuestSingle(language, ankamaId, game, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of quest items.
         * @summary List Quest Items
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {'asc' | 'desc'} [sortLevel] sort the resulting list by level, default unsorted
         * @param {string} [filterTypeName] only results with the translated type name
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {number} [pageSize] size of the results from the list. -1 disables pagination and gets all in one response.
         * @param {number} [pageNumber] page number based on the current page[size]. So you could get page 1 with 8 entrys and page 2 would have entries 8 to 16.
         * @param {Set<'recipe' | 'description' | 'conditions' | 'effects'>} [fieldsItem] adds fields from their detail endpoint to the item list entries. Multiple comma separated values allowed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsQuestList(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', sortLevel?: 'asc' | 'desc', filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, pageSize?: number, pageNumber?: number, fieldsItem?: Set<'recipe' | 'description' | 'conditions' | 'effects'>, options?: any): AxiosPromise<ItemsListPaged> {
            return localVarFp.getItemsQuestList(language, game, sortLevel, filterTypeName, filterMinLevel, filterMaxLevel, pageSize, pageNumber, fieldsItem, options).then((request) => request(axios, basePath));
        },
        /**
         * Search in all names and descriptions of quest items with a query.
         * @summary Search Quest Items
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {string} query case sensitive search query
         * @param {string} [filterTypeName] only results with the translated type name
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsQuestSearch(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', query: string, filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, options?: any): AxiosPromise<Array<ItemListEntry>> {
            return localVarFp.getItemsQuestSearch(language, game, query, filterTypeName, filterMinLevel, filterMaxLevel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QuestItemsApi - object-oriented interface
 * @export
 * @class QuestItemsApi
 * @extends {BaseAPI}
 */
export class QuestItemsApi extends BaseAPI {
    /**
     * Retrieve all quest items with one request. This endpoint is just an alias for the a list with disabled pagination (page[size]=-1) and all fields[type] set.  If you want everything unfiltered, delete the other query parameters.  Be careful with testing or (god forbid) using /all in your browser, the returned json is huge and will slow down the browser!  Tip: set the HTTP Header \'Accept-Encoding: gzip\' for saving bandwidth. You will need to uncompress it on your end. Example with cURL: ``` curl -sH \'Accept-Encoding: gzip\' <api-endpoint> | gunzip - ```
     * @summary List All Quest Items
     * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
     * @param {'dofus2' | 'dofus2beta'} game 
     * @param {'asc' | 'desc'} [sortLevel] sort the resulting list by level, default unsorted
     * @param {string} [filterTypeName] only results with the translated type name
     * @param {number} [filterMinLevel] only results which level is equal or above this value
     * @param {number} [filterMaxLevel] only results which level is equal or below this value
     * @param {'gzip'} [acceptEncoding] optional compression for saving bandwidth
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestItemsApi
     */
    public getAllItemsQuestList(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', sortLevel?: 'asc' | 'desc', filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, acceptEncoding?: 'gzip', options?: AxiosRequestConfig) {
        return QuestItemsApiFp(this.configuration).getAllItemsQuestList(language, game, sortLevel, filterTypeName, filterMinLevel, filterMaxLevel, acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific quest item with id.
     * @summary Single Quest Items
     * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
     * @param {number} ankamaId identifier
     * @param {'dofus2' | 'dofus2beta'} game 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestItemsApi
     */
    public getItemQuestSingle(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', ankamaId: number, game: 'dofus2' | 'dofus2beta', options?: AxiosRequestConfig) {
        return QuestItemsApiFp(this.configuration).getItemQuestSingle(language, ankamaId, game, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of quest items.
     * @summary List Quest Items
     * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
     * @param {'dofus2' | 'dofus2beta'} game 
     * @param {'asc' | 'desc'} [sortLevel] sort the resulting list by level, default unsorted
     * @param {string} [filterTypeName] only results with the translated type name
     * @param {number} [filterMinLevel] only results which level is equal or above this value
     * @param {number} [filterMaxLevel] only results which level is equal or below this value
     * @param {number} [pageSize] size of the results from the list. -1 disables pagination and gets all in one response.
     * @param {number} [pageNumber] page number based on the current page[size]. So you could get page 1 with 8 entrys and page 2 would have entries 8 to 16.
     * @param {Set<'recipe' | 'description' | 'conditions' | 'effects'>} [fieldsItem] adds fields from their detail endpoint to the item list entries. Multiple comma separated values allowed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestItemsApi
     */
    public getItemsQuestList(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', sortLevel?: 'asc' | 'desc', filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, pageSize?: number, pageNumber?: number, fieldsItem?: Set<'recipe' | 'description' | 'conditions' | 'effects'>, options?: AxiosRequestConfig) {
        return QuestItemsApiFp(this.configuration).getItemsQuestList(language, game, sortLevel, filterTypeName, filterMinLevel, filterMaxLevel, pageSize, pageNumber, fieldsItem, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search in all names and descriptions of quest items with a query.
     * @summary Search Quest Items
     * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
     * @param {'dofus2' | 'dofus2beta'} game 
     * @param {string} query case sensitive search query
     * @param {string} [filterTypeName] only results with the translated type name
     * @param {number} [filterMinLevel] only results which level is equal or above this value
     * @param {number} [filterMaxLevel] only results which level is equal or below this value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestItemsApi
     */
    public getItemsQuestSearch(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', query: string, filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, options?: AxiosRequestConfig) {
        return QuestItemsApiFp(this.configuration).getItemsQuestSearch(language, game, query, filterTypeName, filterMinLevel, filterMaxLevel, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ResourcesApi - axios parameter creator
 * @export
 */
export const ResourcesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve all resource items with one request. This endpoint is just an alias for the a list with disabled pagination (page[size]=-1) and all fields[type] set.  If you want everything unfiltered, delete the other query parameters.  Be careful with testing or (god forbid) using /all in your browser, the returned json is huge and will slow down the browser!  Tip: set the HTTP Header \'Accept-Encoding: gzip\' for saving bandwidth. You will need to uncompress it on your end. Example with cURL: ``` curl -sH \'Accept-Encoding: gzip\' <api-endpoint> | gunzip - ```
         * @summary List All Resources
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {'asc' | 'desc'} [sortLevel] sort the resulting list by level, default unsorted
         * @param {string} [filterTypeName] only results with the translated type name
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {'gzip'} [acceptEncoding] optional compression for saving bandwidth
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllItemsResourcesList: async (language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', sortLevel?: 'asc' | 'desc', filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, acceptEncoding?: 'gzip', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getAllItemsResourcesList', 'language', language)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getAllItemsResourcesList', 'game', game)
            const localVarPath = `/{game}/{language}/items/resources/all`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sortLevel !== undefined) {
                localVarQueryParameter['sort[level]'] = sortLevel;
            }

            if (filterTypeName !== undefined) {
                localVarQueryParameter['filter[type_name]'] = filterTypeName;
            }

            if (filterMinLevel !== undefined) {
                localVarQueryParameter['filter[min_level]'] = filterMinLevel;
            }

            if (filterMaxLevel !== undefined) {
                localVarQueryParameter['filter[max_level]'] = filterMaxLevel;
            }

            if (acceptEncoding != null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search in all names and descriptions of resource items with a query.
         * @summary Search Resources
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {string} query case sensitive search query
         * @param {string} [filterTypeName] only results with the translated type name
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsResourceSearch: async (language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', query: string, filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getItemsResourceSearch', 'language', language)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getItemsResourceSearch', 'game', game)
            // verify required parameter 'query' is not null or undefined
            assertParamExists('getItemsResourceSearch', 'query', query)
            const localVarPath = `/{game}/{language}/items/resources/search`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (filterTypeName !== undefined) {
                localVarQueryParameter['filter[type_name]'] = filterTypeName;
            }

            if (filterMinLevel !== undefined) {
                localVarQueryParameter['filter[min_level]'] = filterMinLevel;
            }

            if (filterMaxLevel !== undefined) {
                localVarQueryParameter['filter[max_level]'] = filterMaxLevel;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of resource items.
         * @summary List Resources
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {'asc' | 'desc'} [sortLevel] sort the resulting list by level, default unsorted
         * @param {string} [filterTypeName] only results with the translated type name
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {number} [pageSize] size of the results from the list. -1 disables pagination and gets all in one response.
         * @param {number} [pageNumber] page number based on the current page[size]. So you could get page 1 with 8 entrys and page 2 would have entries 8 to 16.
         * @param {Set<'recipe' | 'description' | 'conditions' | 'effects'>} [fieldsItem] adds fields from their detail endpoint to the item list entries. Multiple comma separated values allowed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsResourcesList: async (language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', sortLevel?: 'asc' | 'desc', filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, pageSize?: number, pageNumber?: number, fieldsItem?: Set<'recipe' | 'description' | 'conditions' | 'effects'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getItemsResourcesList', 'language', language)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getItemsResourcesList', 'game', game)
            const localVarPath = `/{game}/{language}/items/resources`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sortLevel !== undefined) {
                localVarQueryParameter['sort[level]'] = sortLevel;
            }

            if (filterTypeName !== undefined) {
                localVarQueryParameter['filter[type_name]'] = filterTypeName;
            }

            if (filterMinLevel !== undefined) {
                localVarQueryParameter['filter[min_level]'] = filterMinLevel;
            }

            if (filterMaxLevel !== undefined) {
                localVarQueryParameter['filter[max_level]'] = filterMaxLevel;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page[size]'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['page[number]'] = pageNumber;
            }

            if (fieldsItem) {
                localVarQueryParameter['fields[item]'] = Array.from(fieldsItem).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific resource item with id.
         * @summary Single Resources
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {number} ankamaId identifier
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsResourcesSingle: async (language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', ankamaId: number, game: 'dofus2' | 'dofus2beta', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getItemsResourcesSingle', 'language', language)
            // verify required parameter 'ankamaId' is not null or undefined
            assertParamExists('getItemsResourcesSingle', 'ankamaId', ankamaId)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getItemsResourcesSingle', 'game', game)
            const localVarPath = `/{game}/{language}/items/resources/{ankama_id}`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"ankama_id"}}`, encodeURIComponent(String(ankamaId)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResourcesApi - functional programming interface
 * @export
 */
export const ResourcesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResourcesApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve all resource items with one request. This endpoint is just an alias for the a list with disabled pagination (page[size]=-1) and all fields[type] set.  If you want everything unfiltered, delete the other query parameters.  Be careful with testing or (god forbid) using /all in your browser, the returned json is huge and will slow down the browser!  Tip: set the HTTP Header \'Accept-Encoding: gzip\' for saving bandwidth. You will need to uncompress it on your end. Example with cURL: ``` curl -sH \'Accept-Encoding: gzip\' <api-endpoint> | gunzip - ```
         * @summary List All Resources
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {'asc' | 'desc'} [sortLevel] sort the resulting list by level, default unsorted
         * @param {string} [filterTypeName] only results with the translated type name
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {'gzip'} [acceptEncoding] optional compression for saving bandwidth
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllItemsResourcesList(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', sortLevel?: 'asc' | 'desc', filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, acceptEncoding?: 'gzip', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemsListPaged>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllItemsResourcesList(language, game, sortLevel, filterTypeName, filterMinLevel, filterMaxLevel, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Search in all names and descriptions of resource items with a query.
         * @summary Search Resources
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {string} query case sensitive search query
         * @param {string} [filterTypeName] only results with the translated type name
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemsResourceSearch(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', query: string, filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ItemListEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemsResourceSearch(language, game, query, filterTypeName, filterMinLevel, filterMaxLevel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a list of resource items.
         * @summary List Resources
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {'asc' | 'desc'} [sortLevel] sort the resulting list by level, default unsorted
         * @param {string} [filterTypeName] only results with the translated type name
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {number} [pageSize] size of the results from the list. -1 disables pagination and gets all in one response.
         * @param {number} [pageNumber] page number based on the current page[size]. So you could get page 1 with 8 entrys and page 2 would have entries 8 to 16.
         * @param {Set<'recipe' | 'description' | 'conditions' | 'effects'>} [fieldsItem] adds fields from their detail endpoint to the item list entries. Multiple comma separated values allowed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemsResourcesList(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', sortLevel?: 'asc' | 'desc', filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, pageSize?: number, pageNumber?: number, fieldsItem?: Set<'recipe' | 'description' | 'conditions' | 'effects'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemsListPaged>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemsResourcesList(language, game, sortLevel, filterTypeName, filterMinLevel, filterMaxLevel, pageSize, pageNumber, fieldsItem, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a specific resource item with id.
         * @summary Single Resources
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {number} ankamaId identifier
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemsResourcesSingle(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', ankamaId: number, game: 'dofus2' | 'dofus2beta', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Resource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemsResourcesSingle(language, ankamaId, game, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ResourcesApi - factory interface
 * @export
 */
export const ResourcesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResourcesApiFp(configuration)
    return {
        /**
         * Retrieve all resource items with one request. This endpoint is just an alias for the a list with disabled pagination (page[size]=-1) and all fields[type] set.  If you want everything unfiltered, delete the other query parameters.  Be careful with testing or (god forbid) using /all in your browser, the returned json is huge and will slow down the browser!  Tip: set the HTTP Header \'Accept-Encoding: gzip\' for saving bandwidth. You will need to uncompress it on your end. Example with cURL: ``` curl -sH \'Accept-Encoding: gzip\' <api-endpoint> | gunzip - ```
         * @summary List All Resources
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {'asc' | 'desc'} [sortLevel] sort the resulting list by level, default unsorted
         * @param {string} [filterTypeName] only results with the translated type name
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {'gzip'} [acceptEncoding] optional compression for saving bandwidth
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllItemsResourcesList(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', sortLevel?: 'asc' | 'desc', filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, acceptEncoding?: 'gzip', options?: any): AxiosPromise<ItemsListPaged> {
            return localVarFp.getAllItemsResourcesList(language, game, sortLevel, filterTypeName, filterMinLevel, filterMaxLevel, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * Search in all names and descriptions of resource items with a query.
         * @summary Search Resources
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {string} query case sensitive search query
         * @param {string} [filterTypeName] only results with the translated type name
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsResourceSearch(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', query: string, filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, options?: any): AxiosPromise<Array<ItemListEntry>> {
            return localVarFp.getItemsResourceSearch(language, game, query, filterTypeName, filterMinLevel, filterMaxLevel, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of resource items.
         * @summary List Resources
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {'asc' | 'desc'} [sortLevel] sort the resulting list by level, default unsorted
         * @param {string} [filterTypeName] only results with the translated type name
         * @param {number} [filterMinLevel] only results which level is equal or above this value
         * @param {number} [filterMaxLevel] only results which level is equal or below this value
         * @param {number} [pageSize] size of the results from the list. -1 disables pagination and gets all in one response.
         * @param {number} [pageNumber] page number based on the current page[size]. So you could get page 1 with 8 entrys and page 2 would have entries 8 to 16.
         * @param {Set<'recipe' | 'description' | 'conditions' | 'effects'>} [fieldsItem] adds fields from their detail endpoint to the item list entries. Multiple comma separated values allowed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsResourcesList(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', sortLevel?: 'asc' | 'desc', filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, pageSize?: number, pageNumber?: number, fieldsItem?: Set<'recipe' | 'description' | 'conditions' | 'effects'>, options?: any): AxiosPromise<ItemsListPaged> {
            return localVarFp.getItemsResourcesList(language, game, sortLevel, filterTypeName, filterMinLevel, filterMaxLevel, pageSize, pageNumber, fieldsItem, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific resource item with id.
         * @summary Single Resources
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {number} ankamaId identifier
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsResourcesSingle(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', ankamaId: number, game: 'dofus2' | 'dofus2beta', options?: any): AxiosPromise<Resource> {
            return localVarFp.getItemsResourcesSingle(language, ankamaId, game, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResourcesApi - object-oriented interface
 * @export
 * @class ResourcesApi
 * @extends {BaseAPI}
 */
export class ResourcesApi extends BaseAPI {
    /**
     * Retrieve all resource items with one request. This endpoint is just an alias for the a list with disabled pagination (page[size]=-1) and all fields[type] set.  If you want everything unfiltered, delete the other query parameters.  Be careful with testing or (god forbid) using /all in your browser, the returned json is huge and will slow down the browser!  Tip: set the HTTP Header \'Accept-Encoding: gzip\' for saving bandwidth. You will need to uncompress it on your end. Example with cURL: ``` curl -sH \'Accept-Encoding: gzip\' <api-endpoint> | gunzip - ```
     * @summary List All Resources
     * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
     * @param {'dofus2' | 'dofus2beta'} game 
     * @param {'asc' | 'desc'} [sortLevel] sort the resulting list by level, default unsorted
     * @param {string} [filterTypeName] only results with the translated type name
     * @param {number} [filterMinLevel] only results which level is equal or above this value
     * @param {number} [filterMaxLevel] only results which level is equal or below this value
     * @param {'gzip'} [acceptEncoding] optional compression for saving bandwidth
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourcesApi
     */
    public getAllItemsResourcesList(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', sortLevel?: 'asc' | 'desc', filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, acceptEncoding?: 'gzip', options?: AxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).getAllItemsResourcesList(language, game, sortLevel, filterTypeName, filterMinLevel, filterMaxLevel, acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search in all names and descriptions of resource items with a query.
     * @summary Search Resources
     * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
     * @param {'dofus2' | 'dofus2beta'} game 
     * @param {string} query case sensitive search query
     * @param {string} [filterTypeName] only results with the translated type name
     * @param {number} [filterMinLevel] only results which level is equal or above this value
     * @param {number} [filterMaxLevel] only results which level is equal or below this value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourcesApi
     */
    public getItemsResourceSearch(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', query: string, filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, options?: AxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).getItemsResourceSearch(language, game, query, filterTypeName, filterMinLevel, filterMaxLevel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of resource items.
     * @summary List Resources
     * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
     * @param {'dofus2' | 'dofus2beta'} game 
     * @param {'asc' | 'desc'} [sortLevel] sort the resulting list by level, default unsorted
     * @param {string} [filterTypeName] only results with the translated type name
     * @param {number} [filterMinLevel] only results which level is equal or above this value
     * @param {number} [filterMaxLevel] only results which level is equal or below this value
     * @param {number} [pageSize] size of the results from the list. -1 disables pagination and gets all in one response.
     * @param {number} [pageNumber] page number based on the current page[size]. So you could get page 1 with 8 entrys and page 2 would have entries 8 to 16.
     * @param {Set<'recipe' | 'description' | 'conditions' | 'effects'>} [fieldsItem] adds fields from their detail endpoint to the item list entries. Multiple comma separated values allowed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourcesApi
     */
    public getItemsResourcesList(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', sortLevel?: 'asc' | 'desc', filterTypeName?: string, filterMinLevel?: number, filterMaxLevel?: number, pageSize?: number, pageNumber?: number, fieldsItem?: Set<'recipe' | 'description' | 'conditions' | 'effects'>, options?: AxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).getItemsResourcesList(language, game, sortLevel, filterTypeName, filterMinLevel, filterMaxLevel, pageSize, pageNumber, fieldsItem, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific resource item with id.
     * @summary Single Resources
     * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
     * @param {number} ankamaId identifier
     * @param {'dofus2' | 'dofus2beta'} game 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourcesApi
     */
    public getItemsResourcesSingle(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', ankamaId: number, game: 'dofus2' | 'dofus2beta', options?: AxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).getItemsResourcesSingle(language, ankamaId, game, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SetsApi - axios parameter creator
 * @export
 */
export const SetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve all sets with one request. This endpoint is just an alias for the a list with disabled pagination (page[size]=-1) and all fields[type] set.  If you want everything unfiltered, delete the other query parameters.  Be careful with testing or (god forbid) using /all in your browser, the returned json is huge and will slow down the browser!  Tip: set the HTTP Header \'Accept-Encoding: gzip\' for saving bandwidth. You will need to uncompress it on your end. Example with cURL: ``` curl -sH \'Accept-Encoding: gzip\' <api-endpoint> | gunzip - ```
         * @summary List All Sets
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {'asc' | 'desc'} [sortLevel] sort the resulting list by level, default unsorted
         * @param {number} [filterMinHighestEquipmentLevel] only results where the equipment with the highest level is above or equal to this value
         * @param {number} [filterMaxHighestEquipmentLevel] only results where the equipment with the highest level is below or equal to this value
         * @param {'gzip'} [acceptEncoding] optional compression for saving bandwidth
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSetsList: async (language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', sortLevel?: 'asc' | 'desc', filterMinHighestEquipmentLevel?: number, filterMaxHighestEquipmentLevel?: number, acceptEncoding?: 'gzip', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getAllSetsList', 'language', language)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getAllSetsList', 'game', game)
            const localVarPath = `/{game}/{language}/sets/all`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sortLevel !== undefined) {
                localVarQueryParameter['sort[level]'] = sortLevel;
            }

            if (filterMinHighestEquipmentLevel !== undefined) {
                localVarQueryParameter['filter[min_highest_equipment_level]'] = filterMinHighestEquipmentLevel;
            }

            if (filterMaxHighestEquipmentLevel !== undefined) {
                localVarQueryParameter['filter[max_highest_equipment_level]'] = filterMaxHighestEquipmentLevel;
            }

            if (acceptEncoding != null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of sets.
         * @summary List Sets
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {'asc' | 'desc'} [sortLevel] sort the resulting list by level, default unsorted
         * @param {number} [filterMinHighestEquipmentLevel] only results where the equipment with the highest level is above or equal to this value
         * @param {number} [filterMaxHighestEquipmentLevel] only results where the equipment with the highest level is below or equal to this value
         * @param {number} [pageSize] size of the results from the list. -1 disables pagination and gets all in one response.
         * @param {number} [pageNumber] page number based on the current page[size]. So you could get page 1 with 8 entrys and page 2 would have entries 8 to 16.
         * @param {Set<'effects' | 'equipment_ids'>} [fieldsSet] adds fields from their detail endpoint to the item list entries. Multiple comma separated values allowed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSetsList: async (language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', sortLevel?: 'asc' | 'desc', filterMinHighestEquipmentLevel?: number, filterMaxHighestEquipmentLevel?: number, pageSize?: number, pageNumber?: number, fieldsSet?: Set<'effects' | 'equipment_ids'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getSetsList', 'language', language)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getSetsList', 'game', game)
            const localVarPath = `/{game}/{language}/sets`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sortLevel !== undefined) {
                localVarQueryParameter['sort[level]'] = sortLevel;
            }

            if (filterMinHighestEquipmentLevel !== undefined) {
                localVarQueryParameter['filter[min_highest_equipment_level]'] = filterMinHighestEquipmentLevel;
            }

            if (filterMaxHighestEquipmentLevel !== undefined) {
                localVarQueryParameter['filter[max_highest_equipment_level]'] = filterMaxHighestEquipmentLevel;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page[size]'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['page[number]'] = pageNumber;
            }

            if (fieldsSet) {
                localVarQueryParameter['fields[set]'] = Array.from(fieldsSet).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search in all names and descriptions of sets with a query.
         * @summary Search Sets
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {string} query case sensitive search query
         * @param {number} [filterMinHighestEquipmentLevel] only results where the equipment with the highest level is above or equal to this value
         * @param {number} [filterMaxHighestEquipmentLevel] only results where the equipment with the highest level is below or equal to this value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSetsSearch: async (language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', query: string, filterMinHighestEquipmentLevel?: number, filterMaxHighestEquipmentLevel?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getSetsSearch', 'language', language)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getSetsSearch', 'game', game)
            // verify required parameter 'query' is not null or undefined
            assertParamExists('getSetsSearch', 'query', query)
            const localVarPath = `/{game}/{language}/sets/search`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (filterMinHighestEquipmentLevel !== undefined) {
                localVarQueryParameter['filter[min_highest_equipment_level]'] = filterMinHighestEquipmentLevel;
            }

            if (filterMaxHighestEquipmentLevel !== undefined) {
                localVarQueryParameter['filter[max_highest_equipment_level]'] = filterMaxHighestEquipmentLevel;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific set with id.
         * @summary Single Sets
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {number} ankamaId identifier
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSetsSingle: async (language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', ankamaId: number, game: 'dofus2' | 'dofus2beta', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getSetsSingle', 'language', language)
            // verify required parameter 'ankamaId' is not null or undefined
            assertParamExists('getSetsSingle', 'ankamaId', ankamaId)
            // verify required parameter 'game' is not null or undefined
            assertParamExists('getSetsSingle', 'game', game)
            const localVarPath = `/{game}/{language}/sets/{ankama_id}`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"ankama_id"}}`, encodeURIComponent(String(ankamaId)))
                .replace(`{${"game"}}`, encodeURIComponent(String(game)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SetsApi - functional programming interface
 * @export
 */
export const SetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SetsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve all sets with one request. This endpoint is just an alias for the a list with disabled pagination (page[size]=-1) and all fields[type] set.  If you want everything unfiltered, delete the other query parameters.  Be careful with testing or (god forbid) using /all in your browser, the returned json is huge and will slow down the browser!  Tip: set the HTTP Header \'Accept-Encoding: gzip\' for saving bandwidth. You will need to uncompress it on your end. Example with cURL: ``` curl -sH \'Accept-Encoding: gzip\' <api-endpoint> | gunzip - ```
         * @summary List All Sets
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {'asc' | 'desc'} [sortLevel] sort the resulting list by level, default unsorted
         * @param {number} [filterMinHighestEquipmentLevel] only results where the equipment with the highest level is above or equal to this value
         * @param {number} [filterMaxHighestEquipmentLevel] only results where the equipment with the highest level is below or equal to this value
         * @param {'gzip'} [acceptEncoding] optional compression for saving bandwidth
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllSetsList(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', sortLevel?: 'asc' | 'desc', filterMinHighestEquipmentLevel?: number, filterMaxHighestEquipmentLevel?: number, acceptEncoding?: 'gzip', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetsListPaged>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllSetsList(language, game, sortLevel, filterMinHighestEquipmentLevel, filterMaxHighestEquipmentLevel, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a list of sets.
         * @summary List Sets
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {'asc' | 'desc'} [sortLevel] sort the resulting list by level, default unsorted
         * @param {number} [filterMinHighestEquipmentLevel] only results where the equipment with the highest level is above or equal to this value
         * @param {number} [filterMaxHighestEquipmentLevel] only results where the equipment with the highest level is below or equal to this value
         * @param {number} [pageSize] size of the results from the list. -1 disables pagination and gets all in one response.
         * @param {number} [pageNumber] page number based on the current page[size]. So you could get page 1 with 8 entrys and page 2 would have entries 8 to 16.
         * @param {Set<'effects' | 'equipment_ids'>} [fieldsSet] adds fields from their detail endpoint to the item list entries. Multiple comma separated values allowed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSetsList(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', sortLevel?: 'asc' | 'desc', filterMinHighestEquipmentLevel?: number, filterMaxHighestEquipmentLevel?: number, pageSize?: number, pageNumber?: number, fieldsSet?: Set<'effects' | 'equipment_ids'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetsListPaged>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSetsList(language, game, sortLevel, filterMinHighestEquipmentLevel, filterMaxHighestEquipmentLevel, pageSize, pageNumber, fieldsSet, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Search in all names and descriptions of sets with a query.
         * @summary Search Sets
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {string} query case sensitive search query
         * @param {number} [filterMinHighestEquipmentLevel] only results where the equipment with the highest level is above or equal to this value
         * @param {number} [filterMaxHighestEquipmentLevel] only results where the equipment with the highest level is below or equal to this value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSetsSearch(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', query: string, filterMinHighestEquipmentLevel?: number, filterMaxHighestEquipmentLevel?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SetListEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSetsSearch(language, game, query, filterMinHighestEquipmentLevel, filterMaxHighestEquipmentLevel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a specific set with id.
         * @summary Single Sets
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {number} ankamaId identifier
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSetsSingle(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', ankamaId: number, game: 'dofus2' | 'dofus2beta', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EquipmentSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSetsSingle(language, ankamaId, game, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SetsApi - factory interface
 * @export
 */
export const SetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SetsApiFp(configuration)
    return {
        /**
         * Retrieve all sets with one request. This endpoint is just an alias for the a list with disabled pagination (page[size]=-1) and all fields[type] set.  If you want everything unfiltered, delete the other query parameters.  Be careful with testing or (god forbid) using /all in your browser, the returned json is huge and will slow down the browser!  Tip: set the HTTP Header \'Accept-Encoding: gzip\' for saving bandwidth. You will need to uncompress it on your end. Example with cURL: ``` curl -sH \'Accept-Encoding: gzip\' <api-endpoint> | gunzip - ```
         * @summary List All Sets
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {'asc' | 'desc'} [sortLevel] sort the resulting list by level, default unsorted
         * @param {number} [filterMinHighestEquipmentLevel] only results where the equipment with the highest level is above or equal to this value
         * @param {number} [filterMaxHighestEquipmentLevel] only results where the equipment with the highest level is below or equal to this value
         * @param {'gzip'} [acceptEncoding] optional compression for saving bandwidth
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSetsList(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', sortLevel?: 'asc' | 'desc', filterMinHighestEquipmentLevel?: number, filterMaxHighestEquipmentLevel?: number, acceptEncoding?: 'gzip', options?: any): AxiosPromise<SetsListPaged> {
            return localVarFp.getAllSetsList(language, game, sortLevel, filterMinHighestEquipmentLevel, filterMaxHighestEquipmentLevel, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of sets.
         * @summary List Sets
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {'asc' | 'desc'} [sortLevel] sort the resulting list by level, default unsorted
         * @param {number} [filterMinHighestEquipmentLevel] only results where the equipment with the highest level is above or equal to this value
         * @param {number} [filterMaxHighestEquipmentLevel] only results where the equipment with the highest level is below or equal to this value
         * @param {number} [pageSize] size of the results from the list. -1 disables pagination and gets all in one response.
         * @param {number} [pageNumber] page number based on the current page[size]. So you could get page 1 with 8 entrys and page 2 would have entries 8 to 16.
         * @param {Set<'effects' | 'equipment_ids'>} [fieldsSet] adds fields from their detail endpoint to the item list entries. Multiple comma separated values allowed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSetsList(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', sortLevel?: 'asc' | 'desc', filterMinHighestEquipmentLevel?: number, filterMaxHighestEquipmentLevel?: number, pageSize?: number, pageNumber?: number, fieldsSet?: Set<'effects' | 'equipment_ids'>, options?: any): AxiosPromise<SetsListPaged> {
            return localVarFp.getSetsList(language, game, sortLevel, filterMinHighestEquipmentLevel, filterMaxHighestEquipmentLevel, pageSize, pageNumber, fieldsSet, options).then((request) => request(axios, basePath));
        },
        /**
         * Search in all names and descriptions of sets with a query.
         * @summary Search Sets
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {string} query case sensitive search query
         * @param {number} [filterMinHighestEquipmentLevel] only results where the equipment with the highest level is above or equal to this value
         * @param {number} [filterMaxHighestEquipmentLevel] only results where the equipment with the highest level is below or equal to this value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSetsSearch(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', query: string, filterMinHighestEquipmentLevel?: number, filterMaxHighestEquipmentLevel?: number, options?: any): AxiosPromise<Array<SetListEntry>> {
            return localVarFp.getSetsSearch(language, game, query, filterMinHighestEquipmentLevel, filterMaxHighestEquipmentLevel, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific set with id.
         * @summary Single Sets
         * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
         * @param {number} ankamaId identifier
         * @param {'dofus2' | 'dofus2beta'} game 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSetsSingle(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', ankamaId: number, game: 'dofus2' | 'dofus2beta', options?: any): AxiosPromise<EquipmentSet> {
            return localVarFp.getSetsSingle(language, ankamaId, game, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SetsApi - object-oriented interface
 * @export
 * @class SetsApi
 * @extends {BaseAPI}
 */
export class SetsApi extends BaseAPI {
    /**
     * Retrieve all sets with one request. This endpoint is just an alias for the a list with disabled pagination (page[size]=-1) and all fields[type] set.  If you want everything unfiltered, delete the other query parameters.  Be careful with testing or (god forbid) using /all in your browser, the returned json is huge and will slow down the browser!  Tip: set the HTTP Header \'Accept-Encoding: gzip\' for saving bandwidth. You will need to uncompress it on your end. Example with cURL: ``` curl -sH \'Accept-Encoding: gzip\' <api-endpoint> | gunzip - ```
     * @summary List All Sets
     * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
     * @param {'dofus2' | 'dofus2beta'} game 
     * @param {'asc' | 'desc'} [sortLevel] sort the resulting list by level, default unsorted
     * @param {number} [filterMinHighestEquipmentLevel] only results where the equipment with the highest level is above or equal to this value
     * @param {number} [filterMaxHighestEquipmentLevel] only results where the equipment with the highest level is below or equal to this value
     * @param {'gzip'} [acceptEncoding] optional compression for saving bandwidth
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetsApi
     */
    public getAllSetsList(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', sortLevel?: 'asc' | 'desc', filterMinHighestEquipmentLevel?: number, filterMaxHighestEquipmentLevel?: number, acceptEncoding?: 'gzip', options?: AxiosRequestConfig) {
        return SetsApiFp(this.configuration).getAllSetsList(language, game, sortLevel, filterMinHighestEquipmentLevel, filterMaxHighestEquipmentLevel, acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of sets.
     * @summary List Sets
     * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
     * @param {'dofus2' | 'dofus2beta'} game 
     * @param {'asc' | 'desc'} [sortLevel] sort the resulting list by level, default unsorted
     * @param {number} [filterMinHighestEquipmentLevel] only results where the equipment with the highest level is above or equal to this value
     * @param {number} [filterMaxHighestEquipmentLevel] only results where the equipment with the highest level is below or equal to this value
     * @param {number} [pageSize] size of the results from the list. -1 disables pagination and gets all in one response.
     * @param {number} [pageNumber] page number based on the current page[size]. So you could get page 1 with 8 entrys and page 2 would have entries 8 to 16.
     * @param {Set<'effects' | 'equipment_ids'>} [fieldsSet] adds fields from their detail endpoint to the item list entries. Multiple comma separated values allowed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetsApi
     */
    public getSetsList(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', sortLevel?: 'asc' | 'desc', filterMinHighestEquipmentLevel?: number, filterMaxHighestEquipmentLevel?: number, pageSize?: number, pageNumber?: number, fieldsSet?: Set<'effects' | 'equipment_ids'>, options?: AxiosRequestConfig) {
        return SetsApiFp(this.configuration).getSetsList(language, game, sortLevel, filterMinHighestEquipmentLevel, filterMaxHighestEquipmentLevel, pageSize, pageNumber, fieldsSet, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search in all names and descriptions of sets with a query.
     * @summary Search Sets
     * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
     * @param {'dofus2' | 'dofus2beta'} game 
     * @param {string} query case sensitive search query
     * @param {number} [filterMinHighestEquipmentLevel] only results where the equipment with the highest level is above or equal to this value
     * @param {number} [filterMaxHighestEquipmentLevel] only results where the equipment with the highest level is below or equal to this value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetsApi
     */
    public getSetsSearch(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', game: 'dofus2' | 'dofus2beta', query: string, filterMinHighestEquipmentLevel?: number, filterMaxHighestEquipmentLevel?: number, options?: AxiosRequestConfig) {
        return SetsApiFp(this.configuration).getSetsSearch(language, game, query, filterMinHighestEquipmentLevel, filterMaxHighestEquipmentLevel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific set with id.
     * @summary Single Sets
     * @param {'en' | 'fr' | 'de' | 'it' | 'es' | 'pt'} language a valid language code
     * @param {number} ankamaId identifier
     * @param {'dofus2' | 'dofus2beta'} game 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetsApi
     */
    public getSetsSingle(language: 'en' | 'fr' | 'de' | 'it' | 'es' | 'pt', ankamaId: number, game: 'dofus2' | 'dofus2beta', options?: AxiosRequestConfig) {
        return SetsApiFp(this.configuration).getSetsSingle(language, ankamaId, game, options).then((request) => request(this.axios, this.basePath));
    }
}


